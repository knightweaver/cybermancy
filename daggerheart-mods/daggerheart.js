'use strict';

const compendiumJournals = {
    welcome: 'Compendium.daggerheart.journals.JournalEntry.g7NhKvwltwafmMyR'
};

const ruleChoice = {
    on: {
        id: 'on',
        label: 'DAGGERHEART.CONFIG.RuleChoice.on'
    },
    of: {
        id: 'off',
        label: 'DAGGERHEART.CONFIG.RuleChoice.off'
    },
    onWithToggle: {
        id: 'onWithToggle',
        label: 'DAGGERHEART.CONFIG.RuleChoice.onWithToggle'
    },
    offWithToggle: {
        id: 'offWithToggle',
        label: 'DAGGERHEART.CONFIG.RuleChoice.offWithToggle'
    }
};

const templateRanges = {
    self: {
        id: 'self',
        short: 's',
        label: 'DAGGERHEART.CONFIG.Range.self.name',
        description: 'DAGGERHEART.CONFIG.Range.self.description',
        distance: 0
    },
    melee: {
        id: 'melee',
        short: 'm',
        label: 'DAGGERHEART.CONFIG.Range.melee.name',
        description: 'DAGGERHEART.CONFIG.Range.melee.description',
        distance: 1
    },
    veryClose: {
        id: 'veryClose',
        short: 'vc',
        label: 'DAGGERHEART.CONFIG.Range.veryClose.name',
        description: 'DAGGERHEART.CONFIG.Range.veryClose.description',
        distance: 3
    },
    close: {
        id: 'close',
        short: 'c',
        label: 'DAGGERHEART.CONFIG.Range.close.name',
        description: 'DAGGERHEART.CONFIG.Range.close.description',
        distance: 10
    },
    far: {
        id: 'far',
        short: 'f',
        label: 'DAGGERHEART.CONFIG.Range.far.name',
        description: 'DAGGERHEART.CONFIG.Range.far.description',
        distance: 20
    }
};

const range = {
    ...templateRanges,
    veryFar: {
        id: 'veryFar',
        short: 'vf',
        label: 'DAGGERHEART.CONFIG.Range.veryFar.name',
        description: 'DAGGERHEART.CONFIG.Range.veryFar.description',
        distance: 30
    }
};

const templateTypes = {
    ...CONST.MEASURED_TEMPLATE_TYPES,
    EMANATION: 'emanation',
    INFRONT: 'inFront'
};

const rangeInclusion = {
    withinRange: {
        id: 'withinRange',
        label: 'DAGGERHEART.CONFIG.RangeInclusion.withinRange'
    },
    outsideRange: {
        id: 'outsideRange',
        label: 'DAGGERHEART.CONFIG.RangeInclusion.outsideRange'
    }
};

const otherTargetTypes = {
    friendly: {
        id: 'friendly',
        label: 'Friendly'
    },
    hostile: {
        id: 'hostile',
        label: 'Hostile'
    },
    any: {
        id: 'any',
        label: 'Any'
    }
};

const targetTypes = {
    self: {
        id: 'self',
        label: 'Self'
    },
    ...otherTargetTypes
};

const burden = {
    oneHanded: {
        value: 'oneHanded',
        label: 'DAGGERHEART.CONFIG.Burden.oneHanded'
    },
    twoHanded: {
        value: 'twoHanded',
        label: 'DAGGERHEART.CONFIG.Burden.twoHanded'
    }
};

const damageTypes = {
    physical: {
        id: 'physical',
        label: 'DAGGERHEART.CONFIG.DamageType.physical.name',
        abbreviation: 'DAGGERHEART.CONFIG.DamageType.physical.abbreviation',
        icon: 'fa-hand-fist'
    },
    magical: {
        id: 'magical',
        label: 'DAGGERHEART.CONFIG.DamageType.magical.name',
        abbreviation: 'DAGGERHEART.CONFIG.DamageType.magical.abbreviation',
        icon: 'fa-wand-sparkles'
    }
};

const healingTypes = {
    hitPoints: {
        id: 'hitPoints',
        label: 'DAGGERHEART.CONFIG.HealingType.hitPoints.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.hitPoints.abbreviation'
    },
    stress: {
        id: 'stress',
        label: 'DAGGERHEART.CONFIG.HealingType.stress.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.stress.abbreviation'
    },
    hope: {
        id: 'hope',
        label: 'DAGGERHEART.CONFIG.HealingType.hope.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.hope.abbreviation'
    },
    armor: {
        id: 'armor',
        label: 'DAGGERHEART.CONFIG.HealingType.armor.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.armor.abbreviation'
    },
    fear: {
        id: 'fear',
        label: 'DAGGERHEART.CONFIG.HealingType.fear.name',
        abbreviation: 'DAGGERHEART.CONFIG.HealingType.fear.abbreviation'
    }
};

const defeatedConditions = {
    defeated: {
        id: 'defeated',
        name: 'DAGGERHEART.CONFIG.Condition.defeated.name',
        img: 'icons/magic/control/fear-fright-mask-orange.webp',
        description: 'DAGGERHEART.CONFIG.Condition.defeated.description'
    },
    unconscious: {
        id: 'unconscious',
        name: 'DAGGERHEART.CONFIG.Condition.unconscious.name',
        img: 'icons/magic/control/sleep-bubble-purple.webp',
        description: 'DAGGERHEART.CONFIG.Condition.unconscious.description'
    },
    dead: {
        id: 'dead',
        name: 'DAGGERHEART.CONFIG.Condition.dead.name',
        img: 'icons/magic/death/grave-tombstone-glow-teal.webp',
        description: 'DAGGERHEART.CONFIG.Condition.dead.description'
    }
};

const conditions = {
    vulnerable: {
        id: 'vulnerable',
        name: 'DAGGERHEART.CONFIG.Condition.vulnerable.name',
        img: 'icons/magic/control/silhouette-fall-slip-prone.webp',
        description: 'DAGGERHEART.CONFIG.Condition.vulnerable.description'
    },
    hidden: {
        id: 'hidden',
        name: 'DAGGERHEART.CONFIG.Condition.hidden.name',
        img: 'icons/magic/perception/silhouette-stealth-shadow.webp',
        description: 'DAGGERHEART.CONFIG.Condition.hidden.description'
    },
    restrained: {
        id: 'restrained',
        name: 'DAGGERHEART.CONFIG.Condition.restrained.name',
        img: 'icons/magic/control/debuff-chains-shackle-movement-red.webp',
        description: 'DAGGERHEART.CONFIG.Condition.restrained.description'
    },
    ...defeatedConditions
};

const defaultRestOptions = {
    shortRest: () => ({
        tendToWounds: {
            id: 'tendToWounds',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.name'),
            icon: 'fa-solid fa-bandage',
            img: 'icons/magic/life/cross-worn-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.description'),
            actions: {
                tendToWounds: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.tendToWounds.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.tendToWounds.name'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.hitPoints.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        clearStress: {
            id: 'clearStress',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.name'),
            icon: 'fa-regular fa-face-surprise',
            img: 'icons/magic/perception/eye-ringed-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.description'),
            actions: {
                clearStress: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.clearStress.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.clearStress.name'),
                    img: 'icons/magic/perception/eye-ringed-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.stress.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        repairArmor: {
            id: 'repairArmor',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.name'),
            icon: 'fa-solid fa-hammer',
            img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.description'),
            actions: {
                repairArmor: {
                    type: 'healing',
                    systemPath: 'restMoves.shortRest.moves.repairArmor.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.repairArmor.name'),
                    img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.armor.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '1d4 + @tier'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        prepare: {
            id: 'prepare',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.prepare.name'),
            icon: 'fa-solid fa-dumbbell',
            img: 'icons/skills/trades/academics-merchant-scribe.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.shortRest.prepare.description'),
            actions: {}
        }
    }),
    longRest: () => ({
        tendToWounds: {
            id: 'tendToWounds',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.name'),
            icon: 'fa-solid fa-bandage',
            img: 'icons/magic/life/cross-worn-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.description'),
            actions: {
                tendToWounds: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.tendToWounds.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.tendToWounds.name'),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.hitPoints.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.resources.hitPoints.max'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        clearStress: {
            id: 'clearStress',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.name'),
            icon: 'fa-regular fa-face-surprise',
            img: 'icons/magic/perception/eye-ringed-green.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.description'),
            actions: {
                clearStress: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.clearStress.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.clearStress.name'),
                    img: 'icons/magic/perception/eye-ringed-green.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.stress.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.resources.stress.max'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        repairArmor: {
            id: 'repairArmor',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.name'),
            icon: 'fa-solid fa-hammer',
            img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.description'),
            actions: {
                repairArmor: {
                    type: 'healing',
                    systemPath: 'restMoves.longRest.moves.repairArmor.actions',
                    name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.repairArmor.name'),
                    img: 'icons/skills/trades/smithing-anvil-silver-red.webp',
                    actionType: 'action',
                    chatDisplay: false,
                    target: {
                        type: 'self'
                    },
                    damage: {
                        parts: [
                            {
                                applyTo: healingTypes.armor.id,
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@system.armorScore'
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        },
        prepare: {
            id: 'prepare',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.prepare.name'),
            icon: 'fa-solid fa-dumbbell',
            img: 'icons/skills/trades/academics-merchant-scribe.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.prepare.description'),
            actions: {}
        },
        workOnAProject: {
            id: 'workOnAProject',
            name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.workOnAProject.name'),
            icon: 'fa-solid fa-diagram-project',
            img: 'icons/skills/social/thumbsup-approval-like.webp',
            description: game.i18n.localize('DAGGERHEART.APPLICATIONS.Downtime.longRest.workOnAProject.description'),
            actions: {}
        }
    })
};

const deathMoves = {
    avoidDeath: {
        id: 'avoidDeath',
        name: 'DAGGERHEART.CONFIG.DeathMoves.avoidDeath.name',
        img: 'icons/magic/time/hourglass-yellow-green.webp',
        icon: 'fa-person-running',
        description: 'DAGGERHEART.CONFIG.DeathMoves.avoidDeath.description'
    },
    riskItAll: {
        id: 'riskItAll',
        name: 'DAGGERHEART.CONFIG.DeathMoves.riskItAll.name',
        img: 'icons/sundries/gaming/dice-pair-white-green.webp',
        icon: 'fa-dice',
        description: 'DAGGERHEART.CONFIG.DeathMoves.riskItAll.description'
    },
    blazeOfGlory: {
        id: 'blazeOfGlory',
        name: 'DAGGERHEART.CONFIG.DeathMoves.blazeOfGlory.name',
        img: 'icons/magic/life/heart-cross-strong-flame-purple-orange.webp',
        icon: 'fa-burst',
        description: 'DAGGERHEART.CONFIG.DeathMoves.blazeOfGlory.description'
    }
};

const tiers = {
    1: {
        id: 1,
        label: 'DAGGERHEART.GENERAL.Tiers.1'
    },
    2: {
        id: 2,
        label: 'DAGGERHEART.GENERAL.Tiers.2'
    },
    3: {
        id: 3,
        label: 'DAGGERHEART.GENERAL.Tiers.3'
    },
    4: {
        id: 4,
        label: 'DAGGERHEART.GENERAL.Tiers.4'
    }
};

const diceTypes = {
    d4: 'd4',
    d6: 'd6',
    d8: 'd8',
    d10: 'd10',
    d12: 'd12',
    d20: 'd20'
};

const multiplierTypes = {
    prof: 'Proficiency',
    cast: 'Spellcast',
    scale: 'Cost Scaling',
    result: 'Roll Result',
    flat: 'Flat',
    tier: 'Tier'
};

const diceSetNumbers = {
    prof: 'Proficiency',
    cast: 'Spellcast',
    scale: 'Cost Scaling',
    flat: 'Flat'
};

const getDiceSoNicePreset = async (type, faces) => {
    const system = game.dice3d.DiceFactory.systems.get(type.system).dice.get(faces);
    if (!system) {
        ui.notifications.error(
            game.i18n.format('DAGGERHEART.UI.Notifications.noDiceSystem', {
                system: game.dice3d.DiceFactory.systems.get(type.system).name,
                faces: faces
            })
        );
        return;
    }

    if (system.modelFile && !system.modelLoaded) {
        await system.loadModel(game.dice3d.DiceFactory.loaderGLTF);
    } else {
        await system.loadTextures();
    }

    return {
        modelFile: system.modelFile,
        appearance: {
            ...system.appearance,
            ...type
        }
    };
};

const getDiceSoNicePresets = async (hopeFaces, fearFaces, advantageFaces = 'd6', disadvantageFaces = 'd6') => {
    const { diceSoNice } = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance);

    return {
        hope: await getDiceSoNicePreset(diceSoNice.hope, hopeFaces),
        fear: await getDiceSoNicePreset(diceSoNice.fear, fearFaces),
        advantage: await getDiceSoNicePreset(diceSoNice.advantage, advantageFaces),
        disadvantage: await getDiceSoNicePreset(diceSoNice.disadvantage, disadvantageFaces)
    };
};

const refreshTypes = {
    scene: {
        id: 'session',
        label: 'DAGGERHEART.GENERAL.RefreshType.scene'
    },
    session: {
        id: 'session',
        label: 'DAGGERHEART.GENERAL.RefreshType.session'
    },
    shortRest: {
        id: 'shortRest',
        label: 'DAGGERHEART.GENERAL.RefreshType.shortrest'
    },
    longRest: {
        id: 'longRest',
        label: 'DAGGERHEART.GENERAL.RefreshType.longrest'
    }
};

const abilityCosts = {
    hitPoints: {
        id: 'hitPoints',
        label: 'DAGGERHEART.CONFIG.HealingType.hitPoints.name',
        group: 'Global'
    },
    stress: {
        id: 'stress',
        label: 'DAGGERHEART.CONFIG.HealingType.stress.name',
        group: 'Global'
    },
    hope: {
        id: 'hope',
        label: 'Hope',
        group: 'TYPES.Actor.character'
    },
    armor: {
        id: 'armor',
        label: 'Armor Slot',
        group: 'TYPES.Actor.character'
    },
    fear: {
        id: 'fear',
        label: 'Fear',
        group: 'TYPES.Actor.adversary'
    }
};

const countdownTypes = {
    spotlight: {
        id: 'spotlight',
        label: 'DAGGERHEART.CONFIG.CountdownType.spotlight'
    },
    characterAttack: {
        id: 'characterAttack',
        label: 'DAGGERHEART.CONFIG.CountdownType.characterAttack'
    },
    custom: {
        id: 'custom',
        label: 'DAGGERHEART.CONFIG.CountdownType.custom'
    }
};
const rollTypes = {
    attack: {
        id: 'attack',
        label: 'DAGGERHEART.CONFIG.RollTypes.attack.name'
    },
    spellcast: {
        id: 'spellcast',
        label: 'DAGGERHEART.CONFIG.RollTypes.spellcast.name',
        playerOnly: true
    },
    trait: {
        id: 'trait',
        label: 'DAGGERHEART.CONFIG.RollTypes.trait.name',
        playerOnly: true
    },
    diceSet: {
        id: 'diceSet',
        label: 'DAGGERHEART.CONFIG.RollTypes.diceSet.name'
    }
};

const fearDisplay = {
    token: { value: 'token', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.token' },
    bar: { value: 'bar', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.bar' },
    hide: { value: 'hide', label: 'DAGGERHEART.SETTINGS.Appearance.fearDisplay.hide' }
};

var GENERAL = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abilityCosts: abilityCosts,
    burden: burden,
    compendiumJournals: compendiumJournals,
    conditions: conditions,
    countdownTypes: countdownTypes,
    damageTypes: damageTypes,
    deathMoves: deathMoves,
    defaultRestOptions: defaultRestOptions,
    defeatedConditions: defeatedConditions,
    diceSetNumbers: diceSetNumbers,
    diceTypes: diceTypes,
    fearDisplay: fearDisplay,
    getDiceSoNicePreset: getDiceSoNicePreset,
    getDiceSoNicePresets: getDiceSoNicePresets,
    healingTypes: healingTypes,
    multiplierTypes: multiplierTypes,
    otherTargetTypes: otherTargetTypes,
    range: range,
    rangeInclusion: rangeInclusion,
    refreshTypes: refreshTypes,
    rollTypes: rollTypes,
    ruleChoice: ruleChoice,
    targetTypes: targetTypes,
    templateRanges: templateRanges,
    templateTypes: templateTypes,
    tiers: tiers
});

const domains = {
    arcana: {
        id: 'arcana',
        label: 'DAGGERHEART.GENERAL.Domain.arcana.label',
        src: 'systems/daggerheart/assets/icons/domains/arcana.svg',
        description: 'DAGGERHEART.GENERAL.Domain.arcana.description'
    },
    blade: {
        id: 'blade',
        label: 'DAGGERHEART.GENERAL.Domain.blade.label',
        src: 'systems/daggerheart/assets/icons/domains/blade.svg',
        description: 'DAGGERHEART.GENERAL.Domain.blade.description'
    },
    bone: {
        id: 'bone',
        label: 'DAGGERHEART.GENERAL.Domain.bone.label',
        src: 'systems/daggerheart/assets/icons/domains/bone.svg',
        description: 'DAGGERHEART.GENERAL.Domain.bone.description'
    },
    codex: {
        id: 'codex',
        label: 'DAGGERHEART.GENERAL.Domain.codex.label',
        src: 'systems/daggerheart/assets/icons/domains/codex.svg',
        description: 'DAGGERHEART.GENERAL.Domain.codex.description'
    },
    grace: {
        id: 'grace',
        label: 'DAGGERHEART.GENERAL.Domain.grace.label',
        src: 'systems/daggerheart/assets/icons/domains/grace.svg',
        description: 'DAGGERHEART.GENERAL.Domain.grace.description'
    },
    midnight: {
        id: 'midnight',
        label: 'DAGGERHEART.GENERAL.Domain.midnight.label',
        src: 'systems/daggerheart/assets/icons/domains/midnight.svg',
        description: 'DAGGERHEART.GENERAL.Domain.midnight.description'
    },
    sage: {
        id: 'sage',
        label: 'DAGGERHEART.GENERAL.Domain.sage.label',
        src: 'systems/daggerheart/assets/icons/domains/sage.svg',
        description: 'DAGGERHEART.GENERAL.Domain.sage.description'
    },
    splendor: {
        id: 'splendor',
        label: 'DAGGERHEART.GENERAL.Domain.splendor.label',
        src: 'systems/daggerheart/assets/icons/domains/splendor.svg',
        description: 'DAGGERHEART.GENERAL.Domain.splendor.description'
    },
    valor: {
        id: 'valor',
        label: 'DAGGERHEART.GENERAL.Domain.valor.label',
        src: 'systems/daggerheart/assets/icons/domains/valor.svg',
        description: 'DAGGERHEART.GENERAL.Domain.valor.description'
    },
    circuit: {
        id: 'circuit',
        label: 'DAGGERHEART.GENERAL.Domain.circuit.label',
        src: 'modules/cybermancy/assets/icons/domains/circuit.svg',
        description: 'DAGGERHEART.GENERAL.Domain.circuit.description'
    },
    maker: {
        id: 'maker',
        label: 'DAGGERHEART.GENERAL.Domain.maker.label',
        src: 'modules/cybermancy/assets/icons/domains/maker.svg',
        description: 'DAGGERHEART.GENERAL.Domain.maker.description'
    },
    bullet: {
        id: 'bullet',
        label: 'DAGGERHEART.GENERAL.Domain.bullet.label',
        src: 'modules/cybermancy/assets/icons/domains/bullet.svg',
        description: 'DAGGERHEART.GENERAL.Domain.bullet.description'
    }
};

const allDomains = () => ({
    ...domains,
    ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).domains
});

const orderedDomains = () => {
    const all = {
        ...domains,
        ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).domains
    };
    return Object.values(all).sort((a, b) => game.i18n.localize(a.label).localeCompare(game.i18n.localize(b.label)));
};

const subclassMap = {
    syndicate: {
        id: 'syndicate',
        label: 'Syndicate'
    },
    nightwalker: {
        id: 'nightwalker',
        label: 'Nightwalker'
    }
};

const classMap = {
    rogue: {
        label: 'Rogue',
        subclasses: [subclassMap.syndicate.id, subclassMap.nightwalker.id]
    },
    seraph: {
        label: 'Seraph',
        subclasses: []
    }
};

const cardTypes = {
    ability: {
        id: 'ability',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.ability',
        img: ''
    },
    spell: {
        id: 'spell',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.spell',
        img: ''
    },
    grimoire: {
        id: 'grimoire',
        label: 'DAGGERHEART.CONFIG.DomainCardTypes.grimoire',
        img: ''
    }
};

var DOMAIN = /*#__PURE__*/Object.freeze({
    __proto__: null,
    allDomains: allDomains,
    cardTypes: cardTypes,
    classMap: classMap,
    domains: domains,
    orderedDomains: orderedDomains,
    subclassMap: subclassMap
});

const abilities = {
    agility: {
        id: 'agility',
        label: 'DAGGERHEART.CONFIG.Traits.agility.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.agility.verb.sprint',
            'DAGGERHEART.CONFIG.Traits.agility.verb.leap',
            'DAGGERHEART.CONFIG.Traits.agility.verb.maneuver'
        ]
    },
    strength: {
        id: 'strength',
        label: 'DAGGERHEART.CONFIG.Traits.strength.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.strength.verb.lift',
            'DAGGERHEART.CONFIG.Traits.strength.verb.smash',
            'DAGGERHEART.CONFIG.Traits.strength.verb.grapple'
        ]
    },
    finesse: {
        id: 'finesse',
        label: 'DAGGERHEART.CONFIG.Traits.finesse.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.finesse.verb.control',
            'DAGGERHEART.CONFIG.Traits.finesse.verb.hide',
            'DAGGERHEART.CONFIG.Traits.finesse.verb.tinker'
        ]
    },
    instinct: {
        id: 'instinct',
        label: 'DAGGERHEART.CONFIG.Traits.instinct.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.instinct.verb.perceive',
            'DAGGERHEART.CONFIG.Traits.instinct.verb.sense',
            'DAGGERHEART.CONFIG.Traits.instinct.verb.navigate'
        ]
    },
    presence: {
        id: 'presence',
        label: 'DAGGERHEART.CONFIG.Traits.presence.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.presence.verb.charm',
            'DAGGERHEART.CONFIG.Traits.presence.verb.perform',
            'DAGGERHEART.CONFIG.Traits.presence.verb.deceive'
        ]
    },
    knowledge: {
        id: 'knowledge',
        label: 'DAGGERHEART.CONFIG.Traits.knowledge.name',
        verbs: [
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.recall',
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.analyze',
            'DAGGERHEART.CONFIG.Traits.knowledge.verb.comprehend'
        ]
    }
};

const scrollingTextResource = {
    hitPoints: {
        label: 'DAGGERHEART.GENERAL.HitPoints.plural',
        reversed: true
    },
    stress: {
        label: 'DAGGERHEART.GENERAL.stress',
        reversed: true
    },
    hope: {
        label: 'DAGGERHEART.GENERAL.hope'
    },
    armor: {
        label: 'DAGGERHEART.GENERAL.armor',
        reversed: true
    }
};

const featureProperties = {
    agility: {
        name: 'DAGGERHEART.CONFIG.Traits.agility.name',
        path: actor => actor.system.traits.agility.data.value
    },
    strength: {
        name: 'DAGGERHEART.CONFIG.Traits.strength.name',
        path: actor => actor.system.traits.strength.data.value
    },
    finesse: {
        name: 'DAGGERHEART.CONFIG.Traits.finesse.name',
        path: actor => actor.system.traits.finesse.data.value
    },
    instinct: {
        name: 'DAGGERHEART.CONFIG.Traits.instinct.name',
        path: actor => actor.system.traits.instinct.data.value
    },
    presence: {
        name: 'DAGGERHEART.CONFIG.Traits.presence.name',
        path: actor => actor.system.traits.presence.data.value
    },
    knowledge: {
        name: 'DAGGERHEART.CONFIG.Traits.knowledge.name',
        path: actor => actor.system.traits.knowledge.data.value
    },
    spellcastingTrait: {
        name: 'DAGGERHEART.FeatureProperty.SpellcastingTrait',
        path: actor => actor.system.traits[actor.system.class.subclass.system.spellcastingTrait].data.value
    }
};

const adversaryTypes = {
    bruiser: {
        id: 'bruiser',
        label: 'DAGGERHEART.CONFIG.AdversaryType.bruiser.label',
        description: 'DAGGERHEART.ACTORS.Adversary.bruiser.description'
    },
    horde: {
        id: 'horde',
        label: 'DAGGERHEART.CONFIG.AdversaryType.horde.label',
        description: 'DAGGERHEART.ACTORS.Adversary.horde.description'
    },
    leader: {
        id: 'leader',
        label: 'DAGGERHEART.CONFIG.AdversaryType.leader.label',
        description: 'DAGGERHEART.ACTORS.Adversary.leader.description'
    },
    minion: {
        id: 'minion',
        label: 'DAGGERHEART.CONFIG.AdversaryType.minion.label',
        description: 'DAGGERHEART.ACTORS.Adversary.minion.description'
    },
    ranged: {
        id: 'ranged',
        label: 'DAGGERHEART.CONFIG.AdversaryType.ranged.label',
        description: 'DAGGERHEART.ACTORS.Adversary.ranged.description'
    },
    skulk: {
        id: 'skulk',
        label: 'DAGGERHEART.CONFIG.AdversaryType.skulk.label',
        description: 'DAGGERHEART.ACTORS.Adversary.skulk.description'
    },
    social: {
        id: 'social',
        label: 'DAGGERHEART.CONFIG.AdversaryType.social.label',
        description: 'DAGGERHEART.ACTORS.Adversary.social.description'
    },
    solo: {
        id: 'solo',
        label: 'DAGGERHEART.CONFIG.AdversaryType.solo.label',
        description: 'DAGGERHEART.ACTORS.Adversary.solo.description'
    },
    standard: {
        id: 'standard',
        label: 'DAGGERHEART.CONFIG.AdversaryType.standard.label',
        description: 'DAGGERHEART.ACTORS.Adversary.standard.description'
    },
    support: {
        id: 'support',
        label: 'DAGGERHEART.CONFIG.AdversaryType.support.label',
        description: 'DAGGERHEART.ACTORS.Adversary.support.description'
    }
};

const environmentTypes = {
    exploration: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.exploration.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.exploration.description'
    },
    social: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.social.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.social.description'
    },
    traversal: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.traversal.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.traversal.description'
    },
    event: {
        label: 'DAGGERHEART.CONFIG.EnvironmentType.event.label',
        description: 'DAGGERHEART.CONFIG.EnvironmentType.event.description'
    }
};

const adversaryTraits = {
    relentless: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.relentless.tip'
    },
    slow: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.tip'
    },
    minion: {
        name: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.name',
        description: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.description',
        tip: 'DAGGERHEART.CONFIG.AdversaryTrait.slow.tip'
    }
};

const levelChoices = {
    attributes: {
        name: 'attributes',
        title: '',
        choices: []
    },
    hitPointSlots: {
        name: 'hitPointSlots',
        title: '',
        choices: []
    },
    stressSlots: {
        name: 'stressSlots',
        title: '',
        choices: []
    },
    experiences: {
        name: 'experiences',
        title: '',
        choices: 'system.experiences',
        nrChoices: 2
    },
    proficiency: {
        name: 'proficiency',
        title: '',
        choices: []
    },
    armorOrEvasionSlot: {
        name: 'armorOrEvasionSlot',
        title: 'Permanently add one Armor Slot or take +1 to your Evasion',
        choices: [
            { name: 'Armor Marks +1', path: 'armor' },
            { name: 'Evasion +1', path: 'evasion' }
        ],
        nrChoices: 1
    },
    majorDamageThreshold2: {
        name: 'majorDamageThreshold2',
        title: '',
        choices: []
    },
    severeDamageThreshold2: {
        name: 'severeDamageThreshold2',
        title: '',
        choices: []
    },
    // minorDamageThreshold2: {
    //     name: 'minorDamageThreshold2',
    //     title: '',
    //     choices: [],
    // },
    severeDamageThreshold3: {
        name: 'severeDamageThreshold3',
        title: '',
        choices: []
    },
    // major2OrSevere4DamageThreshold: {
    //     name: 'major2OrSevere4DamageThreshold',
    //     title: 'Increase your Major Damage Threshold by +2 or Severe Damage Threshold by +4',
    //     choices: [{ name: 'Major Damage Threshold +2', path: 'major' }, { name: 'Severe Damage Threshold +4', path: 'severe' }],
    //     nrChoices: 1,
    // },
    // minor1OrMajor1DamageThreshold: {
    //     name: 'minor1OrMajor1DamageThreshold',
    //     title: 'Increase your Minor or Major Damage Threshold by +1',
    //     choices: [{ name: 'Minor Damage Threshold +1', path: 'minor' }, { name: 'Major Damage Threshold +1', path: 'major' }],
    //     nrChoices: 1,
    // },
    severeDamageThreshold4: {
        name: 'severeDamageThreshold4',
        title: '',
        choices: []
    },
    // majorDamageThreshold1: {
    //     name: 'majorDamageThreshold2',
    //     title: '',
    //     choices: [],
    // },
    subclass: {
        name: 'subclass',
        title: 'Select subclass to upgrade',
        choices: []
    },
    multiclass: {
        name: 'multiclass',
        title: '',
        choices: [{}]
    }
};

const levelupData = {
    tier1: {
        id: '2_4',
        tier: 1,
        levels: [2, 3, 4],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier1.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 1
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 1
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 1
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 1
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold2',
                maxChoices: 1
            }
        }
    },
    tier2: {
        id: '5_7',
        tier: 2,
        levels: [5, 6, 7],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier2.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 2
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 2
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 2
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 2
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold3.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold3',
                maxChoices: 1
            },
            [levelChoices.subclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.subclass',
                maxChoices: 1
            },
            [levelChoices.multiclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.multiclass',
                maxChoices: 1,
                cost: 2
            }
        }
    },
    tier3: {
        id: '8_10',
        tier: 3,
        levels: [8, 9, 10],
        label: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Label',
        info: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.InfoLabel',
        pretext: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Pretext',
        posttext: 'DAGGERHEART.APPLICATIONS.Levelup.tier3.Posttext',
        choices: {
            [levelChoices.attributes.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.attributes',
                maxChoices: 3
            },
            [levelChoices.hitPointSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.hitPointSlots',
                maxChoices: 2
            },
            [levelChoices.stressSlots.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.stressSlots',
                maxChoices: 2
            },
            [levelChoices.experiences.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.experiences',
                maxChoices: 1
            },
            [levelChoices.proficiency.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.proficiency',
                maxChoices: 2
            },
            [levelChoices.armorOrEvasionSlot.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.armorOrEvasionSlot',
                maxChoices: 2
            },
            [levelChoices.majorDamageThreshold2.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.majorDamageThreshold2',
                maxChoices: 1
            },
            [levelChoices.severeDamageThreshold4.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.severeDamageThreshold4',
                maxChoices: 1
            },
            [levelChoices.subclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.subclass',
                maxChoices: 1
            },
            [levelChoices.multiclass.name]: {
                description: 'DAGGERHEART.APPLICATIONS.Levelup.choiceDescriptions.multiclass',
                maxChoices: 1,
                cost: 2
            }
        }
    }
};

const subclassFeatureLabels = {
    1: 'DAGGERHEART.ITEMS.DomainCard.foundationTitle',
    2: 'DAGGERHEART.ITEMS.DomainCard.specializationTitle',
    3: 'DAGGERHEART.ITEMS.DomainCard.masteryTitle'
};

var ACTOR = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abilities: abilities,
    adversaryTraits: adversaryTraits,
    adversaryTypes: adversaryTypes,
    environmentTypes: environmentTypes,
    featureProperties: featureProperties,
    levelChoices: levelChoices,
    levelupData: levelupData,
    scrollingTextResource: scrollingTextResource,
    subclassFeatureLabels: subclassFeatureLabels
});

const armorFeatures = {
    burning: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.burning.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.burning.description',
        actions: [
            {
                type: 'damage',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.burning.actions.burn.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.burning.actions.burn.description',
                img: 'icons/magic/fire/flame-burning-embers-yellow.webp',
                range: 'melee',
                target: {
                    type: 'hostile'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'stress',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: '1'
                                }
                            }
                        }
                    ]
                }
            }
        ]
    },
    channeling: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.effects.channeling.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.channeling.effects.channeling.description',
                img: 'icons/magic/symbols/rune-sigil-horned-blue.webp',
                changes: [
                    {
                        key: 'system.bonuses.roll.spellcast',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    difficult: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.effects.difficult.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.difficult.effects.difficult.description',
                img: 'icons/magic/control/buff-flight-wings-red.webp',
                changes: [
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.strength.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.finesse.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.instinct.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.presence.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.traits.knowledge.value',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    flexible: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.effects.flexible.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.flexible.effects.flexible.description',
                img: 'icons/magic/movement/abstract-ribbons-red-orange.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    fortified: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.effects.fortified.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.fortified.effects.fortified.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-blue.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.increasePerArmorMark',
                        mode: 5,
                        value: '2'
                    }
                ]
            }
        ]
    },
    gilded: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.effects.gilded.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.gilded.effects.gilded.description',
                img: 'icons/magic/control/control-influence-crown-gold.webp',
                changes: [
                    {
                        key: 'system.traits.presence.value',
                        mode: 2,
                        value: '1'
                    }
                ]
            }
        ]
    },
    heavy: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.effects.heavy.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.heavy.effects.heavy.description',
                img: 'icons/commodities/metal/ingot-worn-iron.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    hopeful: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.actions.hope.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.hopeful.actions.hope.description',
                img: 'icons/magic/holy/barrier-shield-winged-blue.webp'
            }
        ]
    },
    impenetrable: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.actions.impenetrable.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.impenetrable.actions.impenetrable.description',
                img: 'icons/magic/defensive/shield-barrier-flaming-pentagon-purple-orange.webp',
                uses: {
                    max: 1,
                    recovery: 'shortRest',
                    value: 0
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    magical: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.magical.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.magical.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.magical.effects.magical.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.magical.effects.magical.description',
                img: 'icons/magic/defensive/barrier-shield-dome-blue-purple.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.magical',
                        mode: 5,
                        value: 1
                    }
                ]
            }
        ]
    },
    painful: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.painful.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.painful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.painful.actions.pain.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.painful.actions.pain.description',
                img: 'icons/skills/wounds/injury-face-impact-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    physical: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.physical.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.physical.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.physical.effects.physical.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.physical.effects.physical.description',
                img: 'icons/commodities/stone/ore-pile-tan.webp',
                changes: [
                    {
                        key: 'system.rules.damageReduction.physical',
                        mode: 5,
                        value: 1
                    }
                ]
            }
        ]
    },
    quiet: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.actions.quiet.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.quiet.actions.quiet.description',
                img: 'icons/magic/perception/silhouette-stealth-shadow.webp'
            }
        ]
    },
    reinforced: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.effects.reinforced.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.reinforced.effects.reinforced.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-triangle-green.webp',
                changes: [
                    {
                        key: 'system.bunuses.damageThresholds.major',
                        mode: 2,
                        value: '2'
                    },
                    {
                        key: 'system.bunuses.damageThresholds.severe',
                        mode: 2,
                        value: '2'
                    }
                ]
            }
        ]
    },
    resilient: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.description',
        actions: [
            {
                type: 'attack',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.actions.resilient.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.resilient.actions.resilient.description',
                img: 'icons/magic/life/heart-cross-purple-orange.webp',
                roll: {
                    type: 'diceSet',
                    diceRolling: {
                        compare: 'equal',
                        dice: 'd6',
                        multiplier: 'flat',
                        flatMultiplier: 1,
                        treshold: 6
                    }
                }
            }
        ]
    },
    sharp: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.effects.sharp.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.sharp.effects.sharp.description',
                img: 'icons/magic/defensive/shield-barrier-glowing-triangle-green.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.dice',
                        mode: 2,
                        value: '1d4'
                    },
                    {
                        key: 'system.bonuses.damage.secondaryWeapon.dice',
                        mode: 2,
                        value: '1d4'
                    }
                ]
            }
        ]
    },
    shifting: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.actions.shift.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.shifting.actions.shift.description',
                img: 'icons/magic/defensive/illusion-evasion-echo-purple.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    timeslowing: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.description',
        actions: [
            {
                type: 'attack',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.actions.slowTime.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.timeslowing.actions.slowTime.description',
                img: 'icons/magic/time/hourglass-brown-orange.webp',
                cost: [
                    {
                        key: 'armorSlot',
                        value: 1
                    }
                ],
                roll: {
                    type: 'diceSet',
                    diceRolling: {
                        dice: 'd4',
                        multiplier: 'flat',
                        flatMultiplier: 1
                    }
                }
            }
        ]
    },
    truthseeking: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.actions.truthseeking.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.truthseeking.actions.truthseeking.description',
                img: 'icons/magic/perception/orb-crystal-ball-scrying-blue.webp'
            }
        ]
    },
    veryheavy: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.effects.veryHeavy.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.veryHeavy.effects.veryHeavy.description',
                img: 'icons/commodities/metal/ingot-stamped-steel.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-2'
                    },
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    warded: {
        label: 'DAGGERHEART.CONFIG.ArmorFeature.warded.name',
        description: 'DAGGERHEART.CONFIG.ArmorFeature.warded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.ArmorFeature.warded.effects.warded.name',
                description: 'DAGGERHEART.CONFIG.ArmorFeature.warded.effects.warded.description',
                img: 'icons/magic/defensive/barrier-shield-dome-pink.webp',
                changes: [
                    {
                        key: 'system.resistance.magical.reduction',
                        mode: 2,
                        value: '@system.armorScore'
                    }
                ]
            }
        ]
    }
};

const weaponFeatures = {
    barrier: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.effects.barrier.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.barrier.effects.barrier.description',
                img: 'icons/skills/melee/shield-block-bash-blue.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: 'ITEM.@system.tier + 1'
                    },
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    bonded: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.effects.damage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.bonded.effects.damage.description',
                img: 'icons/magic/symbols/chevron-elipse-circle-blue.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '@system.levelData.level.current'
                    }
                ]
            }
        ]
    },
    bouncing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.actions.bounce.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.bouncing.actions.bounce.description',
                img: 'icons/skills/movement/ball-spinning-blue.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1,
                        scalable: true,
                        step: 1
                    }
                ]
            }
        ]
    },
    brave: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.brave.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.brave.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.brave.effects.brave.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.brave.effects.brave.description',
                img: 'icons/magic/life/heart-cross-strong-flame-purple-orange.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    },
                    {
                        key: 'system.damageThresholds.severe',
                        mode: 2,
                        value: 'ITEM.@system.tier'
                    }
                ]
            }
        ]
    },
    brutal: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.actions.addDamage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.brutal.actions.addDamage.description',
                img: 'icons/skills/melee/strike-dagger-blood-red.webp'
            }
        ]
    },
    burning: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.burning.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.burning.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.burning.actions.burn.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.burning.actions.burn.description',
                img: 'icons/magic/fire/blast-jet-stream-embers-orange.webp'
            }
        ]
    },
    charged: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.charged.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.charged.actions.markStress.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.actions.markStress.description',
                img: 'icons/magic/lightning/claws-unarmed-strike-teal.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.charged.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.charged.description',
                        img: 'icons/magic/lightning/claws-unarmed-strike-teal.webp',
                        changes: [
                            {
                                key: 'system.proficiency',
                                mode: 2,
                                value: '1'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    concussive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.actions.attack.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.concussive.actions.attack.description',
                img: 'icons/skills/melee/shield-block-bash-yellow.webp',
                target: {
                    type: 'any'
                },
                cost: [
                    {
                        key: 'hope',
                        value: 1
                    }
                ]
            }
        ]
    },
    cumbersome: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.effects.cumbersome.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.cumbersome.effects.cumbersome.description',
                img: 'icons/commodities/metal/mail-plate-steel.webp',
                changes: [
                    {
                        key: 'system.traits.finesse.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    deadly: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.actions.extraDamage.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.deadly.actions.extraDamage.description',
                img: 'icons/skills/melee/strike-sword-dagger-runes-red.webp'
            }
        ]
    },
    deflecting: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.actions.deflect.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.actions.deflect.description',
                img: 'icons/skills/melee/hand-grip-sword-strike-orange.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        type: 'armor',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.effects.deflecting.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.deflecting.effects.deflecting.description',
                        img: 'icons/skills/melee/hand-grip-sword-strike-orange.webp',
                        changes: [
                            {
                                key: 'system.evasion',
                                mode: 2,
                                value: '@system.armorScore'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    destructive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.description',
        actions: [
            {
                type: 'damage',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.actions.attack.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.actions.attack.descriptive',
                img: 'icons/skills/melee/strike-flail-spiked-pink.webp',
                range: 'veryClose',
                target: {
                    type: 'hostile'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'stress',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: '1'
                                }
                            }
                        }
                    ]
                }
            }
        ],
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.destructive.effects.agility',
                img: 'icons/skills/melee/strike-flail-spiked-pink.webp',
                changes: [
                    {
                        key: 'system.traits.agility.value',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    devastating: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.actions.devastate.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.devastating.actions.devastate.description',
                img: 'icons/skills/melee/strike-flail-destructive-yellow.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    doubleDuty: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.effects.doubleDuty.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.doubleDuty.effects.doubleDuty.description',
                img: 'icons/skills/melee/sword-shield-stylized-white.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: '1'
                    },
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '1'
                    }
                ],
                system: {
                    rangeDependence: {
                        enabled: true,
                        range: 'melee',
                        target: 'hostile',
                        type: 'withinRange'
                    }
                }
            }
        ]
    },
    doubledUp: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.actions.doubleUp.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.doubledUp.actions.doubleUp.description',
                img: 'icons/skills/melee/strike-slashes-orange.webp'
            }
        ]
    },
    dueling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.actions.duel.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.dueling.actions.duel.description',
                img: 'icons/skills/melee/weapons-crossed-swords-pink.webp'
            }
        ]
    },
    eruptive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.description',
        actions: [
            {
                type: 'effect', // Should prompt a dc 14 reaction save on adversaries
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.actions.erupt.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.eruptive.actions.erupt.description',
                img: 'icons/skills/melee/strike-hammer-destructive-blue.webp'
            }
        ]
    },
    grappling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.actions.grapple.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.grappling.actions.grapple.description',
                img: 'icons/magic/control/debuff-chains-ropes-net-white.webp',
                cost: [
                    {
                        key: 'hope',
                        value: 1
                    }
                ]
            }
        ]
    },
    greedy: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.description',
                img: 'icons/commodities/currency/coins-crown-stack-gold.webp',
                // Should cost handful of gold,
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.actions.greed.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.greedy.actions.greed.description',
                        img: 'icons/commodities/currency/coins-crown-stack-gold.webp',
                        changes: [
                            {
                                key: 'system.proficiency',
                                mode: 2,
                                value: '1'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    healing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.healing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.healing.description',
        actions: [
            {
                type: 'healing',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.healing.actions.heal.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.healing.actions.heal.description',
                img: 'icons/magic/life/cross-beam-green.webp',
                target: {
                    type: 'self'
                },
                damage: {
                    parts: [
                        {
                            applyTo: 'hitPoints',
                            value: {
                                custom: {
                                    enabled: true,
                                    formula: 1
                                }
                            }
                        }
                    ]
                }
            }
        ]
    },
    heavy: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.effects.heavy.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.heavy.effects.heavy.description',
                img: 'icons/commodities/metal/ingot-worn-iron.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    hooked: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.actions.hook.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.hooked.actions.hook.description',
                img: 'icons/skills/melee/strike-chain-whip-blue.webp'
            }
        ]
    },
    hot: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.hot.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.hot.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.hot.actions.hot.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.hot.actions.hot.description',
                img: 'icons/magic/fire/dagger-rune-enchant-flame-red.webp'
            }
        ]
    },
    invigorating: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.actions.invigorate.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.invigorating.actions.invigorate.description',
                img: 'icons/magic/life/heart-cross-green.webp'
            }
        ]
    },
    lifestealing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.actions.lifesteal.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lifestealing.actions.lifesteal.description',
                img: 'icons/magic/unholy/hand-claw-fire-blue.webp'
            }
        ]
    },
    lockedOn: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.actions.lockOn.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lockedOn.actions.lockOn.description',
                img: 'icons/skills/targeting/crosshair-arrowhead-blue.webp'
            }
        ]
    },
    long: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.long.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.long.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.long.actions.long.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.long.actions.long.description',
                img: 'icons/skills/melee/strike-weapon-polearm-ice-blue.webp'
            }
        ]
    },
    lucky: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.actions.luck.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.lucky.actions.luck.description',
                img: 'icons/magic/control/buff-luck-fortune-green.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    massive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.massive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.massive.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.massive.effects.massive.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.massive.effects.massive.description',
                img: 'icons/skills/melee/strike-flail-destructive-yellow.webp',
                changes: [
                    {
                        key: 'system.evasion',
                        mode: 2,
                        value: '-1'
                    }
                ]
            }
        ]
    },
    painful: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.painful.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.painful.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.painful.actions.pain.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.painful.actions.pain.description',
                img: 'icons/skills/wounds/injury-face-impact-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    paired: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.paired.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.paired.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.paired.effects.paired.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.paired.effects.paired.description',
                img: 'icons/skills/melee/weapons-crossed-swords-yellow-teal.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: 'ITEM.@system.tier + 1'
                    }
                ],
                system: {
                    rangeDependence: {
                        enabled: true,
                        range: 'melee',
                        target: 'hostile',
                        type: 'withinRange'
                    }
                }
            }
        ]
    },
    parry: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.parry.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.parry.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.parry.actions.parry.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.parry.actions.parry.description',
                img: 'icons/skills/melee/shield-block-fire-orange.webp'
            }
        ]
    },
    persuasive: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.actions.persuade.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.actions.persuade.description',
                img: 'icons/magic/control/hypnosis-mesmerism-eye.webp',
                target: {
                    type: 'self'
                },
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ],
                effects: [
                    {
                        name: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.effects.persuasive.name',
                        description: 'DAGGERHEART.CONFIG.WeaponFeature.persuasive.effects.persuasive.description',
                        img: 'icons/magic/control/hypnosis-mesmerism-eye.webp',
                        changes: [
                            {
                                key: 'system.traits.presence.value',
                                mode: 2,
                                value: '2'
                            }
                        ]
                    }
                ]
            }
        ]
    },
    pompous: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.actions.pompous.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.pompous.actions.pompous.description',
                img: 'icons/magic/control/control-influence-crown-gold.webp'
            }
        ]
    },
    powerful: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.effects.powerful.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.powerful.effects.powerful.description',
                img: 'icons/magic/control/buff-flight-wings-runes-red-yellow.webp',
                changes: []
            }
        ]
    },
    protective: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.protective.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.protective.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.protective.effects.protective.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.protective.effects.protective.description',
                img: 'icons/skills/melee/shield-block-gray-orange.webp',
                changes: [
                    {
                        key: 'system.armorScore',
                        mode: 2,
                        value: 'ITEM.@system.tier'
                    }
                ]
            }
        ]
    },
    quick: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.quick.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.quick.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.quick.actions.quick.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.quick.actions.quick.description',
                img: 'icons/skills/movement/arrow-upward-yellow.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    reliable: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.effects.reliable.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.reliable.effects.reliable.description',
                img: 'icons/skills/melee/strike-sword-slashing-red.webp',
                changes: [
                    {
                        key: 'system.bonuses.roll.primaryWeapon.bonus',
                        mode: 2,
                        value: 1
                    }
                ]
            }
        ]
    },
    reloading: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.actions.reload.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.reloading.actions.reload.description',
                img: 'icons/weapons/ammunition/shot-round-blue.webp'
            }
        ]
    },
    retractable: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.actions.retract.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.retractable.actions.retract.description',
                img: 'icons/skills/melee/blade-tip-smoke-green.webp'
            }
        ]
    },
    returning: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.returning.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.returning.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.returning.actions.return.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.returning.actions.return.description',
                img: 'icons/magic/movement/trail-streak-pink.webp'
            }
        ]
    },
    scary: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.scary.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.scary.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.scary.actions.scare.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.scary.actions.scare.description',
                img: 'icons/magic/death/skull-energy-light-purple.webp'
            }
        ]
    },
    selfCorrecting: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.effects.selfCorrecting.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.selfCorrecting.effects.selfCorrecting.description',
                img: 'icons/weapons/ammunition/arrow-broadhead-glowing-orange.webp',
                changes: []
            }
        ]
    },
    serrated: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.effects.serrated.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.serrated.effects.serrated.description',
                img: 'icons/weapons/ammunition/arrow-broadhead-glowing-orange.webp',
                changes: []
            }
        ]
    },
    sharpwing: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.description',
        effects: [
            {
                name: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.effects.sharpwing.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.sharpwing.effects.sharpwing.description',
                img: 'icons/weapons/swords/sword-winged-pink.webp',
                changes: [
                    {
                        key: 'system.bonuses.damage.primaryWeapon.bonus',
                        mode: 2,
                        value: '@system.traits.agility.value'
                    }
                ]
            }
        ]
    },
    sheltering: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.actions.shelter.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.sheltering.actions.shelter.description',
                img: 'icons/skills/melee/shield-block-gray-yellow.webp'
            }
        ]
    },
    startling: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.startling.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.startling.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.startling.actions.startle.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.startling.actions.startle.description',
                img: 'icons/magic/control/fear-fright-mask-orange.webp',
                cost: [
                    {
                        key: 'stress',
                        value: 1
                    }
                ]
            }
        ]
    },
    timebending: {
        label: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.name',
        description: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.description',
        actions: [
            {
                type: 'effect',
                actionType: 'action',
                chatDisplay: true,
                name: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.actions.bendTime.name',
                description: 'DAGGERHEART.CONFIG.WeaponFeature.timebending.actions.bendTime.description',
                img: 'icons/magic/time/clock-spinning-gold-pink.webp'
            }
        ]
    }
};

const featureTypes = {
    ancestry: {
        id: 'ancestry',
        label: 'TYPES.Item.ancestry'
    },
    community: {
        id: 'community',
        label: 'TYPES.Item.community'
    },
    companion: {
        id: 'companion',
        label: 'TYPES.Actor.companion'
    },
    class: {
        id: 'class',
        label: 'TYPES.Item.class'
    },
    subclass: {
        id: 'subclass',
        label: 'TYPES.Item.subclass'
    },
    domainCard: {
        id: 'domainCard',
        label: 'TYPES.Item.domainCard'
    },
    armor: {
        id: 'armor',
        label: 'TYPES.Item.armor'
    },
    weapon: {
        id: 'weapon',
        label: 'TYPES.Item.weapon'
    },
    consumable: {
        id: 'consumable',
        label: 'TYPES.Item.consumable'
    },
    loot: {
        id: 'loot',
        label: 'TYPES.Item.loot'
    },
    beastform: {
        if: 'beastform',
        label: 'TYPES.Item.beastform'
    }
};

const featureSubTypes = {
    primary: 'primary',
    secondary: 'secondary',
    hope: 'hope',
    class: 'class',
    foundation: 'foundation',
    specialization: 'specialization',
    mastery: 'mastery'
};

const actionTypes$1 = {
    passive: {
        id: 'passive',
        label: 'DAGGERHEART.CONFIG.ActionType.passive'
    },
    action: {
        id: 'action',
        label: 'DAGGERHEART.CONFIG.ActionType.action'
    },
    reaction: {
        id: 'reaction',
        label: 'DAGGERHEART.CONFIG.ActionType.reaction'
    }
};

const itemResourceTypes = {
    simple: {
        id: 'simple',
        label: 'DAGGERHEART.CONFIG.ItemResourceType.simple'
    },
    diceValue: {
        id: 'diceValue',
        label: 'DAGGERHEART.CONFIG.ItemResourceType.diceValue'
    }
};

const itemResourceProgression = {
    increasing: {
        id: 'increasing',
        label: 'DAGGERHEART.CONFIG.ItemResourceProgression.increasing'
    },
    decreasing: {
        id: 'decreasing',
        label: 'DAGGERHEART.CONFIG.ItemResourceProgression.decreasing'
    }
};

const beastformTypes = {
    normal: {
        id: 'normal',
        label: 'DAGGERHEART.CONFIG.BeastformType.normal'
    },
    evolved: {
        id: 'evolved',
        label: 'DAGGERHEART.CONFIG.BeastformType.evolved'
    },
    hybrid: {
        id: 'hybrid',
        label: 'DAGGERHEART.CONFIG.BeastformType.hybrid'
    }
};

var ITEM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionTypes: actionTypes$1,
    armorFeatures: armorFeatures,
    beastformTypes: beastformTypes,
    featureSubTypes: featureSubTypes,
    featureTypes: featureTypes,
    itemResourceProgression: itemResourceProgression,
    itemResourceTypes: itemResourceTypes,
    weaponFeatures: weaponFeatures
});

const menu = {
    Automation: {
        Name: 'GameSettingsAutomation',
        Icon: 'fa-solid fa-robot'
    },
    Homebrew: {
        Name: 'GameSettingsHomebrew',
        Icon: 'fa-solid fa-flask-vial'
    },
    Range: {
        Name: 'GameSettingsRange',
        Icon: 'fa-solid fa-ruler'
    },
    VariantRules: {
        Name: 'GameSettingsVariantrules',
        Icon: 'fa-solid fa-scale-balanced'
    }
};

const gameSettings = {
    Automation: 'Automation',
    Homebrew: 'Homebrew',
    appearance: 'Appearance',
    variantRules: 'VariantRules',
    Resources: {
        Fear: 'ResourcesFear'
    },
    LevelTiers: 'LevelTiers',
    Countdowns: 'Countdowns',
    LastMigrationVersion: 'LastMigrationVersion'
};

var SETTINGS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    gameSettings: gameSettings,
    menu: menu
});

const valueTypes = {
    numberString: {
        id: 'numberString'
    },
    select: {
        id: 'select'
    }
};

const parseTypes = {
    string: {
        id: 'string'
    },
    number: {
        id: 'number'
    }
};

const applyLocations = {
    attackRoll: {
        id: 'attackRoll',
        name: 'DAGGERHEART.EFFECTS.ApplyLocations.attackRoll.name'
    },
    damageRoll: {
        id: 'damageRoll',
        name: 'DAGGERHEART.EFFECTS.ApplyLocations.damageRoll.name'
    }
};

const effectTypes = {
    health: {
        id: 'health',
        name: 'DAGGERHEART.EFFECTS.Types.HitPoints.name',
        values: [],
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.number.id
    },
    stress: {
        id: 'stress',
        name: 'DAGGERHEART.EFFECTS.Types.Stress.name',
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.number.id
    },
    reach: {
        id: 'reach',
        name: 'DAGGERHEART.EFFECTS.Types.Reach.name',
        valueType: valueTypes.select.id,
        parseType: parseTypes.string.id,
        options: Object.keys(range).map(x => ({ name: range[x].name, value: x }))
    },
    damage: {
        id: 'damage',
        name: 'DAGGERHEART.EFFECTS.Types.Damage.name',
        valueType: valueTypes.numberString.id,
        parseType: parseTypes.string.id,
        appliesOn: applyLocations.damageRoll.id,
        applyLocationChoices: {
            [applyLocations.damageRoll.id]: applyLocations.damageRoll.name,
            [applyLocations.attackRoll.id]: applyLocations.attackRoll.name
        }
    }
};

var EFFECTS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    applyLocations: applyLocations,
    effectTypes: effectTypes,
    parseTypes: parseTypes,
    valueTypes: valueTypes
});

const actionTypes = {
    attack: {
        id: 'attack',
        name: 'DAGGERHEART.ACTIONS.TYPES.attack.name',
        icon: 'fa-khanda',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.attack.tooltip'
    },
    healing: {
        id: 'healing',
        name: 'DAGGERHEART.ACTIONS.TYPES.healing.name',
        icon: 'fa-kit-medical',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.healing.tooltip'
    },
    damage: {
        id: 'damage',
        name: 'DAGGERHEART.ACTIONS.TYPES.damage.name',
        icon: 'fa-heart-crack',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.damage.tooltip'
    },
    beastform: {
        id: 'beastform',
        name: 'DAGGERHEART.ACTIONS.TYPES.beastform.name',
        icon: 'fa-paw',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.beastform.tooltip'
    },
    summon: {
        id: 'summon',
        name: 'DAGGERHEART.ACTIONS.TYPES.summon.name',
        icon: 'fa-ghost',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.summon.tooltip'
    },
    effect: {
        id: 'effect',
        name: 'DAGGERHEART.ACTIONS.TYPES.effect.name',
        icon: 'fa-person-rays',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.effect.tooltip'
    },
    macro: {
        id: 'macro',
        name: 'DAGGERHEART.ACTIONS.TYPES.macro.name',
        icon: 'fa-scroll',
        tooltip: 'DAGGERHEART.ACTIONS.TYPES.macro.tooltip'
    }
};

const damageOnSave = {
    none: {
        id: 'none',
        label: 'None',
        mod: 0
    },
    half: {
        id: 'half',
        label: 'Half Damage',
        mod: 0.5
    },
    full: {
        id: 'full',
        label: 'Full damage',
        mod: 1
    }
};

const diceCompare = {
    below: {
        id: 'below',
        label: 'Below',
        operator: '<'
    },
    belowEqual: {
        id: 'belowEqual',
        label: 'Below or Equal',
        operator: '<='
    },
    equal: {
        id: 'equal',
        label: 'Equal',
        operator: '='
    },
    aboveEqual: {
        id: 'aboveEqual',
        label: 'Above or Equal',
        operator: '>='
    },
    above: {
        id: 'above',
        label: 'Above',
        operator: '>'
    }
};

const advantageState = {
    disadvantage: {
        label: 'DAGGERHEART.GENERAL.Disadvantage.full',
        value: -1
    },
    neutral: {
        label: 'DAGGERHEART.GENERAL.Neutral.full',
        value: 0
    },
    advantage: {
        label: 'DAGGERHEART.GENERAL.Advantage.full',
        value: 1
    }
};

var ACTIONS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionTypes: actionTypes,
    advantageState: advantageState,
    damageOnSave: damageOnSave,
    diceCompare: diceCompare
});

const displayDomainCardsAsList = 'displayDomainCardsAsList';
const narrativeCountdown = {
    simple: 'countdown-narrative-simple',
    position: 'countdown-narrative-position'
};
const encounterCountdown = {
    simple: 'countdown-encounter-simple',
    position: 'countdown-encounter-position'
};

const itemAttachmentSource = 'attachmentSource';

const userFlags = {
    welcomeMessage: 'welcome-message'
};

var FLAGS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    displayDomainCardsAsList: displayDomainCardsAsList,
    encounterCountdown: encounterCountdown,
    itemAttachmentSource: itemAttachmentSource,
    narrativeCountdown: narrativeCountdown,
    userFlags: userFlags
});

const typeConfig = {
    adversaries: {
        columns: [
            {
                key: 'system.tier',
                label: 'Tier'
            },
            {
                key: 'system.type',
                label: 'Type'
            }
        ],
        filters: [
            {
                key: 'system.tier',
                label: 'Tier',
                field: 'system.api.models.actors.DhAdversary.schema.fields.tier'
            },
            {
                key: 'system.type',
                label: 'Type',
                field: 'system.api.models.actors.DhAdversary.schema.fields.type'
            },
            {
                key: 'system.difficulty',
                name: 'difficulty.min',
                label: 'Difficulty (Min)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.difficulty',
                operator: 'gte'
            },
            {
                key: 'system.difficulty',
                name: 'difficulty.max',
                label: 'Difficulty (Max)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.difficulty',
                operator: 'lte'
            },
            {
                key: 'system.resources.hitPoints.max',
                name: 'hp.min',
                label: 'Hit Points (Min)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.hitPoints.fields.max',
                operator: 'gte'
            },
            {
                key: 'system.resources.hitPoints.max',
                name: 'hp.max',
                label: 'Hit Points (Max)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.hitPoints.fields.max',
                operator: 'lte'
            },
            {
                key: 'system.resources.stress.max',
                name: 'stress.min',
                label: 'Stress (Min)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.stress.fields.max',
                operator: 'gte'
            },
            {
                key: 'system.resources.stress.max',
                name: 'stress.max',
                label: 'Stress (Max)',
                field: 'system.api.models.actors.DhAdversary.schema.fields.resources.fields.stress.fields.max',
                operator: 'lte'
            }
        ]
    },
    items: {
        columns: [
            {
                key: 'type',
                label: 'Type'
            },
            {
                key: 'system.secondary',
                label: 'Subtype',
                format: isSecondary => (isSecondary ? 'secondary' : isSecondary === false ? 'primary' : '-')
            },
            {
                key: 'system.tier',
                label: 'Tier'
            }
        ],
        filters: [
            {
                key: 'type',
                label: 'Type',
                choices: () =>
                    CONFIG.Item.documentClass.TYPES.filter(t =>
                        ['armor', 'weapon', 'consumable', 'loot'].includes(t)
                    ).map(t => ({ value: t, label: t }))
            },
            {
                key: 'system.secondary',
                label: 'Subtype',
                choices: [
                    { value: false, label: 'Primary Weapon' },
                    { value: true, label: 'Secondary Weapon' }
                ]
            },
            {
                key: 'system.tier',
                label: 'Tier',
                choices: [
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' },
                    { value: '4', label: '4' }
                ]
            },
            {
                key: 'system.burden',
                label: 'Burden',
                field: 'system.api.models.items.DHWeapon.schema.fields.burden'
            },
            {
                key: 'system.attack.roll.trait',
                label: 'Trait',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.roll.fields.trait'
            },
            {
                key: 'system.attack.range',
                label: 'Range',
                field: 'system.api.models.actions.actionsTypes.attack.schema.fields.range'
            },
            {
                key: 'system.baseScore',
                name: 'armor.min',
                label: 'Armor Score (Min)',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'gte'
            },
            {
                key: 'system.baseScore',
                name: 'armor.max',
                label: 'Armor Score (Max)',
                field: 'system.api.models.items.DHArmor.schema.fields.baseScore',
                operator: 'lte'
            },
            {
                key: 'system.itemFeatures',
                label: 'Features',
                choices: () =>
                    [
                        ...Object.entries(CONFIG.DH.ITEM.weaponFeatures),
                        ...Object.entries(CONFIG.DH.ITEM.armorFeatures)
                    ].map(([k, v]) => ({ value: k, label: v.label })),
                operator: 'contains3'
            }
        ]
    },
    features: {
        columns: [],
        filters: []
    },
    cards: {
        columns: [
            {
                key: 'system.type',
                label: 'Type'
            },
            {
                key: 'system.domain',
                label: 'Domain'
            },
            {
                key: 'system.level',
                label: 'Level'
            }
        ],
        filters: [
            {
                key: 'system.type',
                label: 'Type',
                field: 'system.api.models.items.DHDomainCard.schema.fields.type'
            },
            {
                key: 'system.domain',
                label: 'Domain',
                field: 'system.api.models.items.DHDomainCard.schema.fields.domain',
                operator: 'contains2'
            },
            {
                key: 'system.level',
                name: 'level.min',
                label: 'Level (Min)',
                field: 'system.api.models.items.DHDomainCard.schema.fields.level',
                operator: 'gte'
            },
            {
                key: 'system.level',
                name: 'level.max',
                label: 'Level (Max)',
                field: 'system.api.models.items.DHDomainCard.schema.fields.level',
                operator: 'lte'
            },
            {
                key: 'system.recallCost',
                name: 'recall.min',
                label: 'Recall Cost (Min)',
                field: 'system.api.models.items.DHDomainCard.schema.fields.recallCost',
                operator: 'gte'
            },
            {
                key: 'system.recallCost',
                name: 'recall.max',
                label: 'Recall Cost (Max)',
                field: 'system.api.models.items.DHDomainCard.schema.fields.recallCost',
                operator: 'lte'
            }
        ]
    },
    classes: {
        columns: [
            {
                key: 'system.evasion',
                label: 'Evasion'
            },
            {
                key: 'system.hitPoints',
                label: 'Hit Points'
            },
            {
                key: 'system.domains',
                label: 'Domains'
            }
        ],
        filters: [
            {
                key: 'system.evasion',
                name: 'evasion.min',
                label: 'Evasion (Min)',
                field: 'system.api.models.items.DHClass.schema.fields.evasion',
                operator: 'gte'
            },
            {
                key: 'system.evasion',
                name: 'evasion.max',
                label: 'Evasion (Max)',
                field: 'system.api.models.items.DHClass.schema.fields.evasion',
                operator: 'lte'
            },
            {
                key: 'system.hitPoints',
                name: 'hp.min',
                label: 'Hit Points (Min)',
                field: 'system.api.models.items.DHClass.schema.fields.hitPoints',
                operator: 'gte'
            },
            {
                key: 'system.hitPoints',
                name: 'hp.max',
                label: 'Hit Points (Max)',
                field: 'system.api.models.items.DHClass.schema.fields.hitPoints',
                operator: 'lte'
            },
            {
                key: 'system.domains',
                label: 'Domains',
                choices: () => Object.values(CONFIG.DH.DOMAIN.domains).map(d => ({ value: d.id, label: d.label })),
                operator: 'contains2'
            }
        ]
    },
    subclasses: {
        columns: [
            {
                key: 'system.linkedClass',
                label: 'Class',
                format: linkedClass => linkedClass.name
            },
            {
                key: 'system.spellcastingTrait',
                label: 'Spellcasting Trait'
            }
        ],
        filters: [
            {
                key: 'system.linkedClass.uuid',
                label: 'Class',
                choices: (items) => {
                    const list = items.map(item => ({ value: item.system.linkedClass.uuid, label: item.system.linkedClass.name }));
                    return list.reduce((a,c) => {
                        if(!(a.find(i => i.value === c.value))) a.push(c);
                        return a;
                    }, []);
                }
            }
        ]
    },
    beastforms: {
        columns: [
            {
                key: 'system.tier',
                label: 'Tier'
            },
            {
                key: 'system.mainTrait',
                label: 'Main Trait'
            }
        ],
        filters: [
            {
                key: 'system.tier',
                label: 'Tier',
                field: 'system.api.models.items.DHBeastform.schema.fields.tier'
            },
            {
                key: 'system.mainTrait',
                label: 'Main Trait',
                field: 'system.api.models.items.DHBeastform.schema.fields.mainTrait'
            }
        ]
    }
};

const compendiumConfig = {
    daggerheart: {
        id: 'daggerheart',
        label: 'DAGGERHEART',
        folders: {
            adversaries: {
                id: 'adversaries',
                keys: ['adversaries'],
                label: 'Adversaries',
                type: ['adversary'],
                listType: 'adversaries'
            },
            ancestries: {
                id: 'ancestries',
                keys: ['ancestries'],
                label: 'Ancestries',
                type: ['ancestry'],
                folders: {
                    features: {
                        id: 'features',
                        keys: ['ancestries'],
                        label: 'Features',
                        type: ['feature']
                    }
                }
            },
            equipments: {
                id: 'equipments',
                keys: ['armors', 'weapons', 'consumables', 'loot'],
                label: 'Equipment',
                type: ['armor', 'weapon', 'consumable', 'loot'],
                listType: 'items'
            },
            classes: {
                id: 'classes',
                keys: ['classes'],
                label: 'Classes',
                type: ['class'],
                folders: {
                    features: {
                        id: 'features',
                        keys: ['classes'],
                        label: 'Features',
                        type: ['feature']
                    },
                    items: {
                        id: 'items',
                        keys: ['classes'],
                        label: 'Items',
                        type: ['armor', 'weapon', 'consumable', 'loot'],
                        listType: 'items'
                    }
                },
                listType: 'classes'
            },
            subclasses: {
                id: 'subclasses',
                keys: ['subclasses'],
                label: 'Subclasses',
                type: ['subclass'],
                listType: 'subclasses'
            },
            domains: {
                id: 'domains',
                keys: ['domains'],
                label: 'Domain Cards',
                type: ['domainCard'],
                listType: 'cards'
            },
            communities: {
                id: 'communities',
                keys: ['communities'],
                label: 'Communities',
                type: ['community'],
                folders: {
                    features: {
                        id: 'features',
                        keys: ['communities'],
                        label: 'Features',
                        type: ['feature']
                    }
                }
            },
            environments: {
                id: 'environments',
                keys: ['environments'],
                label: 'Environments',
                type: ['environment']
            },
            beastforms: {
                id: 'beastforms',
                keys: ['beastforms'],
                label: 'Beastforms',
                type: ['beastform'],
                listType: 'beastforms',
                folders: {
                    features: {
                        id: 'features',
                        keys: ['beastforms'],
                        label: 'Features',
                        type: ['feature']
                    }
                }
            }
        }
    }
};

var ITEMBROWSER = /*#__PURE__*/Object.freeze({
    __proto__: null,
    compendiumConfig: compendiumConfig,
    typeConfig: typeConfig
});

const SYSTEM_ID = 'daggerheart';

const SYSTEM = {
    id: SYSTEM_ID,
    GENERAL,
    DOMAIN,
    ACTOR,
    ITEM,
    SETTINGS,
    EFFECTS,
    ACTIONS,
    FLAGS,
    ITEMBROWSER
};

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$m, ApplicationV2: ApplicationV2$l } = foundry.applications.api;

/**
 * A UI element which displays the Users defined for this world.
 * Currently active users are always displayed, while inactive users can be displayed on toggle.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class ItemBrowser extends HandlebarsApplicationMixin$m(ApplicationV2$l) {
    constructor(options = {}) {
        super(options);
        this.items = [];
        this.fieldFilter = [];
        this.selectedMenu = { path: [], data: null };
        this.config = CONFIG.DH.ITEMBROWSER.compendiumConfig;
        this.presets = options.presets;

        if (this.presets?.compendium && this.presets?.folder)
            ItemBrowser.selectFolder.call(this, null, null, this.presets.compendium, this.presets.folder);
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'itemBrowser',
        classes: ['daggerheart', 'dh-style', 'dialog', 'compendium-browser'],
        tag: 'div',
        window: {
            frame: true,
            title: 'Compendium Browser',
            icon: 'fa-solid fa-book-atlas',
            positioned: true,
            resizable: true
        },
        actions: {
            selectFolder: this.selectFolder,
            expandContent: this.expandContent,
            resetFilters: this.resetFilters,
            sortList: this.sortList
        },
        position: {
            left: 100,
            width: 850,
            height: 600
        }
    };

    /** @override */
    static PARTS = {
        sidebar: {
            template: 'systems/daggerheart/templates/ui/itemBrowser/sidebar.hbs'
        },
        list: {
            template: 'systems/daggerheart/templates/ui/itemBrowser/itemBrowser.hbs'
        }
    };

    /* -------------------------------------------- */
    /*  Filter Tracking                             */
    /* -------------------------------------------- */

    /**
     * The currently active search filter.
     * @type {foundry.applications.ux.SearchFilter}
     */
    #search = {};

    #input = {};

    /**
     * Tracks which item IDs are currently displayed, organized by filter type and section.
     * @type {{
     *   inventory: {
     *     search: Set<string>,
     *     input: Set<string>
     *   }
     * }}
     */
    #filteredItems = {
        browser: {
            search: new Set(),
            input: new Set()
        }
    };

    /** @inheritDoc */
    async _preFirstRender(context, options) {
        if (context.presets?.render?.noFolder || context.presets?.render?.lite) options.position.width = 600;

        await super._preFirstRender(context, options);
    }

    /** @inheritDoc */
    async _preRender(context, options) {
        if (context.presets?.render?.noFolder || context.presets?.render?.lite)
            options.parts.splice(options.parts.indexOf('sidebar'), 1);

        await super._preRender(context, options);
    }

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        this._createSearchFilter();
        this._createFilterInputs();
        this._createDragProcess();

        if (context.presets?.render?.lite) this.element.classList.add('lite');

        if (context.presets?.render?.noFolder) this.element.classList.add('no-folder');

        if (context.presets?.render?.noFilter) this.element.classList.add('no-filter');

        if (this.presets?.filter) {
            Object.entries(this.presets.filter).forEach(
                ([k, v]) => (this.fieldFilter.find(c => c.name === k).value = v.value)
            );
            await this._onInputFilterBrowser();
        }
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement
            .querySelectorAll('[data-action="selectFolder"]')
            .forEach(element => element.addEventListener("contextmenu", (event) => {
                event.target.classList.toggle('expanded');
            }));
    }

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /** @override */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.compendiums = this.getCompendiumFolders(foundry.utils.deepClone(this.config));
        // context.pathTitle = this.pathTile;
        context.menu = this.selectedMenu;
        context.formatLabel = this.formatLabel;
        context.formatChoices = this.formatChoices;
        context.fieldFilter = this.fieldFilter = this._createFieldFilter();
        context.items = this.items;
        context.presets = this.presets;
        return context;
    }

    getCompendiumFolders(config, parent = null, depth = 0) {
        let folders = [];
        Object.values(config).forEach(c => {
            const folder = {
                id: c.id,
                label: c.label,
                selected: (!parent || parent.selected) && this.selectedMenu.path[depth] === c.id
            };
            folder.folders = c.folders
                ? ItemBrowser.sortBy(this.getCompendiumFolders(c.folders, folder, depth + 2), 'label')
                : [];
            folders.push(folder);
        });

        return folders;
    }

    static async selectFolder(_, target, compend, folder) {
        const config = foundry.utils.deepClone(this.config),
            compendium = compend ?? target.closest('[data-compendium-id]').dataset.compendiumId,
            folderId = folder ?? target.dataset.folderId,
            folderPath = `${compendium}.folders.${folderId}`,
            folderData = foundry.utils.getProperty(config, folderPath);

        this.selectedMenu = {
            path: folderPath.split('.'),
            data: {
                ...folderData,
                columns: ItemBrowser.getFolderConfig(folderData)
            }
        };

        let items = [];
        for (const key of folderData.keys) {
            const comp = game.packs.get(`${compendium}.${key}`);
            if (!comp) return;
            items = items.concat(await comp.getDocuments({ type__in: folderData.type }));
        }

        this.items = ItemBrowser.sortBy(items, 'name');

        if(target) {
            target.closest('.compendium-sidebar').querySelectorAll('[data-action="selectFolder"]').forEach(element => element.classList.remove("is-selected"));
            target.classList.add('is-selected');
        }

        this.render({ force: true });
    }

    _replaceHTML(result, content, options) {
        if(!options.isFirstRender) delete result.sidebar;
        super._replaceHTML(result, content, options);
    }

    static expandContent(_, target) {
        const parent = target.parentElement;
        parent.classList.toggle('expanded');
    }

    static sortBy(data, property) {
        return data.sort((a, b) => (a[property] > b[property] ? 1 : -1));
    }

    formatLabel(item, field) {
        const property = foundry.utils.getProperty(item, field.key);
        if (Array.isArray(property)) property.join(', ');
        if (typeof field.format !== 'function') return property ?? '-';
        return field.format(property);
    }

    formatChoices(data) {
        if (!data.field.choices) return null;
        const config = {
            choices: data.field.choices
        };
        foundry.data.fields.StringField._prepareChoiceConfig(config);
        return config.options.filter(
            c => data.filtered.includes(c.value) || data.filtered.includes(c.label.toLowerCase())
        );
    }

    _createFieldFilter() {
        const filters = ItemBrowser.getFolderConfig(this.selectedMenu.data, 'filters');
        filters.forEach(f => {
            if (typeof f.field === 'string') f.field = foundry.utils.getProperty(game, f.field);
            else if (typeof f.choices === 'function') {
                f.choices = f.choices(this.items);
            }
            f.name ??= f.key;
            f.value = this.presets?.filter?.[f.name]?.value ?? null;
        });
        return filters;
    }

    /* -------------------------------------------- */
    /*  Search Inputs                               */
    /* -------------------------------------------- */

    /**
     * Create and initialize search filter instance.
     *
     * @private
     */
    _createSearchFilter() {
        //Filters could be a application option if needed
        const filters = [
            {
                key: 'browser',
                input: 'input[type="search"].search-input',
                content: '[data-application-part="list"] .item-list',
                callback: this._onSearchFilterBrowser.bind(this)
            }
        ];

        for (const { key, input, content, callback } of filters) {
            const filter = new foundry.applications.ux.SearchFilter({
                inputSelector: input,
                contentSelector: content,
                callback
            });
            filter.bind(this.element);
            this.#search[key] = filter;
        }
    }

    /* -------------------------------------------- */
    /*  Filter Inputs                                */
    /* -------------------------------------------- */

    _createFilterInputs() {
        const inputs = [
            {
                key: 'browser',
                container: '[data-application-part="list"] .filter-content .wrapper',
                content: '[data-application-part="list"] .item-list',
                callback: this._onInputFilterBrowser.bind(this)
            }
        ];

        inputs.forEach(m => {
            const container = this.element.querySelector(m.container);
            if (!container) return (this.#input[m.key] = {});
            const inputs = container.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', this._onInputFilterBrowser.bind(this));
            });
            this.#filteredItems[m.key].input = new Set(this.items.map(i => i.id));
            this.#input[m.key] = inputs;
        });
    }

    /**
     * Handle invetory items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterBrowser(event, query, rgx, html) {
        this.#filteredItems.browser.search.clear();

        for (const li of html.querySelectorAll('.item-container')) {
            const itemUUID = li.dataset.itemUuid,
                item = this.items.find(i => i.uuid === itemUUID);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.browser.search.add(item.id);
            const { input } = this.#filteredItems.browser;
            li.hidden = !(input.has(item.id) && matchesSearch);
        }
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     */
    async _onInputFilterBrowser(event) {
        this.#filteredItems.browser.input.clear();

        if (event) this.fieldFilter.find(f => f.name === event.target.name).value = event.target.value;

        for (const li of this.element.querySelectorAll('.item-container')) {
            const itemUUID = li.dataset.itemUuid,
                item = this.items.find(i => i.uuid === itemUUID);

            if (!item) continue;
            
            const matchesMenu =
                this.fieldFilter.length === 0 ||
                this.fieldFilter.every(
                    f => (!f.value && f.value !== false) || ItemBrowser.evaluateFilter(item, this.createFilterData(f))
                );
            if (matchesMenu) this.#filteredItems.browser.input.add(item.id);

            const { search } = this.#filteredItems.browser;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /**
     * Foundry evaluateFilter doesn't allow you to match if filter values are included into item data
     * @param {*} obj
     * @param {*} filter
     */
    static evaluateFilter(obj, filter) {
        let docValue = foundry.utils.getProperty(obj, filter.field);
        let filterValue = filter.value;
        switch (filter.operator) {
            case 'contains2':
                filterValue = Array.isArray(filterValue) ? filterValue : [filterValue];
                docValue = Array.isArray(docValue) ? docValue : [docValue];
                return docValue.some(dv => filterValue.includes(dv));
            case 'contains3':
                return docValue.some(f => f.value === filterValue);
            default:
                return foundry.applications.ux.SearchFilter.evaluateFilter(obj, filter);
        }
    }

    createFilterData(filter) {
        return {
            field: filter.key,
            value: isNaN(filter.value)
                ? ['true', 'false'].includes(filter.value)
                    ? filter.value === 'true'
                    : filter.value
                : Number(filter.value),
            operator: filter.operator,
            negate: filter.negate
        };
    }

    static resetFilters() {
        this.render({ force: true });
    }

    static getFolderConfig(folder, property = 'columns') {
        if (!folder) return [];
        return folder[property] ?? CONFIG.DH.ITEMBROWSER.typeConfig[folder.listType]?.[property] ?? [];
    }

    static sortList(_, target) {
        const key = target.dataset.sortKey,
            type = !target.dataset.sortType || target.dataset.sortType === 'DESC' ? 'ASC' : 'DESC',
            itemListContainer = target.closest('.compendium-results').querySelector('.item-list'),
            itemList = itemListContainer.querySelectorAll('.item-container');

        target
            .closest('.item-list-header')
            .querySelectorAll('[data-sort-key]')
            .forEach(b => (b.dataset.sortType = ''));
        target.dataset.sortType = type;

        const newOrder = [...itemList].reverse().sort((a, b) => {
            const aProp = a.querySelector(`[data-item-key="${key}"]`),
                bProp = b.querySelector(`[data-item-key="${key}"]`);
            if (type === 'DESC') {
                return aProp.innerText < bProp.innerText ? 1 : -1;
            } else {
                return aProp.innerText > bProp.innerText ? 1 : -1;
            }
        });

        itemListContainer.replaceChildren(...newOrder);
    }

    _createDragProcess() {
        new foundry.applications.ux.DragDrop.implementation({
            dragSelector: '.item-container',
            permissions: {
                dragstart: this._canDragStart.bind(this)
            },
            callbacks: {
                dragstart: this._onDragStart.bind(this)
            }
        }).bind(this.element);
    }

    async _onDragStart(event) {
        const { itemUuid } = event.target.closest('[data-item-uuid]').dataset,
            item = await foundry.utils.fromUuid(itemUuid),
            dragData = item.toDragData();
        event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
    }

    _canDragStart() {
        return true;
    }
}

/*
Tagify v4.35.1 - tags input component
By: Yair Even-Or <vsync.design@gmail.com>
https://github.com/yairEO/tagify

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

This Software may not be rebranded and sold as a library under any other name
other than "Tagify" (by owner) or as part of another library.
*/

var t="&#8203;";function e(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function i(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,i){if(!t)return;if("string"==typeof t)return e(t,i);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return e(t,i)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var n={isEnabled:function(){var t;return null===(t=window.TAGIFY_DEBUG)||void 0===t||t},log:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var s;this.isEnabled()&&(s=console).log.apply(s,["[Tagify]:"].concat(i(e)));},warn:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var s;this.isEnabled()&&(s=console).warn.apply(s,["[Tagify]:"].concat(i(e)));}},s=function(t,e,i,n){return t=""+t,e=""+e,n&&(t=t.trim(),e=e.trim()),i?t==e:t.toLowerCase()==e.toLowerCase()},a=function(t,e){return t&&Array.isArray(t)&&t.map((function(t){return o(t,e)}))};function o(t,e){var i,n={};for(i in t)e.indexOf(i)<0&&(n[i]=t[i]);return n}function r(t){return (new DOMParser).parseFromString(t.trim(),"text/html").body.firstElementChild}function l(t,e){for(e=e||"previous";t=t[e+"Sibling"];)if(3==t.nodeType)return t}function d(t){return "string"==typeof t?t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/`|'/g,"&#039;"):t}function c(t){var e=Object.prototype.toString.call(t).split(" ")[1].slice(0,-1);return t===Object(t)&&"Array"!=e&&"Function"!=e&&"RegExp"!=e&&"HTMLUnknownElement"!=e}function u(t,e,i){var n,s;function a(t,e){for(var i in e)if(e.hasOwnProperty(i)){if(c(e[i])){c(t[i])?a(t[i],e[i]):t[i]=Object.assign({},e[i]);continue}if(Array.isArray(e[i])){t[i]=Object.assign([],e[i]);continue}t[i]=e[i];}}return n=t,(null!=(s=Object)&&"undefined"!=typeof Symbol&&s[Symbol.hasInstance]?s[Symbol.hasInstance](n):n instanceof s)||(t={}),a(t,e),i&&a(t,i),t}function g(){var t=[],e={},i=true,n=false,s=void 0;try{for(var a,o=arguments[Symbol.iterator]();!(i=(a=o.next()).done);i=!0){var r=a.value,l=!0,d=!1,u=void 0;try{for(var g,h=r[Symbol.iterator]();!(l=(g=h.next()).done);l=!0){var p=g.value;c(p)?e[p.value]||(t.push(p),e[p.value]=1):t.includes(p)||t.push(p);}}catch(t){d=!0,u=t;}finally{try{l||null==h.return||h.return();}finally{if(d)throw u}}}}catch(t){n=true,s=t;}finally{try{i||null==o.return||o.return();}finally{if(n)throw s}}return t}function h(t){return String.prototype.normalize?"string"==typeof t?t.normalize("NFD").replace(/[\u0300-\u036f]/g,""):void 0:t}var p=function(){return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)};function f(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(function(t){return (t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16)}))}function m(t){var e,i=b.call(this,t),n=null==t||null===(e=t.classList)||void 0===e?void 0:e.contains(this.settings.classNames.tag);return i&&n}function v(t){return b.call(this,t)&&(null==t?void 0:t.closest(this.settings.classNames.tagSelector))}function b(t){var e;return (null==t||null===(e=t.closest)||void 0===e?void 0:e.call(t,this.settings.classNames.namespaceSelector))===this.DOM.scope}function w(t,e){var i=window.getSelection();return e=e||i.getRangeAt(0),"string"==typeof t&&(t=document.createTextNode(t)),e&&(e.deleteContents(),e.insertNode(t)),t}function y(t,e,i){return t?(e&&(t.__tagifyTagData=i?e:u({},t.__tagifyTagData||{},e)),t.__tagifyTagData):(n.warn("tag element doesn't exist",{tagElm:t,data:e}),e)}function T(t){if(t&&t.parentNode){var e=t,i=window.getSelection(),n=i.getRangeAt(0);i.rangeCount&&(n.setStartAfter(e),n.collapse(true),i.removeAllRanges(),i.addRange(n));}}function O(t,e){t.forEach((function(t){if(y(t.previousSibling)||!t.previousSibling){var i=document.createTextNode("");t.before(i),e&&T(i);}}));}var D={delimiters:",",pattern:null,tagTextProp:"value",maxTags:1/0,callbacks:{},addTagOnBlur:true,addTagOn:["blur","tab","enter"],onChangeAfterBlur:true,duplicates:false,whitelist:[],blacklist:[],enforceWhitelist:false,userInput:true,focusable:true,focusInputOnRemove:true,keepInvalidTags:false,createInvalidTags:true,mixTagsAllowedAfter:/,|\.|\:|\s/,mixTagsInterpolator:["[[","]]"],backspace:true,skipInvalid:false,pasteAsTags:true,editTags:{clicks:2,keepInvalid:true},transformTag:function(){},trim:true,a11y:{focusableTags:false},mixMode:{insertAfterTag:""},autoComplete:{enabled:true,rightKey:false,tabKey:false},classNames:{namespace:"tagify",mixMode:"tagify--mix",selectMode:"tagify--select",input:"tagify__input",focus:"tagify--focus",tagNoAnimation:"tagify--noAnim",tagInvalid:"tagify--invalid",tagNotAllowed:"tagify--notAllowed",scopeLoading:"tagify--loading",hasMaxTags:"tagify--hasMaxTags",hasNoTags:"tagify--noTags",empty:"tagify--empty",inputInvalid:"tagify__input--invalid",dropdown:"tagify__dropdown",dropdownWrapper:"tagify__dropdown__wrapper",dropdownHeader:"tagify__dropdown__header",dropdownFooter:"tagify__dropdown__footer",dropdownItem:"tagify__dropdown__item",dropdownItemActive:"tagify__dropdown__item--active",dropdownItemHidden:"tagify__dropdown__item--hidden",dropdownItemSelected:"tagify__dropdown__item--selected",dropdownInital:"tagify__dropdown--initial",tag:"tagify__tag",tagText:"tagify__tag-text",tagX:"tagify__tag__removeBtn",tagLoading:"tagify__tag--loading",tagEditing:"tagify__tag--editable",tagFlash:"tagify__tag--flash",tagHide:"tagify__tag--hide"},dropdown:{classname:"",enabled:2,maxItems:10,searchKeys:["value","searchBy"],fuzzySearch:true,caseSensitive:false,accentedSearch:true,includeSelectedTags:false,escapeHTML:true,highlightFirst:true,closeOnSelect:true,clearOnSelect:true,position:"all",appendTarget:null},hooks:{beforeRemoveTag:function(){return Promise.resolve()},beforePaste:function(){return Promise.resolve()},suggestionClick:function(){return Promise.resolve()},beforeKeyDown:function(){return Promise.resolve()}}};function x(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function S(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){x(t,e,i[e]);}));}return t}function I(t,e){return e=null!=e?e:{},Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i));})),t}function M(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function E(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function N(t){return function(t){if(Array.isArray(t))return M(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return M(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return M(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function A(){for(var t in this.dropdown={},this._dropdown)this.dropdown[t]="function"==typeof this._dropdown[t]?this._dropdown[t].bind(this):this._dropdown[t];this.dropdown.refs(),this.DOM.dropdown.__tagify=this;}var _,C,k=(_=function(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){E(t,e,i[e]);}));}return t}({},{events:{binding:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=this.dropdown.events.callbacks,i=this.listeners.dropdown=this.listeners.dropdown||{position:this.dropdown.position.bind(this,null),onKeyDown:e.onKeyDown.bind(this),onMouseOver:e.onMouseOver.bind(this),onMouseLeave:e.onMouseLeave.bind(this),onClick:e.onClick.bind(this),onScroll:e.onScroll.bind(this)},n=t?"addEventListener":"removeEventListener";"manual"!=this.settings.dropdown.position&&(document[n]("scroll",i.position,true),window[n]("resize",i.position),window[n]("keydown",i.onKeyDown)),this.DOM.dropdown[n]("mouseover",i.onMouseOver),this.DOM.dropdown[n]("mouseleave",i.onMouseLeave),this.DOM.dropdown[n]("mousedown",i.onClick),this.DOM.dropdown.content[n]("scroll",i.onScroll);},callbacks:{onKeyDown:function(t){var e=this;if(this.state.hasFocus&&!this.state.composing){var i=this.settings,s=i.dropdown.includeSelectedTags,a=this.DOM.dropdown.querySelector(i.classNames.dropdownItemActiveSelector),o=this.dropdown.getSuggestionDataByNode(a),r="mix"==i.mode,l="select"==i.mode;i.hooks.beforeKeyDown(t,{tagify:this}).then((function(d){switch(t.key){case "ArrowDown":case "ArrowUp":case "Down":case "Up":t.preventDefault();var c=e.dropdown.getAllSuggestionsRefs(),u="ArrowUp"==t.key||"Up"==t.key;a&&(a=e.dropdown.getNextOrPrevOption(a,!u)),a&&a.matches(i.classNames.dropdownItemSelector)||(a=c[u?c.length-1:0]),e.dropdown.highlightOption(a,true);break;case "PageUp":case "PageDown":var g;t.preventDefault();var h=e.dropdown.getAllSuggestionsRefs(),p=Math.floor(e.DOM.dropdown.content.clientHeight/(null===(g=h[0])||void 0===g?void 0:g.offsetHeight))||1,f="PageUp"===t.key;if(a){var m=h.indexOf(a),v=f?Math.max(0,m-p):Math.min(h.length-1,m+p);a=h[v];}else a=h[0];e.dropdown.highlightOption(a,true);break;case "Home":case "End":t.preventDefault();var b=e.dropdown.getAllSuggestionsRefs();a=b["Home"===t.key?0:b.length-1],e.dropdown.highlightOption(a,true);break;case "Escape":case "Esc":e.dropdown.hide();break;case "ArrowRight":if(e.state.actions.ArrowLeft||i.autoComplete.rightKey)return;case "Tab":var w=!i.autoComplete.rightKey||!i.autoComplete.tabKey;if(!r&&!l&&a&&w&&!e.state.editing&&o){t.preventDefault();var y=e.dropdown.getMappedValue(o);return e.state.autoCompleteData=o,e.input.autocomplete.set.call(e,y),false}return  true;case "Enter":t.preventDefault(),e.state.actions.selectOption=true,setTimeout((function(){return e.state.actions.selectOption=false}),100),i.hooks.suggestionClick(t,{tagify:e,tagData:o,suggestionElm:a}).then((function(){if(a){var i=s?a:e.dropdown.getNextOrPrevOption(a,!u);e.dropdown.selectOption(a,t,(function(){if(i){var t=i.getAttribute("value");i=e.dropdown.getSuggestionNodeByValue(t),e.dropdown.highlightOption(i);}}));}else e.dropdown.hide(),r||e.addTags(e.state.inputText.trim(),true);})).catch((function(t){return n.warn(t)}));break;case "Backspace":if(r||e.state.editing.scope)return;var T=e.input.raw.call(e);""!=T&&8203!=T.charCodeAt(0)||(true===i.backspace?e.removeTags():"edit"==i.backspace&&setTimeout(e.editTag.bind(e),0));}}));}},onMouseOver:function(t){var e=t.target.closest(this.settings.classNames.dropdownItemSelector);this.dropdown.highlightOption(e);},onMouseLeave:function(t){this.dropdown.highlightOption();},onClick:function(t){var e=this;if(0==t.button&&t.target!=this.DOM.dropdown&&t.target!=this.DOM.dropdown.content){var i=t.target.closest(this.settings.classNames.dropdownItemSelector),s=this.dropdown.getSuggestionDataByNode(i);this.state.actions.selectOption=true,setTimeout((function(){return e.state.actions.selectOption=false}),100),this.settings.hooks.suggestionClick(t,{tagify:this,tagData:s,suggestionElm:i}).then((function(){i?e.dropdown.selectOption(i,t):e.dropdown.hide();})).catch((function(t){return n.warn(t)}));}},onScroll:function(t){var e=t.target,i=e.scrollTop/(e.scrollHeight-e.parentNode.clientHeight)*100;this.trigger("dropdown:scroll",{percentage:Math.round(i)});}}},refilter:function(t){t=t||this.state.dropdown.query||"",this.suggestedListItems=this.dropdown.filterListItems(t),this.dropdown.fill(),this.suggestedListItems.length||this.dropdown.hide(),this.trigger("dropdown:updated",this.DOM.dropdown);},getSuggestionDataByNode:function(t){for(var e,i=t&&t.getAttribute("value"),n=this.suggestedListItems.length;n--;){if(c(e=this.suggestedListItems[n])&&e.value==i)return e;if(e==i)return {value:e}}},getSuggestionNodeByValue:function(t){return this.dropdown.getAllSuggestionsRefs().find((function(e){return e.getAttribute("value")===t}))},getNextOrPrevOption:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.dropdown.getAllSuggestionsRefs(),n=i.findIndex((function(e){return e===t}));return e?i[n+1]:i[n-1]},highlightOption:function(t,e){var i,n=this.settings.classNames.dropdownItemActive;if(this.state.ddItemElm&&(this.state.ddItemElm.classList.remove(n),this.state.ddItemElm.removeAttribute("aria-selected")),!t)return this.state.ddItemData=null,this.state.ddItemElm=null,void this.input.autocomplete.suggest.call(this);i=this.dropdown.getSuggestionDataByNode(t),this.state.ddItemData=i,this.state.ddItemElm=t,t.classList.add(n),t.setAttribute("aria-selected",true),e&&(t.parentNode.scrollTop=t.clientHeight+t.offsetTop-t.parentNode.clientHeight),this.settings.autoComplete&&(this.input.autocomplete.suggest.call(this,i),this.dropdown.position());},selectOption:function(t,e,i){var n=this,s=this.settings,a=s.dropdown.includeSelectedTags,o=s.dropdown,r=o.clearOnSelect,l=o.closeOnSelect;if(!t)return this.addTags(this.state.inputText,true),void(l&&this.dropdown.hide());e=e||{};var d=t.getAttribute("value"),c="noMatch"==d,g="mix"==s.mode,h=this.suggestedListItems.find((function(t){var e;return (null!==(e=t.value)&&void 0!==e?e:t)==d}));if(this.trigger("dropdown:select",{data:h,elm:t,event:e}),h||c){if(this.state.editing){var p=this.normalizeTags([h])[0];h=s.transformTag.call(this,p)||p,this.onEditTagDone(null,u({__isValid:true},h));}else this[g?"addMixTags":"addTags"]([h||this.input.raw.call(this)],r);(g||this.DOM.input.parentNode)&&(setTimeout((function(){n.DOM.input.focus(),n.toggleFocusClass(true);})),l&&setTimeout(this.dropdown.hide.bind(this)),a?i&&i():(t.addEventListener("transitionend",(function(){n.dropdown.fillHeaderFooter(),setTimeout((function(){t.remove(),n.dropdown.refilter(),i&&i();}),100);}),{once:true}),t.classList.add(this.settings.classNames.dropdownItemHidden)));}else l&&setTimeout(this.dropdown.hide.bind(this));},selectAll:function(t){this.suggestedListItems.length=0,this.dropdown.hide(),this.dropdown.filterListItems("");var e=this.dropdown.filterListItems("");return t||(e=this.state.dropdown.suggestions),this.addTags(e,true),this},filterListItems:function(t,e){var i,n,s,a,o,r,l=function(){var t,l,d=void 0,u=void 0;t=m[T],n=(null!=(l=Object)&&"undefined"!=typeof Symbol&&l[Symbol.hasInstance]?l[Symbol.hasInstance](t):t instanceof l)?m[T]:{value:m[T]};var v,b=!Object.keys(n).some((function(t){return y.includes(t)}))?["value"]:y;g.fuzzySearch&&!e.exact?(a=b.reduce((function(t,e){return t+" "+(n[e]||"")}),"").toLowerCase().trim(),g.accentedSearch&&(a=h(a),r=h(r)),d=0==a.indexOf(r),u=a===r,v=a,s=r.toLowerCase().split(" ").every((function(t){return v.includes(t.toLowerCase())}))):(d=true,s=b.some((function(t){var i=""+(n[t]||"");return g.accentedSearch&&(i=h(i),r=h(r)),g.caseSensitive||(i=i.toLowerCase()),u=i===r,e.exact?i===r:0==i.indexOf(r)}))),o=!g.includeSelectedTags&&i.isTagDuplicate(c(n)?n.value:n),s&&!o&&(u&&d?f.push(n):"startsWith"==g.sortby&&d?p.unshift(n):p.push(n));},d=this,u=this.settings,g=u.dropdown,p=(e=e||{},[]),f=[],m=u.whitelist,v=g.maxItems>=0?g.maxItems:1/0,b=g.includeSelectedTags,w="function"==typeof g.sortby,y=g.searchKeys,T=0;if(!(t="select"==u.mode&&this.value.length&&this.value[0][u.tagTextProp]==t?"":t)||!y.length){p=b?m:m.filter((function(t){return !d.isTagDuplicate(c(t)?t.value:t)}));var O=w?g.sortby(p,r):p.slice(0,v);return this.state.dropdown.suggestions=O,O}for(r=g.caseSensitive?""+t:(""+t).toLowerCase();T<m.length;T++)i=this,l();this.state.dropdown.suggestions=f.concat(p);O=w?g.sortby(f.concat(p),r):f.concat(p).slice(0,v);return this.state.dropdown.suggestions=O,O},getMappedValue:function(t){var e=this.settings.dropdown.mapValueTo;return e?"function"==typeof e?e(t):t[e]||t.value:t.value},createListHTML:function(t){var e=this;return u([],t).map((function(t,i){"string"!=typeof t&&"number"!=typeof t||(t={value:t});var n=e.dropdown.getMappedValue(t);return n="string"==typeof n&&e.settings.dropdown.escapeHTML?d(n):n,e.settings.templates.dropdownItem.apply(e,[I(S({},t),{mappedValue:n}),e])})).join("")}}),C=null!=(C={refs:function(){this.DOM.dropdown=this.parseTemplate("dropdown",[this.settings]),this.DOM.dropdown.content=this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");},getHeaderRef:function(){return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']")},getFooterRef:function(){return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']")},getAllSuggestionsRefs:function(){return N(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector))},show:function(t){var e,i,n,a=this,o=this.settings,r="mix"==o.mode&&!o.enforceWhitelist,l=!o.whitelist||!o.whitelist.length,d="manual"==o.dropdown.position;if(t=void 0===t?this.state.inputText:t,!(l&&!r&&!o.templates.dropdownItemNoMatch||false===o.dropdown.enabled||this.state.isLoading||this.settings.readonly)){if(clearTimeout(this.dropdownHide__bindEventsTimeout),this.suggestedListItems=this.dropdown.filterListItems(t),t&&!this.suggestedListItems.length&&(this.trigger("dropdown:noMatch",t),o.templates.dropdownItemNoMatch&&(n=o.templates.dropdownItemNoMatch.call(this,{value:t}))),!n){if(this.suggestedListItems.length)t&&r&&!this.state.editing.scope&&!s(this.suggestedListItems[0].value,t)&&this.suggestedListItems.unshift({value:t});else {if(!t||!r||this.state.editing.scope)return this.input.autocomplete.suggest.call(this),void this.dropdown.hide();this.suggestedListItems=[{value:t}];}i=""+(c(e=this.suggestedListItems[0])?e.value:e),o.autoComplete&&i&&0==i.indexOf(t)&&this.input.autocomplete.suggest.call(this,e);}this.dropdown.fill(n),o.dropdown.highlightFirst&&this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o.classNames.dropdownItemSelector)),this.state.dropdown.visible||setTimeout(this.dropdown.events.binding.bind(this)),this.state.dropdown.visible=t||true,this.state.dropdown.query=t,this.setStateSelection(),d||setTimeout((function(){a.dropdown.position(),a.dropdown.render();})),setTimeout((function(){a.trigger("dropdown:show",a.DOM.dropdown);}));}},hide:function(t){var e=this,i=this.DOM,n=i.scope,s=i.dropdown,a="manual"==this.settings.dropdown.position&&!t;if(s&&document.body.contains(s)&&!a)return window.removeEventListener("resize",this.dropdown.position),this.dropdown.events.binding.call(this,false),n.setAttribute("aria-expanded",false),s.parentNode.removeChild(s),setTimeout((function(){e.state.dropdown.visible=false;}),100),this.state.dropdown.query=this.state.ddItemData=this.state.ddItemElm=this.state.selection=null,this.state.tag&&this.state.tag.value.length&&(this.state.flaggedTags[this.state.tag.baseOffset]=this.state.tag),this.trigger("dropdown:hide",s),this},toggle:function(t){this.dropdown[this.state.dropdown.visible&&!t?"hide":"show"]();},getAppendTarget:function(){var t=this.settings.dropdown;return "function"==typeof t.appendTarget?t.appendTarget():t.appendTarget},render:function(){var t,e,i,n=this,s=(t=this.DOM.dropdown,(i=t.cloneNode(true)).style.cssText="position:fixed; top:-9999px; opacity:0",document.body.appendChild(i),e=i.clientHeight,i.parentNode.removeChild(i),e),a=this.settings,o=this.dropdown.getAppendTarget();return  false===a.dropdown.enabled||(this.DOM.scope.setAttribute("aria-expanded",true),document.body.contains(this.DOM.dropdown)||(this.DOM.dropdown.classList.add(a.classNames.dropdownInital),this.dropdown.position(s),o.appendChild(this.DOM.dropdown),setTimeout((function(){return n.DOM.dropdown.classList.remove(a.classNames.dropdownInital)})))),this},fill:function(t){t="string"==typeof t?t:this.dropdown.createListHTML(t||this.suggestedListItems);var e,i=this.settings.templates.dropdownContent.call(this,t);this.DOM.dropdown.content.innerHTML=(e=i)?e.replace(/\>[\r\n ]+\</g,"><").split(/>\s+</).join("><").trim():"";},fillHeaderFooter:function(){var t=this.dropdown.filterListItems(this.state.dropdown.query),e=this.parseTemplate("dropdownHeader",[t]),i=this.parseTemplate("dropdownFooter",[t]),n=this.dropdown.getHeaderRef(),s=this.dropdown.getFooterRef();e&&(null==n||n.parentNode.replaceChild(e,n)),i&&(null==s||s.parentNode.replaceChild(i,s));},position:function(t){var e=this.settings.dropdown,i=this.dropdown.getAppendTarget();if("manual"!=e.position&&i){var n,s,a,o,r,l,d,c,u,g,h=this.DOM.dropdown,p=e.RTL,f=i===document.body,m=i===this.DOM.scope,v=f?window.pageYOffset:i.scrollTop,b=document.fullscreenElement||document.webkitFullscreenElement||document.documentElement,w=b.clientHeight,y=Math.max(b.clientWidth||0,window.innerWidth||0),T=y>480?e.position:"all",O=this.DOM["input"==T?"input":"scope"];if(t=t||h.clientHeight,this.state.dropdown.visible){if("text"==T?(a=(n=function(){var t=document.getSelection();if(t.rangeCount){var e,i,n=t.getRangeAt(0),s=n.startContainer,a=n.startOffset;if(a>0)return (i=document.createRange()).setStart(s,a-1),i.setEnd(s,a),{left:(e=i.getBoundingClientRect()).right,top:e.top,bottom:e.bottom};if(s.getBoundingClientRect)return s.getBoundingClientRect()}return {left:-9999,top:-9999}}()).bottom,s=n.top,o=n.left,r="auto"):(l=function(t){var e=0,i=0;for(t=t.parentNode;t&&t!=b;)e+=t.offsetTop||0,i+=t.offsetLeft||0,t=t.parentNode;return {top:e,left:i}}(i),n=O.getBoundingClientRect(),s=m?-1:n.top-l.top,a=(m?n.height:n.bottom-l.top)-1,o=m?-1:n.left-l.left,r=n.width+"px"),!f){var D=function(){for(var t=0,i=e.appendTarget.parentNode;i;)t+=i.scrollTop||0,i=i.parentNode;return t}();s+=D,a+=D;}var x;s=Math.floor(s),a=Math.ceil(a),c=y-o<120,u=((d=null!==(x=e.placeAbove)&&void 0!==x?x:w-n.bottom<t)?s:a)+v,g=o+(p&&n.width||0)+window.pageXOffset,g="text"==T&&c?"right: 0;":"left: ".concat(g,"px;"),h.style.cssText="".concat(g," top: ").concat(u,"px; min-width: ").concat(r,"; max-width: ").concat(r),h.setAttribute("placement",d?"top":"bottom"),h.setAttribute("position",T);}}}})?C:{},Object.getOwnPropertyDescriptors?Object.defineProperties(_,Object.getOwnPropertyDescriptors(C)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(C)).forEach((function(t){Object.defineProperty(_,t,Object.getOwnPropertyDescriptor(C,t));})),_),L="@yaireo/tagify/",P={empty:"empty",exceed:"number of tags exceeded",pattern:"pattern mismatch",duplicate:"already exists",notAllowed:"not allowed"},j={wrapper:function(e,i){return '<tags class="'.concat(i.classNames.namespace," ").concat(i.mode?"".concat(i.classNames[i.mode+"Mode"]):""," ").concat(e.className,'"\n                    ').concat(i.readonly?"readonly":"","\n                    ").concat(i.disabled?"disabled":"","\n                    ").concat(i.required?"required":"","\n                    ").concat("select"===i.mode?"spellcheck='false'":"",'\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this),"\n                ").concat(t,"\n        </tags>")},input:function(){var e=this.settings,i=e.placeholder||t;return "<span ".concat(!e.readonly&&e.userInput?"contenteditable":"",' data-can-editable tabIndex="0" data-placeholder="').concat(i,'" aria-placeholder="').concat(e.placeholder||"",'"\n                    class="').concat(e.classNames.input,'"\n                    role="textbox"\n                    autocapitalize="false"\n                    autocorrect="off"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix"==e.mode,'"></span>')},tag:function(t,e){var i=e.settings;return '<tag title="'.concat(t.title||t.value,"\"\n                    contenteditable='false'\n                    tabIndex=\"").concat(i.a11y.focusableTags?0:-1,'"\n                    class="').concat(i.classNames.tag," ").concat(t.class||"",'"\n                    ').concat(this.getAttributes(t),">\n            <x title='' tabIndex=\"").concat(i.a11y.focusableTags?0:-1,'" class="').concat(i.classNames.tagX,"\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span ").concat("select"===i.mode&&i.userInput?"contenteditable='true'":"",' autocapitalize="false" autocorrect="off" spellcheck=\'false\' class="').concat(i.classNames.tagText,'">').concat(t[i.tagTextProp]||t.value,"</span>\n            </div>\n        </tag>")},dropdown:function(t){var e=t.dropdown,i="manual"==e.position;return '<div class="'.concat(i?"":t.classNames.dropdown," ").concat(e.classname,'" role="listbox" aria-labelledby="dropdown" dir="').concat(e.RTL?"rtl":"","\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"").concat(t.classNames.dropdownWrapper,'"></div>\n                </div>')},dropdownContent:function(t){var e=this.settings.templates,i=this.state.dropdown.suggestions;return "\n            ".concat(e.dropdownHeader.call(this,i),"\n            ").concat(t,"\n            ").concat(e.dropdownFooter.call(this,i),"\n        ")},dropdownItem:function(t){return "<div ".concat(this.getAttributes(t),"\n                    class='").concat(this.settings.classNames.dropdownItem," ").concat(this.isTagDuplicate(t.value)?this.settings.classNames.dropdownItemSelected:""," ").concat(t.class||"",'\'\n                    tabindex="0"\n                    role="option">').concat(t.mappedValue||t.value,"</div>")},dropdownHeader:function(t){return "<header data-selector='tagify-suggestions-header' class=\"".concat(this.settings.classNames.dropdownHeader,'"></header>')},dropdownFooter:function(t){var e=t.length-this.settings.dropdown.maxItems;return e>0?"<footer data-selector='tagify-suggestions-footer' class=\"".concat(this.settings.classNames.dropdownFooter,'">\n                ').concat(e," more items. Refine your search.\n            </footer>"):""},dropdownItemNoMatch:null};function V(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function R(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function F(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=i){var n,s,a=[],o=true,r=false;try{for(i=i.call(t);!(o=(n=i.next()).done)&&(a.push(n.value),!e||a.length!==e);o=!0);}catch(t){r=true,s=t;}finally{try{o||null==i.return||i.return();}finally{if(r)throw s}}return a}}(t,e)||function(t,e){if(!t)return;if("string"==typeof t)return V(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return V(t,e)}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function H(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function B(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function W(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function q(t,e){return e=null!=e?e:{},Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):function(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i.push.apply(i,n);}return i}(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i));})),t}function U(t){return function(t){if(Array.isArray(t))return H(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return H(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return H(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var K={customBinding:function(){var t=this;this.customEventsList.forEach((function(e){t.on(e,t.settings.callbacks[e]);}));},binding:function(){var t,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],i=this.settings,n=this.events.callbacks,s=e?"addEventListener":"removeEventListener";if(!(this.state.mainEvents&&e||i.disabled||i.readonly)){for(var a in this.state.mainEvents=e,e&&!this.listeners.main&&(this.events.bindGlobal.call(this),this.settings.isJQueryPlugin&&jQuery(this.DOM.originalInput).on("tagify.removeAllTags",this.removeAllTags.bind(this))),t=this.listeners.main=this.listeners.main||{keydown:["input",n.onKeydown.bind(this)],click:["scope",n.onClickScope.bind(this)],dblclick:"select"!=i.mode&&["scope",n.onDoubleClickScope.bind(this)],paste:["input",n.onPaste.bind(this)],drop:["input",n.onDrop.bind(this)],compositionstart:["input",n.onCompositionStart.bind(this)],compositionend:["input",n.onCompositionEnd.bind(this)]})t[a]&&this.DOM[t[a][0]][s](a,t[a][1]);var o=this.listeners.main.inputMutationObserver||new MutationObserver(n.onInputDOMChange.bind(this));o.disconnect(),"mix"==i.mode&&o.observe(this.DOM.input,{childList:true}),this.events.bindOriginaInputListener.call(this);}},bindOriginaInputListener:function(t){var e=(t||0)+500;this.listeners.main&&(clearInterval(this.listeners.main.originalInputValueObserverInterval),this.listeners.main.originalInputValueObserverInterval=setInterval(this.events.callbacks.observeOriginalInputValue.bind(this),e));},bindGlobal:function(t){var e,i=this.events.callbacks,n=t?"removeEventListener":"addEventListener";if(this.listeners&&(t||!this.listeners.global)){this.listeners.global=this.listeners.global||[{type:this.isIE?"keydown":"input",target:this.DOM.input,cb:i[this.isIE?"onInputIE":"onInput"].bind(this)},{type:"keydown",target:window,cb:i.onWindowKeyDown.bind(this)},{type:"focusin",target:this.DOM.scope,cb:i.onFocusBlur.bind(this)},{type:"focusout",target:this.DOM.scope,cb:i.onFocusBlur.bind(this)},{type:"click",target:document,cb:i.onClickAnywhere.bind(this),useCapture:true}];var s=true,a=false,o=void 0;try{for(var r,l=this.listeners.global[Symbol.iterator]();!(s=(r=l.next()).done);s=!0)(e=r.value).target[n](e.type,e.cb,!!e.useCapture);}catch(t){a=true,o=t;}finally{try{s||null==l.return||l.return();}finally{if(a)throw o}}}},unbindGlobal:function(){this.events.bindGlobal.call(this,true);},callbacks:{onFocusBlur:function(t){var e,i,n=this.settings,s=v.call(this,t.relatedTarget),a=m.call(this,t.target),o=t.target.classList.contains(n.classNames.tagX),r="focusin"==t.type,l="focusout"==t.type;o&&"mix"!=n.mode&&n.focusInputOnRemove&&this.DOM.input.focus(),s&&r&&!a&&!o&&this.toggleFocusClass(this.state.hasFocus=+new Date);var d=t.target?this.trim(this.DOM.input.textContent):"",c=null===(i=this.value)||void 0===i||null===(e=i[0])||void 0===e?void 0:e[n.tagTextProp],u=n.dropdown.enabled>=0,g={relatedTarget:t.relatedTarget},h=this.state.actions.selectOption&&(u||!n.dropdown.closeOnSelect),p=this.state.actions.addNew&&u;if(l){if(t.relatedTarget===this.DOM.scope)return this.dropdown.hide(),void this.DOM.input.focus();this.postUpdate(),n.onChangeAfterBlur&&this.triggerChangeEvent();}if(!(h||p||o))if(this.state.hasFocus=!(!r&&!s)&&+new Date,this.toggleFocusClass(this.state.hasFocus),"mix"!=n.mode){if(r){if(!n.focusable)return;var f=0===n.dropdown.enabled&&!this.state.dropdown.visible,b=this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector);return this.trigger("focus",g),void(f&&!a&&(this.dropdown.show(this.value.length?"":void 0),"select"===n.mode&&this.setRangeAtStartEnd(false,b)))}if(l){if(this.trigger("blur",g),this.loading(false),"select"==n.mode){if(this.value.length){var w=this.getTagElms()[0];d=this.trim(w.textContent);}c===d&&(d="");}d&&!this.state.actions.selectOption&&n.addTagOnBlur&&n.addTagOn.includes("blur")&&this.addTags(d,true);}s||(this.DOM.input.removeAttribute("style"),this.dropdown.hide());}else r?this.trigger("focus",g):l&&(this.trigger("blur",g),this.loading(false),this.dropdown.hide(),this.state.dropdown.visible=void 0,this.setStateSelection());},onCompositionStart:function(t){this.state.composing=true;},onCompositionEnd:function(t){this.state.composing=false;},onWindowKeyDown:function(t){var e,i=this.settings,n=document.activeElement,s=v.call(this,n)&&this.DOM.scope.contains(n),a=n===this.DOM.input,o=s&&n.hasAttribute("readonly"),r=this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector),l=this.state.dropdown.visible;if(("Tab"===t.key&&l||this.state.hasFocus||s&&!o)&&!a){e=n.nextElementSibling;var d=t.target.classList.contains(i.classNames.tagX);switch(t.key){case "Backspace":i.readonly||this.state.editing||(this.removeTags(n),(e||this.DOM.input).focus());break;case "Enter":if(d)return void this.removeTags(t.target.parentNode);i.a11y.focusableTags&&m.call(this,n)&&setTimeout(this.editTag.bind(this),0,n);break;case "ArrowDown":this.state.dropdown.visible||"mix"==i.mode||this.dropdown.show();break;case "Tab":null==r||r.focus();}}},onKeydown:function(t){var e=this,i=this.settings;if(!this.state.composing&&i.userInput){"select"==i.mode&&i.enforceWhitelist&&this.value.length&&"Tab"!=t.key&&t.preventDefault();var n=this.trim(t.target.textContent);this.trigger("keydown",{event:t}),i.hooks.beforeKeyDown(t,{tagify:this}).then((function(s){if("mix"==i.mode){switch(t.key){case "Left":case "ArrowLeft":e.state.actions.ArrowLeft=true;break;case "Delete":case "Backspace":if(e.state.editing)return;var a=document.getSelection(),o="Delete"==t.key&&a.anchorOffset==(a.anchorNode.length||0),r=a.anchorNode.previousSibling,d=1==a.anchorNode.nodeType||!a.anchorOffset&&r&&1==r.nodeType&&a.anchorNode.previousSibling;!function(t){var e=document.createElement("div");t.replace(/\&#?[0-9a-z]+;/gi,(function(t){return e.innerHTML=t,e.innerText}));}(e.DOM.input.innerHTML);var c,u,g,h=e.getTagElms(),f=1===a.anchorNode.length&&a.anchorNode.nodeValue==String.fromCharCode(8203);if("edit"==i.backspace&&d)return c=1==a.anchorNode.nodeType?null:a.anchorNode.previousElementSibling,setTimeout(e.editTag.bind(e),0,c),void t.preventDefault();if(p()&&W(d,Element))return g=l(d),d.hasAttribute("readonly")||d.remove(),e.DOM.input.focus(),void setTimeout((function(){T(g),e.DOM.input.click();}));if("BR"==a.anchorNode.nodeName)return;if((o||d)&&1==a.anchorNode.nodeType?u=0==a.anchorOffset?o?h[0]:null:h[Math.min(h.length,a.anchorOffset)-1]:o?u=a.anchorNode.nextElementSibling:W(d,Element)&&(u=d),3==a.anchorNode.nodeType&&!a.anchorNode.nodeValue&&a.anchorNode.previousElementSibling&&t.preventDefault(),(d||o)&&!i.backspace)return void t.preventDefault();if("Range"!=a.type&&!a.anchorOffset&&a.anchorNode==e.DOM.input&&"Delete"!=t.key)return void t.preventDefault();if("Range"!=a.type&&u&&u.hasAttribute("readonly"))return void T(l(u));"Delete"==t.key&&f&&y(a.anchorNode.nextSibling)&&e.removeTags(a.anchorNode.nextSibling);}return  true}var m="manual"==i.dropdown.position;switch(t.key){case "Backspace":"select"==i.mode&&i.enforceWhitelist&&e.value.length?e.removeTags():e.state.dropdown.visible&&"manual"!=i.dropdown.position||""!=t.target.textContent&&8203!=n.charCodeAt(0)||(true===i.backspace?e.removeTags():"edit"==i.backspace&&setTimeout(e.editTag.bind(e),0));break;case "Esc":case "Escape":if(e.state.dropdown.visible)return;t.target.blur();break;case "Down":case "ArrowDown":e.state.dropdown.visible||e.dropdown.show();break;case "ArrowRight":var v=e.state.inputSuggestion||e.state.ddItemData;if(v&&i.autoComplete.rightKey)return void e.addTags([v],true);break;case "Tab":return  true;case "Enter":if(e.state.dropdown.visible&&!m)return;t.preventDefault();var b=e.state.autoCompleteData||n;setTimeout((function(){e.state.dropdown.visible&&!m||e.state.actions.selectOption||!i.addTagOn.includes(t.key.toLowerCase())||(e.addTags([b],true),e.state.autoCompleteData=null);}));}})).catch((function(t){return t}));}},onInput:function(t){this.postUpdate();var e=this.settings;if("mix"==e.mode)return this.events.callbacks.onMixTagsInput.call(this,t);var i=this.input.normalize.call(this,void 0,{trim:false}),n=i.length>=e.dropdown.enabled,s={value:i,inputElm:this.DOM.input},a=this.validateTag({value:i});"select"==e.mode&&this.toggleScopeValidation(a),s.isValid=a,this.state.inputText!=i&&(this.input.set.call(this,i,false),-1!=i.search(e.delimiters)?this.addTags(i)&&this.input.set.call(this):e.dropdown.enabled>=0&&this.dropdown[n?"show":"hide"](i),this.trigger("input",s));},onMixTagsInput:function(t){var e,i,n,s,a,o,r,l,d=this,c=this.settings,g=this.value.length,h=this.getTagElms(),f=document.createDocumentFragment(),m=window.getSelection().getRangeAt(0),v=[].map.call(h,(function(t){return y(t).value}));if("deleteContentBackward"==t.inputType&&p()&&this.events.callbacks.onKeydown.call(this,{target:t.target,key:"Backspace"}),O(this.getTagElms()),this.value.slice().forEach((function(t){t.readonly&&!v.includes(t.value)&&f.appendChild(d.createTagElem(t));})),f.childNodes.length&&(m.insertNode(f),this.setRangeAtStartEnd(false,f.lastChild)),h.length!=g)return this.value=[].map.call(this.getTagElms(),(function(t){return y(t)})),void this.update({withoutChangeEvent:true});if(this.hasMaxTags())return  true;if(window.getSelection&&(o=window.getSelection()).rangeCount>0&&3==o.anchorNode.nodeType){if((m=o.getRangeAt(0).cloneRange()).collapse(true),m.setStart(o.focusNode,0),n=(e=m.toString().slice(0,m.endOffset)).split(c.pattern).length-1,(i=e.match(c.pattern))&&(s=e.slice(e.lastIndexOf(i[i.length-1]))),s){if(this.state.actions.ArrowLeft=false,this.state.tag={prefix:s.match(c.pattern)[0],value:s.replace(c.pattern,"")},this.state.tag.baseOffset=o.baseOffset-this.state.tag.value.length,l=this.state.tag.value.match(c.delimiters))return this.state.tag.value=this.state.tag.value.replace(c.delimiters,""),this.state.tag.delimiters=l[0],this.addTags(this.state.tag.value,c.dropdown.clearOnSelect),void this.dropdown.hide();a=this.state.tag.value.length>=c.dropdown.enabled;try{r=(r=this.state.flaggedTags[this.state.tag.baseOffset]).prefix==this.state.tag.prefix&&r.value[0]==this.state.tag.value[0],this.state.flaggedTags[this.state.tag.baseOffset]&&!this.state.tag.value&&delete this.state.flaggedTags[this.state.tag.baseOffset];}catch(t){}(r||n<this.state.mixMode.matchedPatternCount)&&(a=false);}else this.state.flaggedTags={};this.state.mixMode.matchedPatternCount=n;}setTimeout((function(){d.update({withoutChangeEvent:true}),d.trigger("input",u({},d.state.tag,{textContent:d.DOM.input.textContent})),d.state.tag&&d.dropdown[a?"show":"hide"](d.state.tag.value);}),10);},onInputIE:function(t){var e=this;setTimeout((function(){e.events.callbacks.onInput.call(e,t);}));},observeOriginalInputValue:function(){this.DOM.originalInput.parentNode||this.destroy(),this.DOM.originalInput.value!=this.DOM.originalInput.tagifyValue&&this.loadOriginalValues();},onClickAnywhere:function(t){if(t.target!=this.DOM.scope&&!this.DOM.scope.contains(t.target)){this.toggleFocusClass(false),this.state.hasFocus=false;var e=t.target.closest(this.settings.classNames.dropdownSelector);(null==e?void 0:e.__tagify)!=this&&this.dropdown.hide();}},onClickScope:function(t){var e=this.settings,i=t.target.closest("."+e.classNames.tag);t.target,this.DOM.scope;var n=+new Date-this.state.hasFocus;if(!t.target.classList.contains(e.classNames.tagX))return i&&!this.state.editing?(this.trigger("click",{tag:i,index:this.getNodeIndex(i),data:y(i),event:t}),void(1!==e.editTags&&1!==e.editTags.clicks&&"select"!=e.mode||this.events.callbacks.onDoubleClickScope.call(this,t))):void(t.target==this.DOM.input&&("mix"==e.mode&&this.fixFirefoxLastTagNoCaret(),n>500||!e.focusable)?this.state.dropdown.visible?this.dropdown.hide():0===e.dropdown.enabled&&"mix"!=e.mode&&this.dropdown.show(this.value.length?"":void 0):"select"!=e.mode||0!==e.dropdown.enabled||this.state.dropdown.visible||(this.events.callbacks.onDoubleClickScope.call(this,q(function(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){B(t,e,i[e]);}));}return t}({},t),{target:this.getTagElms()[0]})),!e.userInput&&this.dropdown.show()));this.removeTags(t.target.parentNode);},onPaste:function(t){var e=this;t.preventDefault();var i,n,s,a=this.settings;if(!a.userInput)return  false;a.readonly||(n=t.clipboardData||window.clipboardData,s=n.getData("Text"),a.hooks.beforePaste(t,{tagify:this,pastedText:s,clipboardData:n}).then((function(a){ void 0===a&&(a=s),a&&(e.injectAtCaret(a,window.getSelection().getRangeAt(0)),"mix"==e.settings.mode?e.events.callbacks.onMixTagsInput.call(e,t):e.settings.pasteAsTags?i=e.addTags(e.state.inputText+a,true):(e.state.inputText=a,e.dropdown.show(a))),e.trigger("paste",{event:t,pastedText:s,clipboardData:n,tagsElems:i});})).catch((function(t){return t})));},onDrop:function(t){t.preventDefault();},onEditTagInput:function(t,e){var i,n=t.closest("."+this.settings.classNames.tag),s=this.getNodeIndex(n),a=y(n),o=this.input.normalize.call(this,t),r=(B(i={},this.settings.tagTextProp,o),B(i,"__tagId",a.__tagId),i),l=this.validateTag(r);this.editTagChangeDetected(u(a,r))||true!==t.originalIsValid||(l=true),n.classList.toggle(this.settings.classNames.tagInvalid,true!==l),a.__isValid=l,n.title=true===l?a.title||a.value:l,o.length>=this.settings.dropdown.enabled&&(this.state.editing&&(this.state.editing.value=o),this.dropdown.show(o)),this.trigger("edit:input",{tag:n,index:s,data:u({},this.value[s],{newValue:o}),event:e});},onEditTagPaste:function(t,e){var i=(e.clipboardData||window.clipboardData).getData("Text");e.preventDefault();var n=w(i);this.setRangeAtStartEnd(false,n);},onEditTagClick:function(t,e){this.events.callbacks.onClickScope.call(this,e);},onEditTagFocus:function(t){this.state.editing={scope:t,input:t.querySelector("[contenteditable]")};},onEditTagBlur:function(t,e){var i=m.call(this,e.relatedTarget);if("select"==this.settings.mode&&i&&e.relatedTarget.contains(e.target))this.dropdown.hide();else if(this.state.editing&&(this.state.hasFocus||this.toggleFocusClass(),this.DOM.scope.contains(document.activeElement)||this.trigger("blur",{}),this.DOM.scope.contains(t))){var n,s,a,o=this.settings,r=t.closest("."+o.classNames.tag),l=y(r),d=this.input.normalize.call(this,t),c=(B(n={},o.tagTextProp,d),B(n,"__tagId",l.__tagId),n),g=l.__originalData,h=this.editTagChangeDetected(u(l,c)),p=this.validateTag(c);if(d)if(h){var f;if(s=this.hasMaxTags(),a=u({},g,(B(f={},o.tagTextProp,this.trim(d)),B(f,"__isValid",p),f)),o.transformTag.call(this,a,g),true!==(p=(!s||true===g.__isValid)&&this.validateTag(a))){if(this.trigger("invalid",{data:a,tag:r,message:p}),o.editTags.keepInvalid)return;o.keepInvalidTags?a.__isValid=p:a=g;}else o.keepInvalidTags&&(delete a.title,delete a["aria-invalid"],delete a.class);this.onEditTagDone(r,a);}else this.onEditTagDone(r,g);else this.onEditTagDone(r);}},onEditTagkeydown:function(t,e){if(!this.state.composing)switch(this.trigger("edit:keydown",{event:t}),t.key){case "Esc":case "Escape":this.state.editing=false,!!e.__tagifyTagData.__originalData.value?e.parentNode.replaceChild(e.__tagifyTagData.__originalHTML,e):e.remove();break;case "Enter":case "Tab":t.preventDefault();setTimeout((function(){return t.target.blur()}),0);}},onDoubleClickScope:function(t){var e=t.target.closest("."+this.settings.classNames.tag);if(e){var i,n,s=y(e),a=this.settings;false!==(null==s?void 0:s.editable)&&(i=e.classList.contains(this.settings.classNames.tagEditing),n=e.hasAttribute("readonly"),a.readonly||i||n||!this.settings.editTags||!a.userInput||(this.events.callbacks.onEditTagFocus.call(this,e),this.editTag(e)),this.toggleFocusClass(true),"select"!=a.mode&&this.trigger("dblclick",{tag:e,index:this.getNodeIndex(e),data:y(e)}));}},onInputDOMChange:function(t){var e=this;t.forEach((function(t){t.addedNodes.forEach((function(t){if("<div><br></div>"==t.outerHTML)t.replaceWith(document.createElement("br"));else if(1==t.nodeType&&t.querySelector(e.settings.classNames.tagSelector)){var i,n=document.createTextNode("");3==t.childNodes[0].nodeType&&"BR"!=t.previousSibling.nodeName&&(n=document.createTextNode("\n")),(i=t).replaceWith.apply(i,U([n].concat(U(U(t.childNodes).slice(0,-1))))),T(n);}else if(m.call(e,t)){var s;if(3!=(null===(s=t.previousSibling)||void 0===s?void 0:s.nodeType)||t.previousSibling.textContent||t.previousSibling.remove(),t.previousSibling&&"BR"==t.previousSibling.nodeName){t.previousSibling.replaceWith("\n");for(var a=t.nextSibling,o="";a;)o+=a.textContent,a=a.nextSibling;o.trim()&&T(t.previousSibling);}else t.previousSibling&&!y(t.previousSibling)||t.before("");}})),t.removedNodes.forEach((function(t){t&&"BR"==t.nodeName&&m.call(e,i)&&(e.removeTags(i),e.fixFirefoxLastTagNoCaret());}));}));var i=this.DOM.input.lastChild;i&&""==i.nodeValue&&i.remove(),i&&"BR"==i.nodeName||this.DOM.input.appendChild(document.createElement("br"));}}};function z(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function X(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:true,configurable:true,writable:true}):t[e]=i,t}function J(t,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](t):t instanceof e}function G(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{},n=Object.keys(i);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(i).filter((function(t){return Object.getOwnPropertyDescriptor(i,t).enumerable})))),n.forEach((function(e){X(t,e,i[e]);}));}return t}function $$1(t){return function(t){if(Array.isArray(t))return z(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return z(t,e);var i=Object.prototype.toString.call(t).slice(8,-1);"Object"===i&&t.constructor&&(i=t.constructor.name);if("Map"===i||"Set"===i)return Array.from(i);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return z(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Q(t,e){if(!t){n.warn("input element not found",t);var i=new Proxy(this,{get:function(){return function(){return i}}});return i}if(t.__tagify)return n.warn("input element is already Tagified - Same instance is returned.",t),t.__tagify;var s;u(this,function(t){var e=document.createTextNode(""),i={};function s(t,i,n){n&&i.split(/\s+/g).forEach((function(i){return e[t+"EventListener"].call(e,i,n)}));}return {removeAllCustomListeners:function(){Object.entries(i).forEach((function(t){var e=F(t,2),i=e[0];e[1].forEach((function(t){return s("remove",i,t)}));})),i={};},off:function(t,e){return t&&(e?s("remove",t,e):t.split(/\s+/g).forEach((function(t){var e;null===(e=i[t])||void 0===e||e.forEach((function(e){return s("remove",t,e)})),delete i[t];}))),this},on:function(t,e){return e&&"function"==typeof e&&(t.split(/\s+/g).forEach((function(t){Array.isArray(i[t])?i[t].push(e):i[t]=[e];})),s("add",t,e)),this},trigger:function(i,s,a){var o;if(a=a||{cloneData:true},i)if(t.settings.isJQueryPlugin)"remove"==i&&(i="removeTag"),jQuery(t.DOM.originalInput).triggerHandler(i,[s]);else {try{var r="object"==typeof s?s:{value:s};if((r=a.cloneData?u({},r):r).tagify=this,s.event&&(r.event=this.cloneEvent(s.event)),R(s,Object))for(var l in s)R(s[l],HTMLElement)&&(r[l]=s[l]);o=new CustomEvent(i,{detail:r});}catch(t){n.warn(t);}e.dispatchEvent(o);}}}}(this)),this.isFirefox=/firefox|fxios/i.test(navigator.userAgent)&&!/seamonkey/i.test(navigator.userAgent),this.isIE=window.document.documentMode,e=e||{},this.getPersistedData=(s=e.id,function(t){var e;if(s){var i,n="/"+t;if(1===(null===(e=localStorage)||void 0===e?void 0:e.getItem(L+s+"/v")))try{i=JSON.parse(localStorage[L+s+n]);}catch(t){}return i}}),this.setPersistedData=function(t){var e;return t?(null===(e=localStorage)||void 0===e||e.setItem(L+t+"/v",1),function(e,i){var n,s="/"+i,a=JSON.stringify(e);e&&i&&(null===(n=localStorage)||void 0===n||n.setItem(L+t+s,a),dispatchEvent(new Event("storage")));}):function(){}}(e.id),this.clearPersistedData=function(t){return function(e){var i=L+"/"+t+"/";if(e)localStorage.removeItem(i+e);else for(var n in localStorage)n.includes(i)&&localStorage.removeItem(n);}}(e.id),this.applySettings(t,e),this.state={inputText:"",editing:false,composing:false,actions:{},mixMode:{},dropdown:{},flaggedTags:{}},this.value=[],this.listeners={},this.DOM={},this.build(t),A.call(this),this.getCSSVars(),this.loadOriginalValues(),this.events.customBinding.call(this),this.events.binding.call(this),t.autofocus&&this.DOM.input.focus(),t.__tagify=this;}Q.prototype={_dropdown:k,placeCaretAfterNode:T,getSetTagData:y,helpers:{sameStr:s,removeCollectionProp:a,omit:o,isObject:c,parseHTML:r,escapeHTML:d,extend:u,concatWithoutDups:g,getUID:f,isNodeTag:m},customEventsList:["change","add","remove","invalid","input","paste","click","keydown","focus","blur","edit:input","edit:beforeUpdate","edit:updated","edit:start","edit:keydown","dropdown:show","dropdown:hide","dropdown:select","dropdown:updated","dropdown:noMatch","dropdown:scroll"],dataProps:["__isValid","__removed","__originalData","__originalHTML","__tagId"],trim:function(t){return this.settings.trim&&t&&"string"==typeof t?t.trim():t},parseHTML:r,templates:j,parseTemplate:function(t,e){return r((t=this.settings.templates[t]||t).apply(this,e))},set whitelist(t){var e=t&&Array.isArray(t);this.settings.whitelist=e?t:[],this.setPersistedData(e?t:[],"whitelist");},get whitelist(){return this.settings.whitelist},set userInput(t){this.settings.userInput=!!t,this.setContentEditable(!!t);},get userInput(){return this.settings.userInput},generateClassSelectors:function(t){var e=function(e){var i=e;Object.defineProperty(t,i+"Selector",{get:function(){return "."+this[i].split(" ")[0]}});};for(var i in t)e(i);},applySettings:function(t,e){var i,n;D.templates=this.templates;var s=u({},D,"mix"==e.mode?{dropdown:{position:"text"}}:{}),a=this.settings=u({},s,e);if(a.disabled=t.hasAttribute("disabled"),a.readonly=a.readonly||t.hasAttribute("readonly"),a.placeholder=d(t.getAttribute("placeholder")||a.placeholder||""),a.required=t.hasAttribute("required"),this.generateClassSelectors(a.classNames),this.isIE&&(a.autoComplete=false),["whitelist","blacklist"].forEach((function(e){var i=t.getAttribute("data-"+e);i&&J(i=i.split(a.delimiters),Array)&&(a[e]=i);})),"autoComplete"in e&&!c(e.autoComplete)&&(a.autoComplete=D.autoComplete,a.autoComplete.enabled=e.autoComplete),"mix"==a.mode&&(a.pattern=a.pattern||/@/,a.autoComplete.rightKey=true,a.delimiters=e.delimiters||null,a.tagTextProp&&!a.dropdown.searchKeys.includes(a.tagTextProp)&&a.dropdown.searchKeys.push(a.tagTextProp)),t.pattern)try{a.pattern=new RegExp(t.pattern);}catch(t){}if(a.delimiters){a._delimiters=a.delimiters;try{a.delimiters=new RegExp(this.settings.delimiters,"g");}catch(t){}}(a.disabled||a.readonly)&&(a.userInput=false),this.TEXTS=G({},P,a.texts||{}),"select"==a.mode&&(a.dropdown.includeSelectedTags=true),("select"!=a.mode||(null===(i=e.dropdown)||void 0===i?void 0:i.enabled))&&a.userInput||(a.dropdown.enabled=0),a.disabled&&(a.dropdown.enabled=false),a.dropdown.appendTarget=(null===(n=e.dropdown)||void 0===n?void 0:n.appendTarget)||document.body,void 0===a.dropdown.includeSelectedTags&&(a.dropdown.includeSelectedTags=a.duplicates);var o=this.getPersistedData("whitelist");Array.isArray(o)&&(this.whitelist=Array.isArray(a.whitelist)?g(a.whitelist,o):o);},getAttributes:function(t){var e,i=this.getCustomAttributes(t),n="";for(e in i)n+=" "+e+(void 0!==t[e]?'="'.concat(i[e],'"'):"");return n},getCustomAttributes:function(t){if(!c(t))return "";var e,i={};for(e in t)"__"!=e.slice(0,2)&&"class"!=e&&t.hasOwnProperty(e)&&void 0!==t[e]&&(i[e]=d(t[e]));return i},setStateSelection:function(){var t=window.getSelection(),e={anchorOffset:t.anchorOffset,anchorNode:t.anchorNode,range:t.getRangeAt&&t.rangeCount&&t.getRangeAt(0)};return this.state.selection=e,e},getCSSVars:function(){var t,e,i,n=getComputedStyle(this.DOM.scope,null);this.CSSVars={tagHideTransition:(t=function(t){if(!t)return {};var e=(t=t.trim().split(" ")[0]).split(/\d+/g).filter((function(t){return t})).pop().trim();return {value:+t.split(e).filter((function(t){return t}))[0].trim(),unit:e}}((i="tag-hide-transition",n.getPropertyValue("--"+i))),e=t.value,"s"==t.unit?1e3*e:e)};},build:function(t){var e=this.DOM,i=t.closest("label");this.settings.mixMode.integrated?(e.originalInput=null,e.scope=t,e.input=t):(e.originalInput=t,e.originalInput_tabIndex=t.tabIndex,e.scope=this.parseTemplate("wrapper",[t,this.settings]),e.input=e.scope.querySelector(this.settings.classNames.inputSelector),t.parentNode.insertBefore(e.scope,t),t.tabIndex=-1),i&&i.setAttribute("for","");},destroy:function(){var t;this.events.unbindGlobal.call(this),null===(t=this.DOM.scope.parentNode)||void 0===t||t.removeChild(this.DOM.scope),this.DOM.originalInput.tabIndex=this.DOM.originalInput_tabIndex,delete this.DOM.originalInput.__tagify,this.dropdown.hide(true),this.removeAllCustomListeners(),clearTimeout(this.dropdownHide__bindEventsTimeout),clearInterval(this.listeners.main.originalInputValueObserverInterval);},loadOriginalValues:function(t){var e,i=this.settings;if(this.state.blockChangeEvent=true,void 0===t){var n=this.getPersistedData("value");t=n&&!this.DOM.originalInput.value?n:i.mixMode.integrated?this.DOM.input.textContent:this.DOM.originalInput.value;}if(this.removeAllTags(),t)if("mix"==i.mode)this.parseMixTags(t),(e=this.DOM.input.lastChild)&&"BR"==e.tagName||this.DOM.input.insertAdjacentHTML("beforeend","<br>");else {try{J(JSON.parse(t),Array)&&(t=JSON.parse(t));}catch(t){}this.addTags(t,true).forEach((function(t){return t&&t.classList.add(i.classNames.tagNoAnimation)}));}else this.postUpdate();this.state.lastOriginalValueReported=i.mixMode.integrated?"":this.DOM.originalInput.value;},cloneEvent:function(t){var e={};for(var i in t)"path"!=i&&(e[i]=t[i]);return e},loading:function(t){return this.state.isLoading=t,this.DOM.scope.classList[t?"add":"remove"](this.settings.classNames.scopeLoading),this},tagLoading:function(t,e){return t&&t.classList[e?"add":"remove"](this.settings.classNames.tagLoading),this},toggleClass:function(t,e){"string"==typeof t&&this.DOM.scope.classList.toggle(t,e);},toggleScopeValidation:function(t){var e=true===t||void 0===t;!this.settings.required&&t&&t===this.TEXTS.empty&&(e=true),this.toggleClass(this.settings.classNames.tagInvalid,!e),this.DOM.scope.title=e?"":t;},toggleFocusClass:function(t){this.toggleClass(this.settings.classNames.focus,!!t);},setPlaceholder:function(t){var e=this;["data","aria"].forEach((function(i){return e.DOM.input.setAttribute("".concat(i,"-placeholder"),t)}));},triggerChangeEvent:function(){if(!this.settings.mixMode.integrated){var t=this.DOM.originalInput,e=this.state.lastOriginalValueReported!==t.value,i=new CustomEvent("change",{bubbles:true});e&&(this.state.lastOriginalValueReported=t.value,i.simulated=true,t._valueTracker&&t._valueTracker.setValue(Math.random()),t.dispatchEvent(i),this.trigger("change",this.state.lastOriginalValueReported),t.value=this.state.lastOriginalValueReported);}},events:K,fixFirefoxLastTagNoCaret:function(){},setRangeAtStartEnd:function(t,e){if(e){t="number"==typeof t?t:!!t,e=e.lastChild||e;var i=document.getSelection();if(J(i.focusNode,Element)&&!this.DOM.input.contains(i.focusNode))return  true;try{i.rangeCount>=1&&["Start","End"].forEach((function(n){return i.getRangeAt(0)["set"+n](e,t||e.length)}));}catch(t){console.warn(t);}}},insertAfterTag:function(t,e){if(e=e||this.settings.mixMode.insertAfterTag,t&&t.parentNode&&e)return e="string"==typeof e?document.createTextNode(e):e,t.parentNode.insertBefore(e,t.nextSibling),e},editTagChangeDetected:function(t){var e=t.__originalData;for(var i in e)if(!this.dataProps.includes(i)&&t[i]!=e[i])return  true;return  false},getTagTextNode:function(t){return t.querySelector(this.settings.classNames.tagTextSelector)},setTagTextNode:function(t,e){this.getTagTextNode(t).innerHTML=d(e);},editTag:function(t,e){var i=this;t=t||this.getLastTag(),e=e||{};var s=this.settings,a=this.getTagTextNode(t),o=this.getNodeIndex(t),r=y(t),l=this.events.callbacks,d=true,c="select"==s.mode;if(!c&&this.dropdown.hide(),a){if(!J(r,Object)||!("editable"in r)||r.editable)return r=y(t,{__originalData:u({},r),__originalHTML:t.cloneNode(true)}),y(r.__originalHTML,r.__originalData),a.setAttribute("contenteditable",true),t.classList.add(s.classNames.tagEditing),this.events.callbacks.onEditTagFocus.call(this,t),a.addEventListener("click",l.onEditTagClick.bind(this,t)),a.addEventListener("blur",l.onEditTagBlur.bind(this,this.getTagTextNode(t))),a.addEventListener("input",l.onEditTagInput.bind(this,a)),a.addEventListener("paste",l.onEditTagPaste.bind(this,a)),a.addEventListener("keydown",(function(e){return l.onEditTagkeydown.call(i,e,t)})),a.addEventListener("compositionstart",l.onCompositionStart.bind(this)),a.addEventListener("compositionend",l.onCompositionEnd.bind(this)),e.skipValidation||(d=this.editTagToggleValidity(t)),a.originalIsValid=d,this.trigger("edit:start",{tag:t,index:o,data:r,isValid:d}),a.focus(),!c&&this.setRangeAtStartEnd(false,a),0===s.dropdown.enabled&&!c&&this.dropdown.show(),this.state.hasFocus=true,this}else n.warn("Cannot find element in Tag template: .",s.classNames.tagTextSelector);},editTagToggleValidity:function(t,e){var i;if(e=e||y(t))return (i=!("__isValid"in e)||true===e.__isValid)||this.removeTagsFromValue(t),this.update(),t.classList.toggle(this.settings.classNames.tagNotAllowed,!i),e.__isValid=i,e.__isValid;n.warn("tag has no data: ",t,e);},onEditTagDone:function(t,e){t=t||this.state.editing.scope,e=e||{};var i,n,s=this.settings,a={tag:t,index:this.getNodeIndex(t),previousData:y(t),data:e};this.trigger("edit:beforeUpdate",a,{cloneData:false}),this.state.editing=false,delete e.__originalData,delete e.__originalHTML,t&&t.parentNode&&((void 0!==(n=e[s.tagTextProp])?null===(i=(n+="").trim)||void 0===i?void 0:i.call(n):s.tagTextProp in e?void 0:e.value)?(t=this.replaceTag(t,e),this.editTagToggleValidity(t,e),s.a11y.focusableTags?t.focus():"select"!=s.mode&&T(t)):this.removeTags(t)),this.trigger("edit:updated",a),s.dropdown.closeOnSelect&&this.dropdown.hide(),this.settings.keepInvalidTags&&this.reCheckInvalidTags();},replaceTag:function(t,e){e&&""!==e.value&&void 0!==e.value||(e=t.__tagifyTagData),e.__isValid&&1!=e.__isValid&&u(e,this.getInvalidTagAttrs(e,e.__isValid));var i=this.createTagElem(e);return t.parentNode.replaceChild(i,t),this.updateValueByDOMTags(),i},updateValueByDOMTags:function(){var t=this;this.value.length=0;var e=this.settings.classNames,i=[e.tagNotAllowed.split(" ")[0],e.tagHide];[].forEach.call(this.getTagElms(),(function(e){$$1(e.classList).some((function(t){return i.includes(t)}))||t.value.push(y(e));})),this.update(),this.dropdown.refilter();},injectAtCaret:function(t,e){var i;if(e=e||(null===(i=this.state.selection)||void 0===i?void 0:i.range),"string"==typeof t&&(t=document.createTextNode(t)),!e&&t)return this.appendMixTags(t),this;var n=w(t,e);return this.setRangeAtStartEnd(false,n),this.updateValueByDOMTags(),this.update(),this},input:{set:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.settings,n=i.dropdown.closeOnSelect;this.state.inputText=t,e&&(this.DOM.input.innerHTML=d(""+t),t&&this.toggleClass(i.classNames.empty,!this.DOM.input.innerHTML)),!t&&n&&this.dropdown.hide.bind(this),this.input.autocomplete.suggest.call(this),this.input.validate.call(this);},raw:function(){return this.DOM.input.textContent},validate:function(){var t=!this.state.inputText||true===this.validateTag({value:this.state.inputText});return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid,!t),t},normalize:function(t,e){var i=t||this.DOM.input,n=[];i.childNodes.forEach((function(t){return 3==t.nodeType&&n.push(t.nodeValue)})),n=n.join("\n");try{n=n.replace(/(?:\r\n|\r|\n)/g,this.settings.delimiters.source.charAt(0));}catch(t){}return n=n.replace(/\s/g," "),(null==e?void 0:e.trim)?this.trim(n):n},autocomplete:{suggest:function(t){if(this.settings.autoComplete.enabled){"object"!=typeof(t=t||{value:""})&&(t={value:t});var e=this.dropdown.getMappedValue(t);if("number"!=typeof e){var i=this.state.inputText.toLowerCase(),n=e.substr(0,this.state.inputText.length).toLowerCase(),s=e.substring(this.state.inputText.length);e&&this.state.inputText&&n==i?(this.DOM.input.setAttribute("data-suggest",s),this.state.inputSuggestion=t):(this.DOM.input.removeAttribute("data-suggest"),delete this.state.inputSuggestion);}}},set:function(t){var e=this.DOM.input.getAttribute("data-suggest"),i=t||(e?this.state.inputText+e:null);return !!i&&("mix"==this.settings.mode?this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix+i)):(this.input.set.call(this,i),this.setRangeAtStartEnd(false,this.DOM.input)),this.input.autocomplete.suggest.call(this),this.dropdown.hide(),true)}}},getTagIdx:function(t){return this.value.findIndex((function(e){return e.__tagId==(t||{}).__tagId}))},getNodeIndex:function(t){var e=0;if(t)for(;t=t.previousElementSibling;)e++;return e},getTagElms:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];var n="."+$$1(this.settings.classNames.tag.split(" ")).concat($$1(e)).join(".");return [].slice.call(this.DOM.scope.querySelectorAll(n))},getLastTag:function(){var t=this.settings.classNames,e=this.DOM.scope.querySelectorAll("".concat(t.tagSelector,":not(.").concat(t.tagHide,"):not([readonly])"));return e[e.length-1]},isTagDuplicate:function(t,e,i){var n=0,a=true,o=false,r=void 0;try{for(var l,d=this.value[Symbol.iterator]();!(a=(l=d.next()).done);a=!0){var c=l.value;s(this.trim(""+t),c.value,e)&&i!=c.__tagId&&n++;}}catch(t){o=true,r=t;}finally{try{a||null==d.return||d.return();}finally{if(o)throw r}}return n},getTagIndexByValue:function(t){var e=this,i=[],n=this.settings.dropdown.caseSensitive;return this.getTagElms().forEach((function(a,o){a.__tagifyTagData&&s(e.trim(a.__tagifyTagData.value),t,n)&&i.push(o);})),i},getTagElmByValue:function(t){var e=this.getTagIndexByValue(t)[0];return this.getTagElms()[e]},flashTag:function(t){var e=this;t&&(t.classList.add(this.settings.classNames.tagFlash),setTimeout((function(){t.classList.remove(e.settings.classNames.tagFlash);}),100));},isTagBlacklisted:function(t){return t=this.trim(t.toLowerCase()),this.settings.blacklist.filter((function(e){return (""+e).toLowerCase()==t})).length},isTagWhitelisted:function(t){return !!this.getWhitelistItem(t)},getWhitelistItem:function(t,e,i){e=e||"value";var n,a=this.settings;return (i=i||a.whitelist).some((function(i){var o="object"==typeof i?i[e]||i.value:i;if(s(o,t,a.dropdown.caseSensitive,a.trim))return n="object"==typeof i?i:{value:i},true})),n||"value"!=e||"value"==a.tagTextProp||(n=this.getWhitelistItem(t,a.tagTextProp,i)),n},validateTag:function(t){var e=this.settings,i="value"in t?"value":e.tagTextProp,n=this.trim(t[i]+"");return (t[i]+"").trim()?"mix"!=e.mode&&e.pattern&&J(e.pattern,RegExp)&&!e.pattern.test(n)?this.TEXTS.pattern:!e.duplicates&&this.isTagDuplicate(n,e.dropdown.caseSensitive,t.__tagId)?this.TEXTS.duplicate:this.isTagBlacklisted(n)||e.enforceWhitelist&&!this.isTagWhitelisted(n)?this.TEXTS.notAllowed:!e.validate||e.validate(t):this.TEXTS.empty},getInvalidTagAttrs:function(t,e){return {"aria-invalid":true,class:"".concat(t.class||""," ").concat(this.settings.classNames.tagNotAllowed).trim(),title:e}},hasMaxTags:function(){return this.value.length>=this.settings.maxTags&&this.TEXTS.exceed},setReadonly:function(t,e){var i=this.settings;this.DOM.scope.contains(document.activeElement)&&document.activeElement.blur(),i[e||"readonly"]=t,this.DOM.scope[(t?"set":"remove")+"Attribute"](e||"readonly",true),this.settings.userInput=true,this.setContentEditable(!t);},setContentEditable:function(t){this.DOM.scope.querySelectorAll("[data-can-editable]").forEach((function(e){e.contentEditable=t,e.tabIndex=t?0:-1;}));},setDisabled:function(t){this.setReadonly(t,"disabled");},normalizeTags:function(t){var e=this,i=this.settings,n=i.whitelist,s=i.delimiters,a=i.mode,o=i.tagTextProp,r=[],l=!!n&&J(n[0],Object),d=Array.isArray(t),g=d&&t[0].value,h=function(t){return (t+"").split(s).reduce((function(t,i){var n,s=e.trim(i);return s&&t.push((X(n={},o,s),X(n,"value",s),n)),t}),[])};if("number"==typeof t&&(t=t.toString()),"string"==typeof t){if(!t.trim())return [];t=h(t);}else d&&(t=t.reduce((function(t,i){if(c(i)){var n=u({},i);o in n||(o="value"),n[o]=e.trim(n[o]),(n[o]||0===n[o])&&t.push(n);}else if(null!=i&&""!==i&&void 0!==i){var s;(s=t).push.apply(s,$$1(h(i)));}return t}),[]));return l&&!g&&(t.forEach((function(t){var i=r.map((function(t){return t.value})),n=e.dropdown.filterListItems.call(e,t[o],{exact:true});e.settings.duplicates||(n=n.filter((function(t){return !i.includes(t.value)})));var s=n.length>1?e.getWhitelistItem(t[o],o,n):n[0];s&&J(s,Object)?r.push(s):"mix"!=a&&(null==t.value&&(t.value=t[o]),r.push(t));})),r.length&&(t=r)),t},parseMixTags:function(t){var e=this,i=this.settings,n=i.mixTagsInterpolator,s=i.duplicates,a=i.transformTag,o=i.enforceWhitelist,r=i.maxTags,l=i.tagTextProp,d=[];t=t.split(n[0]).map((function(t,i){var c,u,g,h=t.split(n[1]),p=h[0],f=d.length==r;try{if(p==+p)throw Error;u=JSON.parse(p);}catch(t){u=e.normalizeTags(p)[0]||{value:p};}if(a.call(e,u),f||!(h.length>1)||o&&!e.isTagWhitelisted(u.value)||!s&&e.isTagDuplicate(u.value)){if(t)return i?n[0]+t:t}else u[c=u[l]?l:"value"]=e.trim(u[c]),g=e.createTagElem(u),d.push(u),g.classList.add(e.settings.classNames.tagNoAnimation),h[0]=g.outerHTML,e.value.push(u);return h.join("")})).join(""),this.DOM.input.innerHTML=t,this.DOM.input.appendChild(document.createTextNode("")),this.DOM.input.normalize();var c=this.getTagElms();return c.forEach((function(t,e){return y(t,d[e])})),this.update({withoutChangeEvent:true}),O(c,this.state.hasFocus),t},replaceTextWithNode:function(t,e){if(this.state.tag||e){e=e||this.state.tag.prefix+this.state.tag.value;var i,n,s=this.state.selection||window.getSelection(),a=s.anchorNode,o=this.state.tag.delimiters?this.state.tag.delimiters.length:0;return a.splitText(s.anchorOffset-o),-1==(i=a.nodeValue.lastIndexOf(e))?true:(n=a.splitText(i),t&&a.parentNode.replaceChild(t,n),true)}},prepareNewTagNode:function(t,e){e=e||{};var i=this.settings,n=[],s={},a=Object.assign({},t,{value:t.value+""});if(t=Object.assign({},a),i.transformTag.call(this,t),t.__isValid=this.hasMaxTags()||this.validateTag(t),true!==t.__isValid){if(e.skipInvalid)return;if(u(s,this.getInvalidTagAttrs(t,t.__isValid),{__preInvalidData:a}),t.__isValid==this.TEXTS.duplicate&&this.flashTag(this.getTagElmByValue(t.value)),!i.createInvalidTags)return void n.push(t.value)}return "readonly"in t&&(t.readonly?s["aria-readonly"]=true:delete t.readonly),{tagElm:this.createTagElem(t,s),tagData:t,aggregatedInvalidInput:n}},postProcessNewTagNode:function(t,e){var i=this,n=this.settings,s=e.__isValid;s&&true===s?this.value.push(e):(this.trigger("invalid",{data:e,index:this.value.length,tag:t,message:s}),n.keepInvalidTags||setTimeout((function(){return i.removeTags(t,true)}),1e3)),this.dropdown.position();},selectTag:function(t,e){var i=this;if(!this.settings.enforceWhitelist||this.isTagWhitelisted(e.value)){this.state.actions.selectOption&&setTimeout((function(){return i.setRangeAtStartEnd(false,i.DOM.input)}));var n=this.getLastTag();return n?this.replaceTag(n,e):this.appendTag(t),this.value[0]=e,this.update(),this.trigger("add",{tag:t,data:e}),[t]}},addEmptyTag:function(t){var e=u({value:""},t||{}),i=this.createTagElem(e);y(i,e),this.appendTag(i),this.editTag(i,{skipValidation:true}),this.toggleFocusClass(true);},addTags:function(t,e,i){var n=this,s=[],a=this.settings,o=[],r=document.createDocumentFragment(),l=[];if(!t||0==t.length)return s;switch(t=this.normalizeTags(t),a.mode){case "mix":return this.addMixTags(t);case "select":e=false,this.removeAllTags();}return this.DOM.input.removeAttribute("style"),t.forEach((function(t){var e=n.prepareNewTagNode(t,{skipInvalid:i||a.skipInvalid});if(e){var d=e.tagElm;if(t=e.tagData,o=e.aggregatedInvalidInput,s.push(d),"select"==a.mode)return n.selectTag(d,t);r.appendChild(d),n.postProcessNewTagNode(d,t),l.push({tagElm:d,tagData:t});}})),this.appendTag(r),l.forEach((function(t){var e=t.tagElm,i=t.tagData;return n.trigger("add",{tag:e,index:n.getTagIdx(i),data:i})})),this.update(),t.length&&e&&(this.input.set.call(this,a.createInvalidTags?"":o.join(a._delimiters)),this.setRangeAtStartEnd(false,this.DOM.input)),this.dropdown.refilter(),s},addMixTags:function(t){var e=this;if((t=this.normalizeTags(t))[0].prefix||this.state.tag)return this.prefixedTextToTag(t[0]);var i=document.createDocumentFragment();return t.forEach((function(t){var n=e.prepareNewTagNode(t);i.appendChild(n.tagElm),e.insertAfterTag(n.tagElm),e.postProcessNewTagNode(n.tagElm,n.tagData);})),this.appendMixTags(i),i.children},appendMixTags:function(t){var e=!!this.state.selection;e?this.injectAtCaret(t):(this.DOM.input.focus(),(e=this.setStateSelection()).range.setStart(this.DOM.input,e.range.endOffset),e.range.setEnd(this.DOM.input,e.range.endOffset),this.DOM.input.appendChild(t),this.updateValueByDOMTags(),this.update());},prefixedTextToTag:function(t){var e,i,n,s=this,a=this.settings,o=null===(e=this.state.tag)||void 0===e?void 0:e.delimiters;if(t.prefix=t.prefix||this.state.tag?this.state.tag.prefix:(a.pattern.source||a.pattern)[0],n=this.prepareNewTagNode(t),i=n.tagElm,this.replaceTextWithNode(i)||this.DOM.input.appendChild(i),setTimeout((function(){return i.classList.add(s.settings.classNames.tagNoAnimation)}),300),this.update(),!o){var r=this.insertAfterTag(i)||i;setTimeout(T,0,r);}return this.state.tag=null,this.postProcessNewTagNode(i,n.tagData),i},appendTag:function(t){var e=this.DOM,i=e.input;e.scope.insertBefore(t,i);},createTagElem:function(t,e){t.__tagId=f();var i,n=u({},t,G({value:d(t.value+"")},e));return function(t){for(var e,i=document.createNodeIterator(t,NodeFilter.SHOW_TEXT,null,false);e=i.nextNode();)e.textContent.trim()||e.parentNode.removeChild(e);}(i=this.parseTemplate("tag",[n,this])),y(i,t),i},reCheckInvalidTags:function(){var t=this,e=this.settings;this.getTagElms(e.classNames.tagNotAllowed).forEach((function(i,n){var s=y(i),a=t.hasMaxTags(),o=t.validateTag(s),r=true===o&&!a;if("select"==e.mode&&t.toggleScopeValidation(o),r)return s=s.__preInvalidData?s.__preInvalidData:{value:s.value},t.replaceTag(i,s);i.title=a||o;}));},removeTags:function(t,e,i){var n,s=this,a=this.settings;if(t=t&&J(t,HTMLElement)?[t]:J(t,Array)?t:t?[t]:[this.getLastTag()].filter((function(t){return t})),n=t.reduce((function(t,e){e&&"string"==typeof e&&(e=s.getTagElmByValue(e));var i=y(e);return e&&i&&!i.readonly&&t.push({node:e,idx:s.getTagIdx(i),data:y(e,{__removed:true})}),t}),[]),i="number"==typeof i?i:this.CSSVars.tagHideTransition,"select"==a.mode&&(i=0,this.input.set.call(this)),1==n.length&&"select"!=a.mode&&n[0].node.classList.contains(a.classNames.tagNotAllowed)&&(e=true),n.length)return a.hooks.beforeRemoveTag(n,{tagify:this}).then((function(){var t=function(t){t.node.parentNode&&(t.node.parentNode.removeChild(t.node),e?a.keepInvalidTags&&this.trigger("remove",{tag:t.node,index:t.idx}):(this.trigger("remove",{tag:t.node,index:t.idx,data:t.data}),this.dropdown.refilter(),this.dropdown.position(),this.DOM.input.normalize(),a.keepInvalidTags&&this.reCheckInvalidTags()));};i&&i>10&&1==n.length?function(e){e.node.style.width=parseFloat(window.getComputedStyle(e.node).width)+"px",document.body.clientTop,e.node.classList.add(a.classNames.tagHide),setTimeout(t.bind(this),i,e);}.call(s,n[0]):n.forEach(t.bind(s)),e||(s.removeTagsFromValue(n.map((function(t){return t.node}))),s.update(),"select"==a.mode&&a.userInput&&s.setContentEditable(true));})).catch((function(t){}))},removeTagsFromDOM:function(){this.getTagElms().forEach((function(t){return t.remove()}));},removeTagsFromValue:function(t){var e=this;(t=Array.isArray(t)?t:[t]).forEach((function(t){var i=y(t),n=e.getTagIdx(i);n>-1&&e.value.splice(n,1);}));},removeAllTags:function(t){var e=this;t=t||{},this.value=[],"mix"==this.settings.mode?this.DOM.input.innerHTML="":this.removeTagsFromDOM(),this.dropdown.refilter(),this.dropdown.position(),this.state.dropdown.visible&&setTimeout((function(){e.DOM.input.focus();})),"select"==this.settings.mode&&(this.input.set.call(this),this.settings.userInput&&this.setContentEditable(true)),this.update(t);},postUpdate:function(){this.state.blockChangeEvent=false;var t,e,i=this.settings,n=i.classNames,s="mix"==i.mode?i.mixMode.integrated?this.DOM.input.textContent:this.DOM.originalInput.value.trim():this.value.length+this.input.raw.call(this).length;(this.toggleClass(n.hasMaxTags,this.value.length>=i.maxTags),this.toggleClass(n.hasNoTags,!this.value.length),this.toggleClass(n.empty,!s),"select"==i.mode)&&this.toggleScopeValidation(null===(e=this.value)||void 0===e||null===(t=e[0])||void 0===t?void 0:t.__isValid);},setOriginalInputValue:function(t){var e=this.DOM.originalInput;this.settings.mixMode.integrated||(e.value=t,e.tagifyValue=e.value,this.setPersistedData(t,"value"));},update:function(t){clearTimeout(this.debouncedUpdateTimeout),this.debouncedUpdateTimeout=setTimeout(function(){var e=this.getInputValue();this.setOriginalInputValue(e),this.settings.onChangeAfterBlur&&(t||{}).withoutChangeEvent||this.state.blockChangeEvent||this.triggerChangeEvent();this.postUpdate();}.bind(this),100),this.events.bindOriginaInputListener.call(this,100);},getInputValue:function(){var t=this.getCleanValue();return "mix"==this.settings.mode?this.getMixedTagsAsString(t):t.length?this.settings.originalInputValueFormat?this.settings.originalInputValueFormat(t):JSON.stringify(t):""},getCleanValue:function(t){return a(t||this.value,this.dataProps)},getMixedTagsAsString:function(){var t="",e=this,i=this.settings,n=i.originalInputValueFormat||JSON.stringify,s=i.mixTagsInterpolator;return function i(a){a.childNodes.forEach((function(a){if(1==a.nodeType){var r=y(a);if("BR"==a.tagName&&(t+="\r\n"),r&&m.call(e,a)){if(r.__removed)return;t+=s[0]+n(o(r,e.dataProps))+s[1];}else a.getAttribute("style")||["B","I","U"].includes(a.tagName)?t+=a.textContent:"DIV"!=a.tagName&&"P"!=a.tagName||(t+="\r\n",i(a));}else t+=a.textContent;}));}(this.DOM.input),t}},Q.prototype.removeTag=Q.prototype.removeTags;

function rollCommandToJSON(text, raw) {
    if (!text) return {};

    const flavorMatch = raw?.match(/{(.*)}$/);
    const flavor = flavorMatch ? flavorMatch[1] : null;

    // Match key="quoted string"  OR  key=unquotedValue
    const PAIR_RE = /(\w+)=("(?:[^"\\]|\\.)*"|\S+)/g;
    const result = {};
    for (const [, key, raw] of text.matchAll(PAIR_RE)) {
        let value;
        if (raw.startsWith('"') && raw.endsWith('"')) {
            // Strip the surrounding quotes, un-escape any \" sequences
            value = raw.slice(1, -1).replace(/\\"/g, '"');
        } else if (/^(true|false)$/i.test(raw)) {
            // Boolean
            value = raw.toLowerCase() === 'true';
        } else if (!Number.isNaN(Number(raw))) {
            // Numeric
            value = Number(raw);
        } else {
            // Fallback to string
            value = raw;
        }
        result[key] = value;
    }
    return Object.keys(result).length > 0 ? { result, flavor } : null;
}

const getCommandTarget = (options = {}) => {
    const { allowNull = false } = options;
    let target = game.canvas.tokens.controlled.length > 0 ? game.canvas.tokens.controlled[0].actor : null;
    if (!game.user.isGM) {
        target = game.user.character;
        if (!target && !allowNull) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noAssignedPlayerCharacter'));
            return null;
        }
    }
    if (!target && !allowNull) {
        ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noSelectedToken'));
        return null;
    }
    if (target && target.type !== 'character') {
        if (!allowNull) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.onlyUseableByPC'));
        }
        return null;
    }

    return target;
};

const setDiceSoNiceForDualityRoll = async (rollResult, advantageState, hopeFaces, fearFaces, advantageFaces) => {
    if (!game.modules.get('dice-so-nice')?.active) return;
    const diceSoNicePresets = await getDiceSoNicePresets(hopeFaces, fearFaces, advantageFaces, advantageFaces);
    rollResult.dice[0].options = diceSoNicePresets.hope;
    rollResult.dice[1].options = diceSoNicePresets.fear;
    if (rollResult.dice[2] && advantageState) {
        rollResult.dice[2].options =
            advantageState === 1 ? diceSoNicePresets.advantage : diceSoNicePresets.disadvantage;
    }
};

const chunkify = (array, chunkSize, mappingFunc) => {
    var chunkifiedArray = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        if (mappingFunc) {
            chunkifiedArray.push(mappingFunc(chunk));
        } else {
            chunkifiedArray.push(chunk);
        }
    }

    return chunkifiedArray;
};

const tagifyElement = (element, baseOptions, onChange, tagifyOptions = {}) => {
    const { maxTags } = tagifyOptions;
    const options = Array.isArray(baseOptions)
        ? baseOptions
        : Object.keys(baseOptions).map(optionKey => ({
              ...baseOptions[optionKey],
              id: optionKey
          }));

    const tagifyElement = new Q(element, {
        tagTextProp: 'name',
        enforceWhitelist: true,
        whitelist: options.map(option => {
            return {
                value: option.id,
                name: game.i18n.localize(option.label),
                src: option.src,
                description: option.description
            };
        }),
        maxTags: typeof maxTags === 'function' ? maxTags() : maxTags,
        dropdown: {
            mapValueTo: 'name',
            searchKeys: ['value'],
            enabled: 0,
            maxItems: 100,
            closeOnSelect: true,
            highlightFirst: false
        },
        templates: {
            tag(tagData) {
                return `<tag
                            contenteditable='false'
                            spellcheck='false'
                            tabIndex="${this.settings.a11y.focusableTags ? 0 : -1}"
                            class="${this.settings.classNames.tag} ${tagData.class ? tagData.class : ''}"
                            data-tooltip="${tagData.description || tagData.name}"
                            ${this.getAttributes(tagData)}> 
                    <x class="${this.settings.classNames.tagX}" role='button' aria-label='remove tag'></x>
                    <div>
                        <span class="${this.settings.classNames.tagText}">${tagData[this.settings.tagTextProp] || tagData.value}</span>
                        ${tagData.src ? `<img src="${tagData.src}"></i>` : ''}
                    </div>
                </tag>`;
            }
        }
    });

    tagifyElement.on('add', event => {
        if (event.detail.data.__isValid === 'not allowed') return;

        const input = event.detail.tagify.DOM.originalInput;
        const currentList = input.value ? JSON.parse(input.value) : [];
        onChange([...currentList, event.detail.data], { option: event.detail.data.value, removed: false }, input);
    });
    tagifyElement.on('remove', event => {
        const input = event.detail.tagify.DOM.originalInput;
        const currentList = input.value ? JSON.parse(input.value) : [];
        onChange(
            currentList.filter(x => x.value !== event.detail.data.value),
            { option: event.detail.data.value, removed: true },
            event.detail.tagify.DOM.originalInput
        );
    });
};

const getDeleteKeys = (property, innerProperty, innerPropertyDefaultValue) => {
    return Object.keys(property).reduce((acc, key) => {
        if (innerProperty) {
            if (innerPropertyDefaultValue !== undefined) {
                acc[`${key}`] = {
                    [innerProperty]: innerPropertyDefaultValue
                };
            } else {
                acc[`${key}.-=${innerProperty}`] = null;
            }
        } else {
            acc[`-=${key}`] = null;
        }

        return acc;
    }, {});
};

// Fix on Foundry native formula replacement for DH
const nativeReplaceFormulaData = Roll.replaceFormulaData;
Roll.replaceFormulaData = function (formula, data = {}, { missing, warn = false } = {}) {
    const terms = Object.keys(CONFIG.DH.GENERAL.multiplierTypes).map(type => {
        return { term: type, default: 1 };
    });
    formula = terms.reduce((a, c) => a.replaceAll(`@${c.term}`, data[c.term] ?? c.default), formula);
    return nativeReplaceFormulaData(formula, data, { missing, warn });
};

foundry.dice.terms.Die.MODIFIERS.sc = 'selfCorrecting';

/**
 * Return the configured value as result if 1 is rolled
 * Example: 6d6sc6  Roll 6d6, each result of 1 will be changed into 6
 * @param {string} modifier     The matched modifier query
 */
foundry.dice.terms.Die.prototype.selfCorrecting = function (modifier) {
    const rgx = /(?:sc)([0-9]+)/i;
    const match = modifier.match(rgx);
    if (!match) return false;
    let [target] = match.slice(1);
    target = parseInt(target);
    for (const r of this.results) {
        if (r.result === 1) {
            r.result = target;
        }
    }
};

const getDamageKey = damage => {
    return ['none', 'minor', 'major', 'severe', 'any'][damage];
};

const getDamageLabel = damage => {
    return game.i18n.localize(`DAGGERHEART.GENERAL.Damage.${getDamageKey(damage)}`);
};

const damageKeyToNumber = key => {
    return {
        none: 0,
        minor: 1,
        major: 2,
        severe: 3,
        any: 4
    }[key];
};

function constructHTMLButton({
    label,
    dataset = {},
    classes = [],
    icon = '',
    type = 'button',
    disabled = false
}) {
    const button = document.createElement('button');
    button.type = type;

    for (const [key, value] of Object.entries(dataset)) {
        button.dataset[key] = value;
    }
    button.classList.add(...classes);
    if (icon) icon = `<i class="${icon}"></i> `;
    if (disabled) button.disabled = true;
    button.innerHTML = `${icon}${label}`;

    return button;
}

const adjustDice = (dice, decrease) => {
    const diceKeys = Object.keys(diceTypes);
    const index = diceKeys.indexOf(dice);
    const newIndex = Math.min(index + 1, diceKeys.length - 1);
    return diceTypes[diceKeys[newIndex]];
};

const adjustRange = (rangeVal, decrease) => {
    const rangeKeys = Object.keys(range);
    const index = rangeKeys.indexOf(rangeVal);
    const newIndex = Math.min(index + 1, rangeKeys.length - 1);
    return range[rangeKeys[newIndex]];
};

const updateActorTokens = async (actor, update) => {
    await actor.prototypeToken.update({ ...update });

    /* Update the tokens in all scenes belonging to Actor */
    for (let token of actor.getDependentTokens()) {
        const tokenActor = token.baseActor ?? token.actor;
        if (tokenActor?.id === actor.id) {
            await token.update({
                ...update
            });
        }
    }
};

/**
 * Retrieves a Foundry document associated with the nearest ancestor element
 * that has a `data-item-uuid` attribute.
 * @param {HTMLElement} element - The DOM element to start the search from.
 * @returns {Promise<foundry.abstract.Document|null>} The resolved document, or null if not found or invalid.
 */
async function getDocFromElement(element) {
    const target = element.closest('[data-item-uuid]');
    return (await foundry.utils.fromUuid(target.dataset.itemUuid)) ?? null;
}

/**
 * Retrieves a Foundry document associated with the nearest ancestor element
 * that has a `data-item-uuid` attribute.
 * @param {HTMLElement} element - The DOM element to start the search from.
 * @returns {foundry.abstract.Document|null} The resolved document, or null if not found, invalid
 * or in embedded compendium collection.
 */
function getDocFromElementSync(element) {
    const target = element.closest('[data-item-uuid]');
    try {
        return foundry.utils.fromUuidSync(target.dataset.itemUuid) ?? null;
    } catch (_) {
        return null;
    }
}

/**
 * Adds the update diff on a linkedItem property to update.options for use
 * in _onUpdate via the updateLinkedItemApps function.
 * @param {Array} changedItems            The candidate changed list
 * @param {Array} currentItems            The current list
 * @param {object} options                Additional options which modify the update request
 */
function addLinkedItemsDiff(changedItems, currentItems, options) {
    if (changedItems) {
        const prevItems = new Set(currentItems);
        const newItems = new Set(changedItems);
        options.toLink = Array.from(
            newItems
                .difference(prevItems)
                .map(item => item?.item ?? item)
                .filter(x => (typeof x === 'object' ? x?.item : x))
        );

        options.toUnlink = Array.from(
            prevItems
                .difference(newItems)
                .map(item => item?.item?.uuid ?? item?.uuid ?? item)
                .filter(x => (typeof x === 'object' ? x?.item : x))
        );
    }
}

/**
 * Adds or removes the current Application from linked document apps
 * depending on an update diff in the linked item list.
 * @param {object} options                Additional options which modify the update requests
 * @param {object} sheet                  The application to add or remove from document apps
 */
function updateLinkedItemApps(options, sheet) {
    options.toLink?.forEach(featureUuid => {
        const doc = foundry.utils.fromUuidSync(featureUuid);
        doc.apps[sheet.id] = sheet;
    });
    options.toUnlink?.forEach(featureUuid => {
        const doc = foundry.utils.fromUuidSync(featureUuid);
        delete doc.apps[sheet.id];
    });
}

const itemAbleRollParse = (value, actor, item) => {
    if (!value) return value;

    const isItemTarget = value.toLowerCase().includes('item.@');
    const slicedValue = isItemTarget ? value.replaceAll(/item\.@/gi, '@') : value;
    const model = isItemTarget ? item : actor;

    try {
        return Roll.replaceFormulaData(slicedValue, isItemTarget || !model?.getRollData ? model : model.getRollData());
    } catch (_) {
        return '';
    }
};

const setsEqual = (a, b) => a.size === b.size && [...a].every(value => b.has(value));

function getScrollTextData(resources, resource, key) {
    const { reversed, label } = CONFIG.DH.ACTOR.scrollingTextResource[key];
    const { BOTTOM, TOP } = CONST.TEXT_ANCHOR_POINTS;
    const increased = resources[key].value < resource.value;
    const value = -1 * (resources[key].value - resource.value);

    const text = `${game.i18n.localize(label)} ${value.signedString()}`;

    const stroke = increased ? (reversed ? 0xffffff : 0x000000) : reversed ? 0x000000 : 0xffffff;
    const fill = increased ? (reversed ? 0x0032b1 : 0xffe760) : reversed ? 0xffe760 : 0x0032b1;
    const direction = increased ? (reversed ? BOTTOM : TOP) : reversed ? TOP : BOTTOM;

    return { text, stroke, fill, direction };
}

function createScrollText(actor, optionsData) {
    if (actor && optionsData?.length) {
        actor.getActiveTokens().forEach(token => {
            optionsData.forEach(data => {
                const { text, ...options } = data;
                canvas.interface.createScrollingText(token.getCenterPoint(), data.text, {
                    duration: 2000,
                    distance: token.h,
                    jitter: 0,
                    ...options
                });
            });
        });
    }
}

async function createEmbeddedItemWithEffects(actor, baseData, update) {
    const data = baseData.uuid.startsWith('Compendium') ? await foundry.utils.fromUuid(baseData.uuid) : baseData;
    const [doc] = await actor.createEmbeddedDocuments('Item', [
        {
            ...(update ?? data),
            ...baseData,
            id: data.id,
            uuid: data.uuid,
            effects: data.effects?.map(effect => effect.toObject())
        }
    ]);

    return doc;
}

async function createEmbeddedItemsWithEffects(actor, baseData) {
    const effectData = [];
    for (let d of baseData) {
        const data = d.uuid.startsWith('Compendium') ? await foundry.utils.fromUuid(d.uuid) : d;
        effectData.push({
            ...data,
            id: data.id,
            uuid: data.uuid,
            effects: data.effects?.map(effect => effect.toObject())
        });
    }

    await actor.createEmbeddedDocuments('Item', effectData);
}

const slugify = name => {
    return name.toLowerCase().replaceAll(' ', '-').replaceAll('.', '');
};

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$l, ApplicationV2: ApplicationV2$k } = foundry.applications.api;

class DhCharacterCreation extends HandlebarsApplicationMixin$l(ApplicationV2$k) {
    constructor(character) {
        super({});

        this.character = character;

        this.setup = {
            traits: this.character.system.traits,
            ancestryName: {
                primary: '',
                secondary: ''
            },
            mixedAncestry: false,
            primaryAncestry: this.character.system.ancestry ?? {},
            secondaryAncestry: {},
            community: this.character.system.community ?? {},
            class: this.character.system.class?.value ?? {},
            subclass: this.character.system.class?.subclass ?? {},
            experiences: {
                [foundry.utils.randomID()]: { name: '', value: 2, core: true },
                [foundry.utils.randomID()]: { name: '', value: 2, core: true }
            },
            domainCards: {
                [foundry.utils.randomID()]: {},
                [foundry.utils.randomID()]: {}
            },
            visibility: 1
        };

        this.equipment = {
            armor: {},
            primaryWeapon: {},
            secondaryWeapon: {},
            inventory: {
                take: {},
                choiceA: {},
                choiceB: {}
            }
        };

        this._dragDrop = this._createDragDropHandlers();

        this.itemBrowser = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.CharacterCreation.title', { actor: this.character.name });
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'character-creation'],
        position: { width: 700, height: 'auto' },
        actions: {
            viewCompendium: this.viewCompendium,
            viewItem: this.viewItem,
            useSuggestedTraits: this.useSuggestedTraits,
            equipmentChoice: this.equipmentChoice,
            setupGoNext: this.setupGoNext,
            finish: this.finish
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.ancestry-card' },
            { dragSelector: null, dropSelector: '.community-card' },
            { dragSelector: null, dropSelector: '.class-card' },
            { dragSelector: null, dropSelector: '.subclass-card' },
            { dragSelector: null, dropSelector: '.domain-card' },
            { dragSelector: null, dropSelector: '.armor-card' },
            { dragSelector: null, dropSelector: '.primary-weapon-card' },
            { dragSelector: null, dropSelector: '.secondary-weapon-card' },
            { dragSelector: '.suggestion-inner-container', dropSelector: '.selections-container' }
        ]
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/characterCreation/tabs.hbs' },
        ancestry: { template: 'systems/daggerheart/templates/characterCreation/tabs/ancestry.hbs' },
        community: { template: 'systems/daggerheart/templates/characterCreation/tabs/community.hbs' },
        class: { template: 'systems/daggerheart/templates/characterCreation/tabs/class.hbs' },
        traits: { template: 'systems/daggerheart/templates/characterCreation/tabs/traits.hbs' },
        experience: { template: 'systems/daggerheart/templates/characterCreation/tabs/experience.hbs' },
        domainCards: { template: 'systems/daggerheart/templates/characterCreation/tabs/domainCards.hbs' },
        equipment: { template: 'systems/daggerheart/templates/characterCreation/equipment.hbs' },
        // story: { template: 'systems/daggerheart/templates/characterCreation/story.hbs' },
        footer: { template: 'systems/daggerheart/templates/characterCreation/footer.hbs' }
    };

    static TABS = {
        ancestry: {
            active: true,
            cssClass: '',
            group: 'setup',
            id: 'ancestry',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.ancestry'
        },
        community: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'community',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.community'
        },
        class: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'class',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.class'
        },
        traits: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'traits',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.traits'
        },
        experience: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'experience',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.experience'
        },
        domainCards: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'domainCards',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.domainCards'
        },
        equipment: {
            active: false,
            cssClass: '',
            group: 'setup',
            id: 'equipment',
            label: 'DAGGERHEART.APPLICATIONS.CharacterCreation.tabs.equipment'
        }
    };

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group]
                ? this.tabGroups[v.group] === v.id
                : this.tabGroups.primary !== 'equipment'
                  ? v.active
                  : false;
            v.cssClass = v.active ? 'active' : '';

            switch (v.id) {
                case 'community':
                    v.disabled = this.setup.visibility < 2;
                    break;
                case 'class':
                    v.disabled = this.setup.visibility < 3;
                    break;
                case 'traits':
                    v.disabled = this.setup.visibility < 4;
                    break;
                case 'experience':
                    v.disabled = this.setup.visibility < 5;
                    break;
                case 'domainCards':
                    v.disabled = this.setup.visibility < 6;
                    break;
                case 'equipment':
                    v.disabled = this.setup.visibility < 7;
                    break;
            }
        }

        return tabs;
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        this._dragDrop.forEach(d => d.bind(htmlElement));

        htmlElement.querySelectorAll('.mixed-ancestry-slider').forEach(element => {
            element.addEventListener('input', this.mixedAncestryToggle.bind(this));
            element.addEventListener('click', this.mixedAncestryToggle.bind(this));
        });
    }

    async _prepareContext(_options) {
        this.tabGroups.setup = this.tabGroups.setup ?? 'ancestry';
        const context = await super._prepareContext(_options);

        context.tabs = this._getTabs(this.constructor.TABS);
        const availableTraitModifiers = game.settings
            .get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew)
            .traitArray.map(trait => ({ key: trait, name: trait }));
        for (let trait of Object.values(this.setup.traits).filter(x => x.value !== null)) {
            const index = availableTraitModifiers.findIndex(x => x.key === trait.value);
            if (index !== -1) {
                availableTraitModifiers.splice(index, 1);
            }
        }

        context.suggestedTraits = this.setup.class.system
            ? Object.keys(this.setup.class.system.characterGuide.suggestedTraits).map(traitKey => {
                  const trait = this.setup.class.system.characterGuide.suggestedTraits[traitKey];
                  return `${game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${traitKey}.short`)} ${trait > 0 ? `+${trait}` : trait}`;
              })
            : [];
        context.traits = {
            values: Object.keys(this.setup.traits).map(traitKey => {
                const trait = this.setup.traits[traitKey];
                const options = [...availableTraitModifiers];
                if (trait.value !== null && !options.some(x => x.key === trait.value))
                    options.push({ key: trait.value, name: trait.value });

                return {
                    ...trait,
                    key: traitKey,
                    name: game.i18n.localize(abilities[traitKey].label),
                    options: options
                };
            })
        };
        context.traits.nrTotal = Object.keys(context.traits.values).length;
        context.traits.nrSelected = this.getNrSelectedTrait();

        context.experience = {
            values: this.setup.experiences,
            nrTotal: Object.keys(this.setup.experiences).length,
            nrSelected: Object.values(this.setup.experiences).reduce((acc, exp) => acc + (exp.name ? 1 : 0), 0)
        };

        context.mixedAncestry = Number(this.setup.mixedAncestry);

        const { primary, secondary, overwrite } = this.setup.ancestryName;
        context.ancestryName = overwrite ?? (primary && secondary ? `${primary}/${secondary}` : primary);
        context.primaryAncestry = { ...this.setup.primaryAncestry, compendium: 'ancestries' };
        context.secondaryAncestry = { ...this.setup.secondaryAncestry, compendium: 'ancestries' };
        context.community = { ...this.setup.community, compendium: 'communities' };
        context.class = { ...this.setup.class, compendium: 'classes' };
        context.subclass = { ...this.setup.subclass, compendium: 'subclasses' };

        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        context.classDomains = context.class.uuid
            ? context.class.system.domains.map(key => game.i18n.localize(allDomainData[key].label))
            : [];
        context.domainCards = Object.keys(this.setup.domainCards).reduce((acc, x) => {
            acc[x] = { ...this.setup.domainCards[x], compendium: 'domains' };
            return acc;
        }, {});

        context.visibility = this.setup.visibility;

        return context;
    }

    async _preparePartContext(partId, context) {
        switch (partId) {
            case 'footer':
                context.isLastTab = this.tabGroups.setup === 'equipment';
                switch (this.tabGroups.setup) {
                    case null:
                    case 'ancestry':
                        context.nextDisabled = this.setup.visibility === 1;
                        break;
                    case 'community':
                        context.nextDisabled = this.setup.visibility === 2;
                        break;
                    case 'class':
                        context.nextDisabled = this.setup.visibility === 3;
                        break;
                    case 'traits':
                        context.nextDisabled = this.setup.visibility === 4;
                        break;
                    case 'experience':
                        context.nextDisabled = this.setup.visibility === 5;
                        break;
                    case 'domainCards':
                        context.nextDisabled = this.setup.visibility === 6;
                        break;
                }

                break;
            case 'equipment':
                const suggestions = await this.getEquipmentSuggestions(
                    this.equipment.inventory.choiceA,
                    this.equipment.inventory.choiceB
                );
                context.armor = {
                    ...this.equipment.armor,
                    suggestion: {
                        ...suggestions.armor,
                        uuid: suggestions.armor?.uuid,
                        taken: suggestions.armor?.uuid === this.equipment.armor?.uuid
                    },
                    compendium: 'armor'
                };
                context.primaryWeapon = {
                    ...this.equipment.primaryWeapon,
                    suggestion: {
                        ...suggestions.primaryWeapon,
                        uuid: suggestions.primaryWeapon?.uuid,
                        taken: suggestions.primaryWeapon?.uuid === this.equipment.primaryWeapon?.uuid
                    },
                    compendium: 'weapon'
                };
                context.secondaryWeapon = {
                    ...this.equipment.secondaryWeapon,
                    suggestion: {
                        ...suggestions.secondaryWeapon,
                        uuid: suggestions.secondaryWeapon?.uuid,
                        taken: suggestions.secondaryWeapon?.uuid === this.equipment.secondaryWeapon?.uuid
                    },
                    disabled: this.equipment.primaryWeapon?.system?.burden === burden.twoHanded.value,
                    compendium: 'weapon'
                };
                context.inventory = {
                    take: suggestions.inventory.take,
                    choiceA: { suggestions: suggestions.inventory.choiceA, compendium: 'consumables' },
                    choiceB: { suggestions: suggestions.inventory.choiceB, compendium: 'general-items' }
                };
                context.noInventoryChoices =
                    suggestions.inventory.take.length === 0 &&
                    suggestions.inventory.choiceA?.length === 0 &&
                    suggestions.inventory.choiceB?.length === 0;

                break;
        }

        return context;
    }

    static async updateForm(event, _, formData) {
        this.setup = foundry.utils.mergeObject(this.setup, formData.object);

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }

    mixedAncestryToggle(event) {
        event.preventDefault();
        event.stopPropagation();
        this.setup.mixedAncestry = !this.setup.mixedAncestry;
        if (!this.setup.mixedAncestry) this.setup.secondaryAncestry = {};

        this.render();
    }

    getUpdateVisibility() {
        switch (this.setup.visibility) {
            case 7:
                return 7;
            case 6:
                return Object.values(this.setup.domainCards).every(x => x.uuid) ? 7 : 6;
            case 5:
                return Object.values(this.setup.experiences).every(x => x.name) ? 6 : 5;
            case 4:
                return this.getNrSelectedTrait() === 6 ? 5 : 4;
            case 3:
                return this.setup.class.uuid && this.setup.subclass.uuid ? 4 : 3;
            case 2:
                return this.setup.community.uuid ? 3 : 2;
            case 1:
                return this.setup.primaryAncestry.uuid ? 2 : 1;
        }
    }

    getNrSelectedTrait() {
        const traitCompareArray = [
            ...game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).traitArray
        ];
        return Object.values(this.setup.traits).reduce((acc, x) => {
            const index = traitCompareArray.indexOf(x.value);
            traitCompareArray.splice(index, 1);
            acc += index !== -1;
            return acc;
        }, 0);
    }

    async getEquipmentSuggestions(choiceA, choiceB) {
        if (!this.setup.class.uuid) return { inventory: { take: [] } };

        const { inventory, characterGuide } = this.setup.class.system;
        return {
            armor: characterGuide.suggestedArmor ?? null,
            primaryWeapon: characterGuide.suggestedPrimaryWeapon ?? null,
            secondaryWeapon: characterGuide.suggestedSecondaryWeapon
                ? { ...characterGuide.suggestedSecondaryWeapon, uuid: characterGuide.suggestedSecondaryWeapon.uuid }
                : null,
            inventory: {
                take: inventory.take?.filter(x => x) ?? [],
                choiceA:
                    inventory.choiceA
                        ?.filter(x => x)
                        .map(x => ({ ...x, uuid: x.uuid, selected: x.uuid === choiceA?.uuid })) ?? [],
                choiceB:
                    inventory.choiceB
                        ?.filter(x => x)
                        .map(x => ({ ...x, uuid: x.uuid, selected: x.uuid === choiceB?.uuid })) ?? []
            }
        };
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                dragstart: this._onDragStart.bind(this),
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    static async viewCompendium(event, target) {
        const type = target.dataset.compendium ?? target.dataset.type,
            equipment = ['armor', 'weapon'];

        const presets = {
            compendium: 'daggerheart',
            folder: equipment.includes(type) ? 'equipments' : type,
            render: {
                noFolder: true
            }
        };

        if (type === 'domains')
            presets.filter = {
                'level.max': { key: 'level.max', value: 1 },
                'system.domain': { key: 'system.domain', value: this.setup.class?.system.domains ?? null }
            };

        if (type === 'subclasses')
            presets.filter = {
                'system.linkedClass.uuid': { key: 'system.linkedClass.uuid', value: this.setup.class?.uuid }
            };
        
        if (equipment.includes(type))
            presets.filter = {
                'system.tier': { key: 'system.tier', value: 1 },
                'type': { key: 'type', value: type }
            };

        return (this.itemBrowser = await new ItemBrowser({ presets }).render({ force: true }));
    }

    static async viewItem(_, target) {
        (await foundry.utils.fromUuid(target.dataset.uuid)).sheet.render(true);
    }

    static useSuggestedTraits() {
        this.setup.traits = Object.keys(this.setup.traits).reduce((acc, traitKey) => {
            acc[traitKey] = {
                ...this.setup.traits[traitKey],
                value: this.setup.class.system.characterGuide.suggestedTraits[traitKey]
            };
            return acc;
        }, {});

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }

    static async equipmentChoice(_, target) {
        this.equipment.inventory[target.dataset.path] = await foundry.utils.fromUuid(target.dataset.uuid);
        this.render();
    }

    static setupGoNext() {
        switch (this.setup.visibility) {
            case 2:
                this.tabGroups.setup = 'community';
                break;
            case 3:
                this.tabGroups.setup = 'class';
                break;
            case 4:
                this.tabGroups.setup = 'traits';
                break;
            case 5:
                this.tabGroups.setup = 'experience';
                break;
            case 6:
                this.tabGroups.setup = 'domainCards';
                break;
            case 7:
                this.tabGroups.setup = 'equipment';
                break;
        }

        this.render();
    }

    static async finish(_, button) {
        button.disabled = true;

        const primaryAncestryFeature = this.setup.primaryAncestry.system.primaryFeature;
        const secondaryAncestryFeature = this.setup.secondaryAncestry?.uuid
            ? this.setup.secondaryAncestry.system.secondaryFeature
            : this.setup.primaryAncestry.system.secondaryFeature;

        const { primary, secondary, overwrite } = this.setup.ancestryName;
        const ancestry = {
            ...this.setup.primaryAncestry,
            name: overwrite ?? (primary && secondary ? `${primary}/${secondary}` : primary),
            system: {
                ...this.setup.primaryAncestry.system,
                features: [
                    { type: 'primary', item: primaryAncestryFeature.uuid },
                    { type: 'secondary', item: secondaryAncestryFeature.uuid }
                ]
            }
        };

        await createEmbeddedItemWithEffects(this.character, ancestry);
        await createEmbeddedItemWithEffects(this.character, this.setup.community);
        await createEmbeddedItemWithEffects(this.character, this.setup.class);
        await createEmbeddedItemWithEffects(this.character, this.setup.subclass);
        await createEmbeddedItemsWithEffects(this.character, Object.values(this.setup.domainCards));

        if (this.equipment.armor.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.armor, {
                ...this.equipment.armor,
                system: { ...this.equipment.armor.system, equipped: true }
            });
        if (this.equipment.primaryWeapon.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.primaryWeapon, {
                ...this.equipment.primaryWeapon,
                system: { ...this.equipment.primaryWeapon.system, equipped: true }
            });
        if (this.equipment.secondaryWeapon.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.secondaryWeapon, {
                ...this.equipment.secondaryWeapon,
                system: { ...this.equipment.secondaryWeapon.system, equipped: true }
            });
        if (this.equipment.inventory.choiceA.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.inventory.choiceA);
        if (this.equipment.inventory.choiceB.uuid)
            await createEmbeddedItemWithEffects(this.character, this.equipment.inventory.choiceB);

        await createEmbeddedItemsWithEffects(
            this.character,
            this.setup.class.system.inventory.take.filter(x => x)
        );

        await this.character.update(
            {
                system: {
                    traits: this.setup.traits,
                    experiences: {
                        ...this.setup.experiences,
                        ...Object.keys(this.character.system.experiences).reduce((acc, key) => {
                            acc[`-=${key}`] = null;
                            return acc;
                        }, {})
                    }
                }
            },
            { overwrite: true }
        );

        if (this.itemBrowser) this.itemBrowser.close();
        this.close();
    }

    async _onDragStart(event) {
        const target = event.currentTarget;

        event.dataTransfer.setData('text/plain', JSON.stringify(target.dataset));
        event.dataTransfer.setDragImage(target, 60, 0);
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        const item = await foundry.utils.fromUuid(data.uuid);
        if (item.type === 'ancestry' && event.target.closest('.primary-ancestry-card')) {
            this.setup.ancestryName.primary = item.name;
            this.setup.primaryAncestry = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'ancestry' && event.target.closest('.secondary-ancestry-card')) {
            this.setup.ancestryName.secondary = item.name;
            this.setup.secondaryAncestry = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'community' && event.target.closest('.community-card')) {
            this.setup.community = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'class' && event.target.closest('.class-card')) {
            this.setup.class = { ...item, effects: Array.from(item.effects).map(x => x.toObject()), uuid: item.uuid };
            this.setup.subclass = {};
            this.setup.domainCards = {
                [foundry.utils.randomID()]: {},
                [foundry.utils.randomID()]: {}
            };
        } else if (item.type === 'subclass' && event.target.closest('.subclass-card')) {
            if (this.setup.class.system.subclasses.every(subclass => subclass.uuid !== item.uuid)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInClass'));
                return;
            }

            this.setup.subclass = {
                ...item,
                effects: Array.from(item.effects).map(x => x.toObject()),
                uuid: item.uuid
            };
        } else if (item.type === 'domainCard' && event.target.closest('.domain-card')) {
            if (!this.setup.class.uuid) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClass'));
                return;
            }

            if (!this.setup.class.system.domains.includes(item.system.domain)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.wrongDomain'));
                return;
            }

            if (item.system.level > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.cardTooHighLevel'));
                return;
            }

            if (Object.values(this.setup.domainCards).some(card => card.uuid === item.uuid)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.duplicateCard'));
                return;
            }

            this.setup.domainCards[event.target.closest('.domain-card').dataset.card] = { ...item, uuid: item.uuid };
        } else if (item.type === 'armor' && event.target.closest('.armor-card')) {
            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            this.equipment.armor = { ...item, uuid: item.uuid };
        } else if (item.type === 'weapon' && event.target.closest('.primary-weapon-card')) {
            if (item.system.secondary) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.notPrimary'));
                return;
            }

            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            if (item.system.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                this.equipment.secondaryWeapon = {};
            }

            this.equipment.primaryWeapon = { ...item, uuid: item.uuid };
        } else if (item.type === 'weapon' && event.target.closest('.secondary-weapon-card')) {
            if (this.equipment.primaryWeapon?.system?.burden === burden.twoHanded.value) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.primaryIsTwoHanded'));
                return;
            }

            if (!item.system.secondary) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.notSecondary'));
                return;
            }

            if (item.system.tier > 1) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.itemTooHighTier'));
                return;
            }

            this.equipment.secondaryWeapon = { ...item, uuid: item.uuid };
        } else {
            return;
        }

        this.setup.visibility = this.getUpdateVisibility();
        this.render();
    }
}

var _module$f = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CharacterCreation: DhCharacterCreation
});

const { ApplicationV2: ApplicationV2$j, HandlebarsApplicationMixin: HandlebarsApplicationMixin$k } = foundry.applications.api;

class BeastformDialog extends HandlebarsApplicationMixin$k(ApplicationV2$j) {
    constructor(configData, item) {
        super();

        this.item = item;

        this.configData = configData;
        this.selected = null;
        this.evolved = { form: null };
        this.hybrid = { forms: {}, advantages: {}, features: {} };

        this._dragDrop = this._createDragDropHandlers();
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dialog', 'dh-style', 'beastform-selection'],
        position: {
            width: 600,
            height: 'auto'
        },
        window: {
            icon: 'fa-solid fa-paw'
        },
        actions: {
            selectBeastform: this.selectBeastform,
            toggleHybridFeature: this.toggleHybridFeature,
            toggleHybridAdvantage: this.toggleHybridAdvantage,
            submitBeastform: this.submitBeastform
        },
        form: {
            handler: this.updateBeastform,
            submitOnChange: true,
            submitOnClose: false
        },
        dragDrop: [{ dragSelector: '.beastform-container', dropSelector: '.advanced-form-container' }]
    };

    get title() {
        return this.item.name;
    }

    /** @override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/dialogs/beastform/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/dialogs/beastform/tabs.hbs' },
        beastformTier: { template: 'systems/daggerheart/templates/dialogs/beastform/beastformTier.hbs' },
        advanced: { template: 'systems/daggerheart/templates/dialogs/beastform/advanced.hbs' },
        footer: { template: 'systems/daggerheart/templates/dialogs/beastform/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: '1' }, { id: '2' }, { id: '3' }, { id: '4' }],
            initial: '1',
            labelPrefix: 'DAGGERHEART.GENERAL.Tiers'
        }
    };

    changeTab(tab, group, options) {
        super.changeTab(tab, group, options);

        this.render();
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                dragstart: this._onDragStart.bind(this),
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        this._dragDrop.forEach(d => d.bind(htmlElement));
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.selected = this.selected;
        context.selectedBeastformEffect = this.selected?.effects?.find?.(x => x.type === 'beastform');

        context.evolved = this.evolved;

        context.hybridForms = Object.keys(this.hybrid.forms).reduce((acc, formKey) => {
            if (!this.hybrid.forms[formKey]) {
                acc[formKey] = null;
            } else {
                const data = this.hybrid.forms[formKey].toObject();
                acc[formKey] = {
                    ...data,
                    system: {
                        ...data.system,
                        features: this.hybrid.forms[formKey].system.features.map(feature => ({
                            ...feature.toObject(),
                            uuid: feature.uuid,
                            selected: Boolean(this.hybrid.features?.[formKey]?.[feature.uuid])
                        })),
                        advantageOn: Object.keys(data.system.advantageOn).reduce((acc, key) => {
                            acc[key] = {
                                ...data.system.advantageOn[key],
                                selected: Boolean(this.hybrid.advantages?.[formKey]?.[key])
                            };
                            return acc;
                        }, {})
                    }
                };
            }
            return acc;
        }, {});

        const maximumDragTier = Math.max(
            this.selected?.system?.evolved?.maximumTier ?? 0,
            this.selected?.system?.hybrid?.maximumTier ?? 0
        );

        const compendiumBeastforms = await game.packs.get(`daggerheart.beastforms`)?.getDocuments();
        const beastformTiers = [...game.items, ...(compendiumBeastforms ? compendiumBeastforms : [])].reduce(
            (acc, x) => {
                const tier = CONFIG.DH.GENERAL.tiers[x.system.tier];
                if (x.type !== 'beastform' || tier.id > this.configData.tierLimit) return acc;

                if (!acc[tier.id]) acc[tier.id] = { label: game.i18n.localize(tier.label), values: {} };

                if (Object.values(acc[tier.id].values).find(existing => existing.value.name === x.name)) return acc;

                acc[tier.id].values[x.uuid] = {
                    selected: this.selected?.uuid == x.uuid,
                    value: x,
                    draggable:
                        !['evolved', 'hybrid'].includes(x.system.beastformType) && maximumDragTier
                            ? x.system.tier <= maximumDragTier
                            : false
                };

                return acc;
            },
            {}
        );

        context.tier = beastformTiers[this.tabGroups.primary];
        context.tierKey = this.tabGroups.primary;

        context.canSubmit = this.canSubmit();

        return context;
    }

    canSubmit() {
        if (this.selected) {
            switch (this.selected.system.beastformType) {
                case 'normal':
                    return true;
                case 'evolved':
                    return this.evolved.form;
                case 'hybrid':
                    const selectedAdvantages = Object.values(this.hybrid.advantages).reduce(
                        (acc, form) => acc + Object.values(form).length,
                        0
                    );
                    const selectedFeatures = Object.values(this.hybrid.features).reduce(
                        (acc, form) => acc + Object.values(form).length,
                        0
                    );

                    const advantagesSelected = selectedAdvantages === this.selected.system.hybrid.advantages;
                    const featuresSelected = selectedFeatures === this.selected.system.hybrid.features;
                    return advantagesSelected && featuresSelected;
            }
        }

        return false;
    }

    static updateBeastform(event, _, formData) {
        this.selected = foundry.utils.mergeObject(this.selected, formData.object);

        this.render();
    }

    static async selectBeastform(_, target) {
        this.element.querySelectorAll('.beastform-container ').forEach(element => {
            if (element.dataset.uuid === target.dataset.uuid && this.selected?.uuid !== target.dataset.uuid) {
                element.classList.remove('inactive');
            } else {
                element.classList.add('inactive');
            }
        });

        const uuid = this.selected?.uuid === target.dataset.uuid ? null : target.dataset.uuid;
        this.selected = uuid ? await foundry.utils.fromUuid(uuid) : null;

        if (this.selected) {
            if (this.selected.system.beastformType !== 'evolved') this.evolved.form = null;
            if (this.selected.system.beastformType !== 'hybrid') {
                this.hybrid.forms = {};
                this.hybrid.advantages = {};
                this.hybrid.features = {};
            } else {
                this.hybrid.forms = [...Array(this.selected.system.hybrid.beastformOptions).keys()].reduce((acc, _) => {
                    acc[foundry.utils.randomID()] = null;
                    return acc;
                }, {});
            }
        }

        this.render();
    }

    static toggleHybridFeature(_, button) {
        const current = this.hybrid.features[button.dataset.form];
        if (!current) this.hybrid.features[button.dataset.form] = {};

        if (this.hybrid.features[button.dataset.form][button.id])
            delete this.hybrid.features[button.dataset.form][button.id];
        else {
            const currentFeatures = Object.values(this.hybrid.features).reduce(
                (acc, form) => acc + Object.values(form).length,
                0
            );
            if (currentFeatures === this.selected.system.hybrid.features) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformToManyFeatures'));
                return;
            }

            const feature = this.hybrid.forms[button.dataset.form].system.features.find(x => x.uuid === button.id);
            this.hybrid.features[button.dataset.form][button.id] = feature;
        }

        this.render();
    }

    static toggleHybridAdvantage(_, button) {
        const current = this.hybrid.advantages[button.dataset.form];
        if (!current) this.hybrid.advantages[button.dataset.form] = {};

        if (this.hybrid.advantages[button.dataset.form][button.id])
            delete this.hybrid.advantages[button.dataset.form][button.id];
        else {
            const currentAdvantages = Object.values(this.hybrid.advantages).reduce(
                (acc, form) => acc + Object.values(form).length,
                0
            );
            if (currentAdvantages === this.selected.system.hybrid.advantages) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformToManyAdvantages'));
                return;
            }

            const advantage = this.hybrid.forms[button.dataset.form].system.advantageOn[button.id];
            this.hybrid.advantages[button.dataset.form][button.id] = advantage;
        }

        this.render();
    }

    static async submitBeastform() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.selected = null;
    }

    static async configure(configData, item) {
        return new Promise(resolve => {
            const app = new this(configData, item);
            const featureItem = item;
            app.addEventListener(
                'close',
                () => resolve({ selected: app.selected, evolved: app.evolved, hybrid: app.hybrid, item: featureItem }),
                { once: true }
            );
            app.render({ force: true });
        });
    }

    async _onDragStart(event) {
        const target = event.currentTarget;
        const abort = () => event.preventDefault();
        if (!this.selected) abort();

        const draggedForm = await foundry.utils.fromUuid(target.dataset.uuid);
        if (['evolved', 'hybrid'].includes(draggedForm.system.beastformType)) abort();

        if (this.selected.system.beastformType === 'evolved') {
            if (draggedForm.system.tier > this.selected.system.evolved.maximumTier) abort();
        }
        if (this.selected.system.beastformType === 'hybrid') {
            if (draggedForm.system.tier > this.selected.system.hybrid.maximumTier) abort();
        }

        event.dataTransfer.setData('text/plain', JSON.stringify(target.dataset));
        event.dataTransfer.setDragImage(target, 60, 0);
    }

    async _onDrop(event) {
        event.stopPropagation();
        const data = foundry.applications.ux.TextEditor.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        if (!item) return;

        if (event.target.closest('.advanced-form-container.evolved')) {
            this.evolved.form = item;
        } else {
            const hybridContainer = event.target.closest('.advanced-form-container.hybridized');
            if (hybridContainer) {
                const existingId = Object.keys(this.hybrid.forms).find(
                    key => this.hybrid.forms[key]?.uuid === item.uuid
                );
                if (existingId) this.hybrid.forms[existingId] = null;

                this.hybrid.forms[hybridContainer.id] = item;
            }
        }

        this.render();
    }
}

const { ApplicationV2: ApplicationV2$i, HandlebarsApplicationMixin: HandlebarsApplicationMixin$j } = foundry.applications.api;

class D20RollDialog extends HandlebarsApplicationMixin$j(ApplicationV2$i) {
    constructor(roll, config = {}, options = {}) {
        super(options);

        this.roll = roll;
        this.config = config;
        this.config.experiences = [];
        this.reactionOverride = config.roll?.type === 'reaction';

        if (config.source?.action) {
            this.item = config.data.parent.items.get(config.source.item) ?? config.data.parent;
            this.action =
                config.data.attack?._id == config.source.action
                    ? config.data.attack
                    : this.item.system.actions.get(config.source.action);
        }
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'roll-selection',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'roll-selection'],
        position: {
            width: 'auto'
        },
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            updateIsAdvantage: this.updateIsAdvantage,
            selectExperience: this.selectExperience,
            toggleReaction: this.toggleReaction,
            submitRoll: this.submitRoll
        },
        form: {
            handler: this.updateRollConfiguration,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    get title() {
        return this.config.title;
    }

    get actor() {
        return this.config?.data?.parent;
    }

    /** @override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/header.hbs'
        },
        rollSelection: {
            id: 'rollSelection',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/rollSelection.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.rollConfig = this.config;
        context.hasRoll = !!this.config.roll;
        context.canRoll = true;
        context.selectedRollMode = this.config.selectedRollMode;
        context.rollModes = Object.entries(CONFIG.Dice.rollModes).map(([action, { label, icon }]) => ({
            action,
            label,
            icon
        }));

        this.config.costs ??= [];
        if (this.config.costs?.length) {
            const updatedCosts = game.system.api.fields.ActionFields.CostField.calcCosts.call(
                this.action ?? { actor: this.actor },
                this.config.costs
            );
            context.costs = updatedCosts.map(x => ({
                ...x,
                label: x.keyIsID
                    ? this.action.parent.parent.name
                    : game.i18n.localize(CONFIG.DH.GENERAL.abilityCosts[x.key].label)
            }));
            context.canRoll = game.system.api.fields.ActionFields.CostField.hasCost.call(
                this.action ?? { actor: this.actor },
                updatedCosts
            );
            this.config.data.scale = this.config.costs[0].total;
        }
        if (this.config.uses?.max) {
            context.uses = game.system.api.fields.ActionFields.UsesField.calcUses.call(this.action, this.config.uses);
            context.canRoll =
                context.canRoll &&
                game.system.api.fields.ActionFields.UsesField.hasUses.call(this.action, context.uses);
        }
        if (this.roll) {
            context.roll = this.roll;
            context.rollType = this.roll?.constructor.name;
            context.rallyDie = this.roll.rallyChoices;
            const experiences = this.config.data?.experiences || {};
            context.experiences = Object.keys(experiences).map(id => ({
                id,
                ...experiences[id]
            }));
            context.selectedExperiences = this.config.experiences;
            context.advantage = this.config.roll?.advantage;
            context.disadvantage = this.config.roll?.disadvantage;
            context.diceOptions = CONFIG.DH.GENERAL.diceTypes;
            context.isLite = this.config.roll?.lite;
            context.extraFormula = this.config.extraFormula;
            context.formula = this.roll.constructFormula(this.config);

            context.showReaction = !context.rollConfig.type && context.rollType === 'DualityRoll';
            context.reactionOverride = this.reactionOverride;
        }
        return context;
    }

    static updateRollConfiguration(event, _, formData) {
        const { ...rest } = foundry.utils.expandObject(formData.object);
        this.config.selectedRollMode = rest.selectedRollMode;

        if (this.config.costs) {
            this.config.costs = foundry.utils.mergeObject(this.config.costs, rest.costs);
        }
        if (this.config.uses) this.config.uses = foundry.utils.mergeObject(this.config.uses, rest.uses);
        if (rest.roll?.dice) {
            Object.entries(rest.roll.dice).forEach(([key, value]) => {
                this.roll[key] = value;
            });
        }
        this.config.extraFormula = rest.extraFormula;
        this.render();
    }

    static updateIsAdvantage(_, button) {
        const advantage = Number(button.dataset.advantage);
        this.advantage = advantage === 1;
        this.disadvantage = advantage === -1;

        this.config.roll.advantage = this.config.roll.advantage === advantage ? 0 : advantage;
        this.render();
    }

    static selectExperience(_, button) {
        this.config.experiences =
            this.config.experiences.indexOf(button.dataset.key) > -1
                ? this.config.experiences.filter(x => x !== button.dataset.key)
                : [...this.config.experiences, button.dataset.key];
        if (this.config?.data?.parent?.type === 'character' || this.config?.data?.parent?.type === 'companion') {
            this.config.costs =
                this.config.costs.indexOf(this.config.costs.find(c => c.extKey === button.dataset.key)) > -1
                    ? this.config.costs.filter(x => x.extKey !== button.dataset.key)
                    : [
                          ...this.config.costs,
                          {
                              extKey: button.dataset.key,
                              key: 'hope',
                              value: 1,
                              name: this.config.data?.experiences?.[button.dataset.key]?.name
                          }
                      ];
        }
        this.render();
    }

    static toggleReaction() {
        if (this.config.roll) {
            this.reactionOverride = !this.reactionOverride;
            this.config.roll.type = this.reactionOverride
                ? CONFIG.DH.ITEM.actionTypes.reaction.id
                : this.config.roll.type === CONFIG.DH.ITEM.actionTypes.reaction.id
                  ? null
                  : this.config.roll.type;
            this.render();
        }
    }

    static async submitRoll() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.config = false;
    }

    static async configure(roll, config = {}, options = {}) {
        return new Promise(resolve => {
            const app = new this(roll, config, options);
            app.addEventListener('close', () => resolve(app.config), { once: true });
            app.render({ force: true });
        });
    }
}

const { ApplicationV2: ApplicationV2$h, HandlebarsApplicationMixin: HandlebarsApplicationMixin$i } = foundry.applications.api;

class DamageDialog extends HandlebarsApplicationMixin$i(ApplicationV2$h) {
    constructor(roll, config = {}, options = {}) {
        super(options);

        this.roll = roll;
        this.config = config;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'roll-selection',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'damage-selection'],
        position: {
            width: 400,
            height: 'auto'
        },
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            submitRoll: this.submitRoll
        },
        form: {
            handler: this.updateRollConfiguration,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    /** @override */
    static PARTS = {
        damageSelection: {
            id: 'damageSelection',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/damageSelection.hbs'
        }
    };

    get title() {
        return game.i18n.localize(
            `DAGGERHEART.EFFECTS.ApplyLocations.${this.config.hasHealing ? 'healing' : 'damage'}Roll.name`
        );
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.config = CONFIG.DH;
        context.title = this.config.title ?? this.title;
        context.formula = this.roll.constructFormula(this.config);
        context.hasHealing = this.config.hasHealing;
        context.directDamage = this.config.directDamage;
        context.selectedRollMode = this.config.selectedRollMode;
        context.rollModes = Object.entries(CONFIG.Dice.rollModes).map(([action, { label, icon }]) => ({
            action,
            label,
            icon
        }));
        context.modifiers = this.config.modifiers;
        return context;
    }

    static updateRollConfiguration(_event, _, formData) {
        const { ...rest } = foundry.utils.expandObject(formData.object);
        foundry.utils.mergeObject(this.config.roll, rest.roll);
        foundry.utils.mergeObject(this.config.modifiers, rest.modifiers);
        this.config.selectedRollMode = rest.selectedRollMode;

        this.render();
    }

    static async submitRoll() {
        await this.close({ submitted: true });
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.config = false;
    }

    static async configure(roll, config = {}) {
        return new Promise(resolve => {
            const app = new this(roll, config);
            app.addEventListener('close', () => resolve(app.config), { once: true });
            app.render({ force: true });
        });
    }
}

const { ApplicationV2: ApplicationV2$g, HandlebarsApplicationMixin: HandlebarsApplicationMixin$h } = foundry.applications.api;

class DamageReductionDialog extends HandlebarsApplicationMixin$h(ApplicationV2$g) {
    constructor(resolve, reject, actor, damage, damageType) {
        super({});

        this.resolve = resolve;
        this.reject = reject;
        this.actor = actor;
        this.damage = damage;
        this.rulesDefault = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.Automation
        ).damageReductionRulesDefault;

        this.rulesOn = [CONFIG.DH.GENERAL.ruleChoice.on.id, CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id].includes(
            this.rulesDefault
        );

        const canApplyArmor = damageType.every(t => actor.system.armorApplicableDamageTypes[t] === true);
        const availableArmor = actor.system.armorScore - actor.system.armor.system.marks.value;
        const maxArmorMarks = canApplyArmor ? availableArmor : 0;

        const armor = [...Array(maxArmorMarks).keys()].reduce((acc, _) => {
            acc[foundry.utils.randomID()] = { selected: false };
            return acc;
        }, {});
        const stress = [...Array(actor.system.rules.damageReduction.maxArmorMarked.stressExtra ?? 0).keys()].reduce(
            (acc, _) => {
                acc[foundry.utils.randomID()] = { selected: false };
                return acc;
            },
            {}
        );
        this.marks = { armor, stress };

        this.availableStressReductions = Object.keys(actor.system.rules.damageReduction.stressDamageReduction).reduce(
            (acc, key) => {
                const dr = actor.system.rules.damageReduction.stressDamageReduction[key];
                if (dr.cost) {
                    if (acc === null) acc = {};

                    const damage = damageKeyToNumber(key);
                    acc[damage] = {
                        cost: dr.cost,
                        selected: false,
                        any: key === 'any',
                        from: getDamageLabel(damage),
                        to: getDamageLabel(damage - 1)
                    };
                }

                return acc;
            },
            null
        );

        this.thresholdImmunities = Object.keys(actor.system.rules.damageReduction.thresholdImmunities).reduce(
            (acc, key) => {
                if (actor.system.rules.damageReduction.thresholdImmunities[key])
                    acc[damageKeyToNumber(key)] = game.i18n.format(`DAGGERHEART.GENERAL.DamageThresholds.with`, {
                        threshold: game.i18n.localize(`DAGGERHEART.GENERAL.DamageThresholds.${key}`)
                    });
                return acc;
            },
            {}
        );
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'damage-reduction'],
        position: {
            width: 280,
            height: 'auto'
        },
        actions: {
            toggleRules: this.toggleRules,
            setMarks: this.setMarks,
            useStressReduction: this.useStressReduction,
            takeDamage: this.takeDamage
        },
        form: {
            handler: this.updateData,
            submitOnChange: true,
            closeOnSubmit: false
        }
    };

    /** @override */
    static PARTS = {
        damageSelection: {
            id: 'damageReduction',
            template: 'systems/daggerheart/templates/dialogs/damageReduction.hbs'
        }
    };

    /* -------------------------------------------- */

    /** @inheritDoc */
    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.DamageReduction.title');
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.rulesOn = this.rulesOn;
        context.rulesToggleable = [
            CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id,
            CONFIG.DH.GENERAL.ruleChoice.offWithToggle.id
        ].includes(this.rulesDefault);
        context.thresholdImmunities = this.thresholdImmunities;

        const { selectedArmorMarks, selectedStressMarks, stressReductions, currentMarks, currentDamage } =
            this.getDamageInfo();

        context.armorScore = this.actor.system.armorScore;
        context.armorMarks = currentMarks;
        context.basicMarksUsed =
            selectedArmorMarks.length === this.actor.system.rules.damageReduction.maxArmorMarked.value;

        const stressReductionStress = this.availableStressReductions
            ? stressReductions.reduce((acc, red) => acc + red.cost, 0)
            : 0;
        context.stress =
            selectedStressMarks.length > 0 || this.availableStressReductions
                ? {
                      value:
                          this.actor.system.resources.stress.value + selectedStressMarks.length + stressReductionStress,
                      max: this.actor.system.resources.stress.max
                  }
                : null;

        const maxArmor = this.actor.system.rules.damageReduction.maxArmorMarked.value;
        context.marks = {
            armor: Object.keys(this.marks.armor).reduce((acc, key, index) => {
                const mark = this.marks.armor[key];
                if (!this.rulesOn || index + 1 <= maxArmor) acc[key] = mark;

                return acc;
            }, {}),
            stress: this.marks.stress
        };
        context.availableStressReductions = this.availableStressReductions;

        context.damage = getDamageLabel(this.damage);
        context.reducedDamage = currentDamage !== this.damage ? getDamageLabel(currentDamage) : null;
        context.currentDamage = context.reducedDamage ?? context.damage;
        context.currentDamageNr = currentDamage;

        return context;
    }

    static updateData(event, _, formData) {
        foundry.utils.expandObject(formData.object);
        this.render(true);
    }

    getDamageInfo = () => {
        const selectedArmorMarks = Object.values(this.marks.armor).filter(x => x.selected);
        const selectedStressMarks = Object.values(this.marks.stress).filter(x => x.selected);
        const stressReductions = this.availableStressReductions
            ? Object.values(this.availableStressReductions).filter(red => red.selected)
            : [];
        const currentMarks =
            this.actor.system.armor.system.marks.value + selectedArmorMarks.length + selectedStressMarks.length;

        const armorMarkReduction =
            selectedArmorMarks.length * this.actor.system.rules.damageReduction.increasePerArmorMark;
        let currentDamage = Math.max(
            this.damage - armorMarkReduction - selectedStressMarks.length - stressReductions.length,
            0
        );

        if (this.thresholdImmunities[currentDamage]) currentDamage = 0;

        return { selectedArmorMarks, selectedStressMarks, stressReductions, currentMarks, currentDamage };
    };

    static toggleRules() {
        this.rulesOn = !this.rulesOn;

        const maxArmor = this.actor.system.rules.damageReduction.maxArmorMarked.value;
        this.marks = {
            armor: Object.keys(this.marks.armor).reduce((acc, key, index) => {
                const mark = this.marks.armor[key];
                const keepSelectValue = !this.rulesOn || index + 1 <= maxArmor;
                acc[key] = { ...mark, selected: keepSelectValue ? mark.selected : false };

                return acc;
            }, {}),
            stress: this.marks.stress
        };

        this.render();
    }

    static setMarks(_, target) {
        const currentMark = this.marks[target.dataset.type][target.dataset.key];
        const { selectedStressMarks, stressReductions, currentMarks, currentDamage } = this.getDamageInfo();

        if (!currentMark.selected && currentDamage === 0) {
            ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.damageAlreadyNone'));
            return;
        }

        if (this.rulesOn) {
            if (!currentMark.selected && currentMarks === this.actor.system.armorScore) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noAvailableArmorMarks'));
                return;
            }
        }

        if (currentMark.selected) {
            const currentDamageLabel = getDamageLabel(currentDamage);
            for (let reduction of stressReductions) {
                if (reduction.selected && reduction.to === currentDamageLabel) {
                    reduction.selected = false;
                }
            }

            if (target.dataset.type === 'armor' && selectedStressMarks.length > 0) {
                selectedStressMarks.forEach(mark => (mark.selected = false));
            }
        }

        currentMark.selected = !currentMark.selected;
        this.render();
    }

    static useStressReduction(_, target) {
        const damageValue = Number(target.dataset.reduction);
        const stressReduction = this.availableStressReductions[damageValue];
        const { currentDamage, selectedStressMarks, stressReductions } = this.getDamageInfo();

        if (stressReduction.selected) {
            stressReduction.selected = false;

            const currentDamageLabel = getDamageLabel(currentDamage);
            for (let reduction of stressReductions) {
                if (reduction.selected && reduction.to === currentDamageLabel) {
                    reduction.selected = false;
                }
            }

            this.render();
        } else {
            const stressReductionStress = this.availableStressReductions
                ? stressReductions.reduce((acc, red) => acc + red.cost, 0)
                : 0;
            const currentStress =
                this.actor.system.resources.stress.value + selectedStressMarks.length + stressReductionStress;
            if (currentStress + stressReduction.cost > this.actor.system.resources.stress.max) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.notEnoughStress'));
                return;
            }

            const reducedDamage = currentDamage !== this.damage ? getDamageLabel(currentDamage) : null;
            const currentDamageLabel = reducedDamage ?? getDamageLabel(this.damage);

            if (!stressReduction.any && stressReduction.from !== currentDamageLabel) return;

            stressReduction.selected = true;
            this.render();
        }
    }

    static async takeDamage() {
        const { selectedArmorMarks, selectedStressMarks, stressReductions, currentDamage } = this.getDamageInfo();
        const armorSpent = selectedArmorMarks.length + selectedStressMarks.length;
        const stressSpent = selectedStressMarks.length + stressReductions.reduce((acc, red) => acc + red.cost, 0);

        this.resolve({ modifiedDamage: currentDamage, armorSpent, stressSpent });
        await this.close(true);
    }

    async close(fromSave) {
        if (!fromSave) {
            this.resolve();
        }

        await super.close({});
    }

    static async armorSlotQuery({ actorId, damage, type }) {
        return new Promise(async (resolve, reject) => {
            const actor = await fromUuid(actorId);
            if (!actor || !actor?.isOwner) reject();
            new DamageReductionDialog(resolve, reject, actor, damage, type).render({ force: true });
        });
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$g, ApplicationV2: ApplicationV2$f } = foundry.applications.api;

class DhpDeathMove extends HandlebarsApplicationMixin$g(ApplicationV2$f) {
    constructor(actor) {
        super({});

        this.actor = actor;
        this.selectedMove = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.DeathMove.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog', 'views', 'death-move'],
        position: { width: 'auto', height: 'auto' },
        window: { icon: 'fa-solid fa-skull' },
        actions: {
            selectMove: this.selectMove,
            takeMove: this.takeMove
        }
    };

    static PARTS = {
        application: {
            id: 'death-move',
            template: 'systems/daggerheart/templates/dialogs/deathMove.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.selectedMove = this.selectedMove;
        context.options = CONFIG.DH.GENERAL.deathMoves;
        context.title = game.i18n.localize('DAGGERHEART.APPLICATIONS.DeathMove.takeMove');

        return context;
    }

    static selectMove(_, button) {
        const move = button.dataset.move;
        this.selectedMove = CONFIG.DH.GENERAL.deathMoves[move];

        this.render();
    }

    static async takeMove() {
        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/deathMove.hbs',
                {
                    player: this.actor.name,
                    actor: { name: this.actor.name, img: this.actor.img },
                    author: game.users.get(game.user.id),
                    title: game.i18n.localize(this.selectedMove.name),
                    img: this.selectedMove.img,
                    description: game.i18n.localize(this.selectedMove.description)
                }
            ),
            title: game.i18n.localize(
                'DAGGERHEART.UI.Chat.deathMove.title'
            ),
            speaker: cls.getSpeaker(),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);

        this.close();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$f, ApplicationV2: ApplicationV2$e } = foundry.applications.api;

class DhpDowntime extends HandlebarsApplicationMixin$f(ApplicationV2$e) {
    constructor(actor, shortrest) {
        super({});

        this.actor = actor;
        this.shortrest = shortrest;

        this.moveData = foundry.utils.deepClone(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).restMoves
        );
        this.nrChoices = {
            shortRest: {
                taken: 0,
                max:
                    (shortrest ? this.moveData.shortRest.nrChoices : 0) +
                    actor.system.bonuses.rest[`${shortrest ? 'short' : 'long'}Rest`].shortMoves
            },
            longRest: {
                taken: 0,
                max:
                    (!shortrest ? this.moveData.longRest.nrChoices : 0) +
                    actor.system.bonuses.rest[`${shortrest ? 'short' : 'long'}Rest`].longMoves
            }
        };

        this.refreshables = this.getRefreshables();
    }

    get title() {
        return '';
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'dh-style', 'dialog', 'downtime'],
        position: { width: 'auto', height: 'auto' },
        actions: {
            selectMove: this.selectMove,
            takeDowntime: this.takeDowntime
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        application: {
            id: 'downtime',
            template: 'systems/daggerheart/templates/dialogs/downtime/downtime.hbs'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement
            .querySelectorAll('.activity-container')
            .forEach(element => element.addEventListener('contextmenu', this.deselectMove.bind(this)));
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.title = game.i18n.localize(
            `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
        );
        context.selectedActivity = this.selectedActivity;
        context.moveData = this.moveData;

        const shortRestMovesSelected = this.nrSelectedMoves('shortRest');
        const longRestMovesSelected = this.nrSelectedMoves('longRest');
        context.nrChoices = {
            ...this.nrChoices,
            shortRest: {
                ...this.nrChoices.shortRest,
                current: this.nrChoices.shortRest.taken + shortRestMovesSelected
            },
            longRest: {
                ...this.nrChoices.longRest,
                current: this.nrChoices.longRest.taken + longRestMovesSelected
            }
        };

        context.shortRestMoves = this.nrChoices.shortRest.max > 0 ? this.moveData.shortRest : null;
        context.longRestMoves = this.nrChoices.longRest.max > 0 ? this.moveData.longRest : null;

        context.refreshables = this.refreshables;

        context.disabledDowntime = shortRestMovesSelected === 0 && longRestMovesSelected === 0;

        return context;
    }

    getRefreshables() {
        const actionItems = this.actor.items.reduce((acc, x) => {
            if (x.system.actions) {
                const recoverable = x.system.actions.reduce((acc, action) => {
                    if (
                        action.uses.recovery &&
                        ((action.uses.recovery === 'longRest' && !this.shortrest) ||
                            action.uses.recovery === 'shortRest')
                    ) {
                        acc.push({
                            title: x.name,
                            name: action.name,
                            uuid: action.uuid
                        });
                    }

                    return acc;
                }, []);

                if (recoverable) {
                    acc.push(...recoverable);
                }
            }

            return acc;
        }, []);
        const resourceItems = this.actor.items.reduce((acc, x) => {
            if (
                x.system.resource &&
                x.system.resource.type &&
                ((x.system.resource.recovery === 'longRest') === !this.shortrest ||
                    x.system.resource.recovery === 'shortRest')
            ) {
                acc.push({
                    title: game.i18n.localize(`TYPES.Item.${x.type}`),
                    name: x.name,
                    uuid: x.uuid
                });
            }

            return acc;
        }, []);
        return {
            actionItems,
            resourceItems
        };
    }

    static selectMove(_, target) {
        const { category, move } = target.dataset;

        const nrSelected = this.nrSelectedMoves(category);

        if (nrSelected + this.nrChoices[category].taken >= this.nrChoices[category].max) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noMoreMoves'));
            return;
        }

        this.moveData[category].moves[move].selected = this.moveData[category].moves[move].selected
            ? this.moveData[category].moves[move].selected + 1
            : 1;

        this.render();
    }

    deselectMove(event) {
        const button = event.target.closest('.activity-container');
        const { move, category } = button.dataset;
        this.moveData[category].moves[move].selected = this.moveData[category].moves[move].selected
            ? this.moveData[category].moves[move].selected - 1
            : 0;

        this.render();

        // On macOS with a single-button mouse (e.g. a laptop trackpad),
        // right-click is triggered with ctrl+click, which triggers both a
        // `contextmenu` event and a regular click event. We need to stop
        // event propagation to prevent the click event from triggering the
        // `selectMove` function and undoing the change we just made.
        event.stopPropagation();

        // Having stopped propagation, we're no longer subject to Foundry's
        // default `contextmenu` handler, so we also have to prevent the
        // default behaviour to prevent a context menu from appearing.
        event.preventDefault();
    }

    static async takeDowntime() {
        const moves = Object.values(this.moveData).flatMap(category => {
            return Object.values(category.moves)
                .filter(x => x.selected)
                .flatMap(move => [...Array(move.selected).keys()].map(_ => move));
        });

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            system: {
                moves: moves,
                actor: this.actor.uuid
            },
            speaker: cls.getSpeaker(),
            title: game.i18n.localize(
                `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
            ),
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/downtime.hbs',
                {
                    title: game.i18n.localize(
                        `DAGGERHEART.APPLICATIONS.Downtime.${this.shortrest ? 'shortRest' : 'longRest'}.title`
                    ),
                    actor: { name: this.actor.name, img: this.actor.img },
                    moves: moves
                }
            ),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);

        // Reset selection and update number of taken moves
        for (const [catName, category] of Object.entries(this.moveData)) {
            for (const move of Object.values(category.moves)) {
                if (move.selected > 0) {
                    this.nrChoices[catName].taken += move.selected;
                    move.selected = 0;
                }
            }
        }

        // We can close the window and refresh resources when all moves are taken
        if (
            this.nrChoices.shortRest.taken >= this.nrChoices.shortRest.max &&
            this.nrChoices.longRest.taken >= this.nrChoices.longRest.max
        ) {
            for (var data of this.refreshables.actionItems) {
                const action = await foundry.utils.fromUuid(data.uuid);
                await action.parent.parent.update({ [`system.actions.${action.id}.uses.value`]: 0 });
            }

            for (var data of this.refreshables.resourceItems) {
                const feature = await foundry.utils.fromUuid(data.uuid);
                const increasing =
                    feature.system.resource.progression === CONFIG.DH.ITEM.itemResourceProgression.increasing.id;
                const resetValue = increasing
                    ? 0
                    : feature.system.resource.max
                      ? Roll.replaceFormulaData(feature.system.resource.max, this.actor)
                      : 0;
                await feature.update({ 'system.resource.value': resetValue });
            }

            this.close();
        } else {
            this.render();
        }
    }

    static async updateData(event, element, formData) {
        this.customActivity = foundry.utils.mergeObject(this.customActivity, formData.object);
        this.render();
    }

    nrSelectedMoves(category) {
        return Object.values(this.moveData[category].moves).reduce((acc, x) => acc + (x.selected ?? 0), 0);
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$e, ApplicationV2: ApplicationV2$d } = foundry.applications.api;

class MulticlassChoiceDialog extends HandlebarsApplicationMixin$e(ApplicationV2$d) {
    constructor(actor, multiclass, options) {
        super(options);

        this.actor = actor;
        this.multiclass = multiclass;
        this.selectedDomain = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.MulticlassChoice.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog', 'views', 'multiclass-choice'],
        position: { width: 'auto', height: 'auto' },
        window: { icon: 'fa-solid fa-person-rays' },
        actions: {
            save: MulticlassChoiceDialog.#save,
            selectDomain: MulticlassChoiceDialog.#selectDomain
        }
    };

    static PARTS = {
        application: {
            id: 'multiclass-choice',
            template: 'systems/daggerheart/templates/dialogs/multiclassChoice.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.multiclass = this.multiclass;
        context.domainChoices = this.multiclass.domains.map(value => {
            const domain = CONFIG.DH.DOMAIN.allDomains()[value];
            return {
                value: value,
                label: game.i18n.localize(domain.label),
                description: game.i18n.localize(domain.description),
                src: domain.src,
                selected: value === this.selectedDomain,
                disabled: this.actor.system.domains.includes(value)
            };
        });
        context.multiclassDisabled = !this.selectedDomain;

        return context;
    }

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.move = null;
    }

    static async configure(actor, multiclass, options = {}) {
        return new Promise(resolve => {
            const app = new this(actor, multiclass, options);
            app.addEventListener('close', () => resolve(app.selectedDomain), { once: true });
            app.render({ force: true });
        });
    }

    static #save() {
        this.close({ submitted: true });
    }

    static #selectDomain(_event, button) {
        this.selectedDomain = this.selectedDomain === button.dataset.domain ? null : button.dataset.domain;
        this.render();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$d, ApplicationV2: ApplicationV2$c } = foundry.applications.api;

class OwnershipSelection extends HandlebarsApplicationMixin$d(ApplicationV2$c) {
    constructor(resolve, reject, name, ownership) {
        super({});

        this.resolve = resolve;
        this.reject = reject;
        this.name = name;
        this.ownership = ownership;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'views', 'ownership-selection'],
        position: {
            width: 600,
            height: 'auto'
        },
        form: { handler: this.updateData }
    };

    static PARTS = {
        selection: {
            template: 'systems/daggerheart/templates/dialogs/ownershipSelection.hbs'
        }
    };

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.OwnershipSelection.title', { name: this.name });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.ownershipOptions = Object.keys(CONST.DOCUMENT_OWNERSHIP_LEVELS).map(level => ({
            value: CONST.DOCUMENT_OWNERSHIP_LEVELS[level],
            label: game.i18n.localize(`OWNERSHIP.${level}`)
        }));
        context.ownership = {
            default: this.ownership.default,
            players: Object.keys(this.ownership.players).reduce((acc, x) => {
                const user = game.users.get(x);
                if (!user.isGM) {
                    acc[x] = {
                        img: user.character?.img ?? 'icons/svg/cowled.svg',
                        name: user.name,
                        ownership: this.ownership.players[x].value
                    };
                }

                return acc;
            }, {})
        };

        return context;
    }

    static async updateData(event, _, formData) {
        const { ownership } = foundry.utils.expandObject(formData.object);

        this.resolve(ownership);
        this.close(true);
    }

    async close(fromSave) {
        if (!fromSave) {
            this.reject();
        }

        await super.close();
    }
}

const { ApplicationV2: ApplicationV2$b, HandlebarsApplicationMixin: HandlebarsApplicationMixin$c } = foundry.applications.api;

class RerollDamageDialog extends HandlebarsApplicationMixin$c(ApplicationV2$b) {
    constructor(message, options = {}) {
        super(options);

        this.message = message;
        this.damage = Object.keys(message.system.damage).reduce((acc, typeKey) => {
            const type = message.system.damage[typeKey];
            acc[typeKey] = Object.keys(type.parts).reduce((acc, partKey) => {
                const part = type.parts[partKey];
                acc[partKey] = Object.keys(part.dice).reduce((acc, diceKey) => {
                    const dice = part.dice[diceKey];
                    const activeResults = dice.results.filter(x => x.active);
                    acc[diceKey] = {
                        dice: dice.dice,
                        selectedResults: activeResults.length,
                        maxSelected: activeResults.length,
                        results: activeResults.map(x => ({ ...x, selected: true }))
                    };

                    return acc;
                }, {});

                return acc;
            }, {});

            return acc;
        }, {});
    }

    static DEFAULT_OPTIONS = {
        id: 'reroll-dialog',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'reroll-dialog'],
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            toggleResult: RerollDamageDialog.#toggleResult,
            selectRoll: RerollDamageDialog.#selectRoll,
            doReroll: RerollDamageDialog.#doReroll,
            save: RerollDamageDialog.#save
        }
    };

    /** @override */
    static PARTS = {
        main: {
            id: 'main',
            template: 'systems/daggerheart/templates/dialogs/rerollDialog/damage/main.hbs'
        },
        footer: {
            id: 'footer',
            template: 'systems/daggerheart/templates/dialogs/rerollDialog/footer.hbs'
        }
    };

    get title() {
        return game.i18n.localize('DAGGERHEART.APPLICATIONS.RerollDialog.damageTitle');
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.to-reroll-input').forEach(element => {
            element.addEventListener('change', this.toggleDice.bind(this));
        });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.damage = this.damage;
        context.disabledReroll = !this.getRerollDice().length;
        context.saveDisabled = !this.isSelectionDone();

        return context;
    }

    static async #save() {
        const update = {
            'system.damage': Object.keys(this.damage).reduce((acc, typeKey) => {
                const type = this.damage[typeKey];
                let typeTotal = 0;
                const messageType = this.message.system.damage[typeKey];
                const parts = Object.keys(type).map(partKey => {
                    const part = type[partKey];
                    const messagePart = messageType.parts[partKey];
                    let partTotal = messagePart.modifierTotal;
                    const dice = Object.keys(part).map(diceKey => {
                        const dice = part[diceKey];
                        const total = dice.results.reduce((acc, result) => {
                            if (result.active) acc += result.result;
                            return acc;
                        }, 0);
                        partTotal += total;
                        const messageDice = messagePart.dice[diceKey];
                        return {
                            ...messageDice,
                            total: total,
                            results: dice.results.map(x => ({
                                ...x,
                                hasRerolls: dice.results.length > 1
                            }))
                        };
                    });

                    typeTotal += partTotal;
                    return {
                        ...messagePart,
                        total: partTotal,
                        dice: dice
                    };
                });

                acc[typeKey] = {
                    ...messageType,
                    total: typeTotal,
                    parts: parts
                };

                return acc;
            }, {})
        };
        await this.message.update(update);
        await this.close();
    }

    getRerollDice() {
        const rerollDice = [];
        Object.keys(this.damage).forEach(typeKey => {
            const type = this.damage[typeKey];
            Object.keys(type).forEach(partKey => {
                const part = type[partKey];
                Object.keys(part).forEach(diceKey => {
                    const dice = part[diceKey];
                    Object.keys(dice.results).forEach(resultKey => {
                        const result = dice.results[resultKey];
                        if (result.toReroll) {
                            rerollDice.push({
                                ...result,
                                dice: dice.dice,
                                type: typeKey,
                                part: partKey,
                                dice: diceKey,
                                result: resultKey
                            });
                        }
                    });
                });
            });
        });

        return rerollDice;
    }

    isSelectionDone() {
        const diceFinishedData = [];
        Object.keys(this.damage).forEach(typeKey => {
            const type = this.damage[typeKey];
            Object.keys(type).forEach(partKey => {
                const part = type[partKey];
                Object.keys(part).forEach(diceKey => {
                    const dice = part[diceKey];
                    const selected = dice.results.reduce((acc, result) => acc + (result.active ? 1 : 0), 0);
                    diceFinishedData.push(selected === dice.maxSelected);
                });
            });
        });

        return diceFinishedData.every(x => x);
    }

    toggleDice(event) {
        const target = event.target;
        const { type, part, dice } = target.dataset;
        const toggleDice = this.damage[type][part][dice];

        const existingDiceRerolls = this.getRerollDice().filter(
            x => x.type === type && x.part === part && x.dice === dice
        );

        const allRerolled = existingDiceRerolls.length === toggleDice.results.filter(x => x.active).length;

        toggleDice.toReroll = !allRerolled;
        toggleDice.results.forEach(result => {
            if (result.active) {
                result.toReroll = !allRerolled;
            }
        });

        this.render();
    }

    static #toggleResult(event) {
        event.stopPropagation();

        const target = event.target.closest('.to-reroll-result');
        const { type, part, dice, result } = target.dataset;
        const toggleDice = this.damage[type][part][dice];
        const toggleResult = toggleDice.results[result];
        toggleResult.toReroll = !toggleResult.toReroll;

        const existingDiceRerolls = this.getRerollDice().filter(
            x => x.type === type && x.part === part && x.dice === dice
        );

        const allToReroll = existingDiceRerolls.length === toggleDice.results.filter(x => x.active).length;
        toggleDice.toReroll = allToReroll;

        this.render();
    }

    static async #selectRoll(_, button) {
        const { type, part, dice, result } = button.dataset;

        const diceVal = this.damage[type][part][dice];
        const diceResult = diceVal.results[result];
        if (!diceResult.active && diceVal.results.filter(x => x.active).length === diceVal.maxSelected) {
            return ui.notifications.warn(
                game.i18n.localize('DAGGERHEART.APPLICATIONS.RerollDialog.deselectDiceNotification')
            );
        }

        if (diceResult.active) {
            diceVal.toReroll = false;
            diceResult.toReroll = false;
        }

        diceVal.selectedResults += diceResult.active ? -1 : 1;
        diceResult.active = !diceResult.active;

        this.render();
    }

    static async #doReroll() {
        const toReroll = this.getRerollDice().map(x => {
            const { type, part, dice, result } = x;
            const diceData = this.damage[type][part][dice].results[result];
            return {
                ...diceData,
                dice: this.damage[type][part][dice].dice,
                typeKey: type,
                partKey: part,
                diceKey: dice,
                resultsIndex: result
            };
        });

        const roll = await new Roll(toReroll.map(x => `1${x.dice}`).join(' + ')).evaluate();

        if (game.modules.get('dice-so-nice')?.active) {
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: roll.dice,
                options: { appearance: {} }
            };

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        toReroll.forEach((data, index) => {
            const { typeKey, partKey, diceKey, resultsIndex } = data;
            const rerolledDice = roll.dice[index];

            const dice = this.damage[typeKey][partKey][diceKey];
            dice.toReroll = false;
            dice.results[resultsIndex].active = false;
            dice.results[resultsIndex].discarded = true;
            dice.results[resultsIndex].toReroll = false;
            dice.results.splice(dice.results.length, 0, {
                ...rerolledDice.results[0],
                toReroll: false,
                selected: true
            });
        });

        this.render();
    }
}

const { ApplicationV2: ApplicationV2$a, HandlebarsApplicationMixin: HandlebarsApplicationMixin$b } = foundry.applications.api;

class ResourceDiceDialog extends HandlebarsApplicationMixin$b(ApplicationV2$a) {
    constructor(item, actor, options = {}) {
        super(options);

        this.item = item;
        this.actor = actor;
        this.diceStates = foundry.utils.deepClone(item.system.resource.diceStates);
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'views', 'resource-dice'],
        window: {
            icon: 'fa-solid fa-dice'
        },
        actions: {
            rerollDice: this.rerollDice,
            save: this.save
        },
        form: {
            handler: this.updateResourceDice,
            submitOnChange: true,
            submitOnClose: false
        }
    };

    /** @override */
    static PARTS = {
        resourceDice: {
            id: 'resourceDice',
            template: 'systems/daggerheart/templates/dialogs/dice-roll/resourceDice.hbs'
        }
    };

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.ResourceDice.title', { name: this.item.name });
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.item = this.item;
        context.actor = this.actor;
        context.diceStates = this.diceStates;

        return context;
    }

    static async updateResourceDice(event, _, formData) {
        const { diceStates } = foundry.utils.expandObject(formData.object);
        this.diceStates = Object.keys(diceStates).reduce((acc, key) => {
            const resourceState = this.item.system.resource.diceStates[key];
            acc[key] = { ...diceStates[key], used: Boolean(resourceState?.used) };
            return acc;
        }, {});

        this.render();
    }

    static async save() {
        this.rollValues = Object.values(this.diceStates);
        this.close();
    }

    static async rerollDice() {
        const max = itemAbleRollParse(this.item.system.resource.max, this.actor, this.item);
        const diceFormula = `${max}${this.item.system.resource.dieFaces}`;
        const roll = await new Roll(diceFormula).evaluate();
        if (game.modules.get('dice-so-nice')?.active) await game.dice3d.showForRoll(roll, game.user, true);
        this.rollValues = roll.terms[0].results.map(x => ({ value: x.result, used: false }));
        this.resetUsed = true;

        const cls = getDocumentClass('ChatMessage');
        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/resource-roll.hbs',
                {
                    user: this.actor.name,
                    name: this.item.name
                }
            )
        };

        cls.create(msg);
        this.close();
    }

    static async create(item, actor, options = {}) {
        return new Promise(resolve => {
            const app = new this(item, actor, options);
            app.addEventListener('close', () => resolve(app.rollValues), { once: true });
            app.render({ force: true });
        });
    }
}

const { ApplicationV2: ApplicationV2$9, HandlebarsApplicationMixin: HandlebarsApplicationMixin$a } = foundry.applications.api;

class ActionSelectionDialog extends HandlebarsApplicationMixin$a(ApplicationV2$9) {
    constructor(item, event, options = {}) {
        super(options);
        this.#item = item;
        this.#event = event;
    }

    /* -------------------------------------------- */

    /** @override */
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'dialog'],
        actions: {
            choose: ActionSelectionDialog.#onChooseAction
        },
        position: {
            width: 400
        }
    };

    /* -------------------------------------------- */

    static PARTS = {
        actions: {
            template: 'systems/daggerheart/templates/dialogs/actionSelect.hbs'
        }
    };

    #item;

    get item() {
        return this.#item;
    }

    #event;

    get event() {
        return this.#event;
    }

    #action;

    get action() {
        return this.#action ?? null;
    }

    /* -------------------------------------------- */

    /** @override */
    get title() {
        return game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectAction');
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    async _prepareContext(options) {
        const actions = this.#item.system.actionsList,
            itemName = this.#item.name;
        return {
            ...(await super._prepareContext(options)),
            actions,
            itemName
        };
    }

    static async #onChooseAction(event, button) {
        const { actionId } = button.dataset;
        this.#action = this.#item.system.actionsList.find(a => a._id === actionId);
        Object.defineProperty(this.#event, 'shiftKey', {
            get() {
                return event.shiftKey;
            }
        });
        this.close();
    }

    static create(item, event, options) {
        return new Promise(resolve => {
            const dialog = new this(item, event, options);
            dialog.addEventListener('close', () => resolve(dialog.action), { once: true });
            dialog.render({ force: true });
        });
    }
}

var _module$e = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionSelectionDialog: ActionSelectionDialog,
    BeastformDialog: BeastformDialog,
    DamageDialog: DamageDialog,
    DamageReductionDialog: DamageReductionDialog,
    DeathMove: DhpDeathMove,
    Downtime: DhpDowntime,
    MulticlassChoiceDialog: MulticlassChoiceDialog,
    OwnershipSelection: OwnershipSelection,
    RerollDamageDialog: RerollDamageDialog,
    ResourceDiceDialog: ResourceDiceDialog,
    d20RollDialog: D20RollDialog
});

class DHTokenHUD extends foundry.applications.hud.TokenHUD {
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart']
    };

    /** @override */
    static PARTS = {
        hud: {
            root: true,
            template: 'systems/daggerheart/templates/hud/tokenHUD.hbs'
        }
    };

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.systemStatusEffects = Object.keys(context.statusEffects).reduce((acc, key) => {
            const effect = context.statusEffects[key];
            if (effect.systemEffect) acc[key] = effect;

            return acc;
        }, {});

        const useGeneric = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.appearance
        ).showGenericStatusEffects;
        context.genericStatusEffects = useGeneric
            ? Object.keys(context.statusEffects).reduce((acc, key) => {
                  const effect = context.statusEffects[key];
                  if (!effect.systemEffect) acc[key] = effect;

                  return acc;
              }, {})
            : null;

        return context;
    }

    _getStatusEffectChoices() {
        // Include all HUD-enabled status effects
        const choices = {};
        for (const status of CONFIG.statusEffects) {
            if (
                status.hud === false ||
                (foundry.utils.getType(status.hud) === 'Object' &&
                    status.hud.actorTypes?.includes(this.document.actor.type) === false)
            ) {
                continue;
            }
            choices[status.id] = {
                _id: status._id,
                id: status.id,
                systemEffect: status.systemEffect,
                title: game.i18n.localize(status.name ?? /** @deprecated since v12 */ status.label),
                src: status.img ?? /** @deprecated since v12 */ status.icon,
                isActive: false,
                isOverlay: false
            };
        }

        // Update the status of effects which are active for the token actor
        const activeEffects = this.actor?.effects || [];
        for (const effect of activeEffects) {
            for (const statusId of effect.statuses) {
                const status = choices[statusId];
                if (!status) continue;
                if (status._id) {
                    if (status._id !== effect.id) continue;
                }
                status.isActive = true;
                if (effect.getFlag('core', 'overlay')) status.isOverlay = true;
            }
        }

        // Flag status CSS class
        for (const status of Object.values(choices)) {
            status.cssClass = [status.isActive ? 'active' : null, status.isOverlay ? 'overlay' : null].filterJoin(' ');
        }
        return choices;
    }
}

var _module$d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHTokenHUD: DHTokenHUD
});

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$9, ApplicationV2: ApplicationV2$8 } = foundry.applications.api;

class DhlevelUp extends HandlebarsApplicationMixin$9(ApplicationV2$8) {
    constructor(actor) {
        super({});

        this.actor = actor;

        this._dragDrop = this._createDragDropHandlers();
        this.tabGroups.primary = 'advancements';

        this.itemBrowser = null;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.title', { actor: this.actor.name });
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dialog', 'dh-style', 'levelup'],
        position: { width: 1000, height: 'auto' },
        window: {
            resizable: true,
            icon: 'fa-solid fa-arrow-turn-up'
        },
        actions: {
            save: this.save,
            viewCompendium: this.viewCompendium,
            selectPreview: this.selectPreview,
            selectDomain: this.selectDomain,
            selectSubclass: this.selectSubclass,
            updateCurrentLevel: this.updateCurrentLevel,
            activatePart: this.activatePart
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        },
        dragDrop: [{ dragSelector: null, dropSelector: '.levelup-card-selection .card-preview-container' }]
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/levelup/tabs/tab-navigation.hbs' },
        advancements: {
            template: 'systems/daggerheart/templates/levelup/tabs/advancements.hbs'
        },
        selections: {
            template: 'systems/daggerheart/templates/levelup/tabs/selections.hbs',
            scrollable: ['.levelup-selections-container']
        },
        summary: { template: 'systems/daggerheart/templates/levelup/tabs/summary.hbs' },
        footer: { template: 'systems/daggerheart/templates/levelup/tabs/footer.hbs' }
    };

    static TABS = {
        advancements: {
            active: true,
            cssClass: '',
            group: 'primary',
            id: 'advancements',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.advancement'
        },
        selections: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'selections',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.selections'
        },
        summary: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'summary',
            icon: null,
            label: 'DAGGERHEART.GENERAL.Tabs.summary'
        }
    };

    addBonusChoices(levelTiers) {
        for (var tierKey in levelTiers.tiers) {
            const tier = levelTiers.tiers[tierKey];
            tier.maxSelections = [...Array(tier.levels.end - tier.levels.start + 1).keys()].reduce((acc, index) => {
                const level = tier.levels.start + index;
                const bonus = this.actor.system.levelData.level.bonuses[level];
                acc[level] = tier.availableOptions + (bonus ?? 0);

                return acc;
            }, {});
        }

        return levelTiers;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.levelup = this.levelup;
        context.tabs = this._getTabs(this.constructor.TABS);
        context.levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        return context;
    }

    async _preparePartContext(partId, context) {
        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'tabs':
                const previous =
                    this.levelup.currentLevel === this.levelup.startLevel ? null : this.levelup.currentLevel - 1;
                const next = this.levelup.currentLevel === this.levelup.endLevel ? null : this.levelup.currentLevel + 1;
                context.navigate = {
                    previous: {
                        disabled: !previous,
                        label: previous
                            ? game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.navigateLevel', { level: previous })
                            : '',
                        fromSummary: this.tabGroups.primary === 'summary'
                    },
                    next: {
                        disabled: !this.levelup.currentLevelFinished,
                        label: next
                            ? game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.navigateLevel', { level: next })
                            : '',
                        toSummary: !next,
                        show: this.tabGroups.primary !== 'summary'
                    }
                };

                const { selections } = currentLevel.nrSelections;
                context.tabs.advancements.progress = { selected: selections, max: currentLevel.maxSelections };
                context.showTabs = this.tabGroups.primary !== 'summary';
                break;
        }

        return context;
    }

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }

    _createDragDropHandlers() {
        return this.options.dragDrop.map(d => {
            d.callbacks = {
                drop: this._onDrop.bind(this)
            };
            return new foundry.applications.ux.DragDrop.implementation(d);
        });
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        htmlElement
            .querySelectorAll('.selection-checkbox')
            .forEach(element => element.addEventListener('change', this.selectionClick.bind(this)));

        const traitsTagify = htmlElement.querySelector('.levelup-trait-increases');
        if (traitsTagify) {
            tagifyElement(traitsTagify, this.levelup.unmarkedTraits, this.tagifyUpdate('trait').bind(this));
        }

        const experienceIncreaseTagify = htmlElement.querySelector('.levelup-experience-increases');
        if (experienceIncreaseTagify) {
            tagifyElement(
                experienceIncreaseTagify,
                Object.keys(this.actor.system.experiences).reduce((acc, id) => {
                    const experience = this.actor.system.experiences[id];
                    acc.push({ id: id, label: experience.name });

                    return acc;
                }, []),
                this.tagifyUpdate('experience').bind(this)
            );
        }

        this._dragDrop.forEach(d => d.bind(htmlElement));
    }

    tagifyUpdate =
        type =>
        async (_, { option, removed }) => {
            const updatePath = Object.keys(this.levelup.levels[this.levelup.currentLevel].choices).reduce(
                (acc, choiceKey) => {
                    const choice = this.levelup.levels[this.levelup.currentLevel].choices[choiceKey];
                    Object.keys(choice).forEach(checkboxNr => {
                        const checkbox = choice[checkboxNr];
                        if (
                            choiceKey === type &&
                            (removed ? checkbox.data.includes(option) : checkbox.data.length < checkbox.amount)
                        ) {
                            acc = `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}.data`;
                        }
                    });

                    return acc;
                },
                null
            );

            if (!updatePath) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noSelectionsLeft'));
                return;
            }

            const currentData = foundry.utils.getProperty(this.levelup, updatePath);
            const updatedData = removed ? currentData.filter(x => x !== option) : [...currentData, option];
            await this.levelup.updateSource({ [updatePath]: updatedData });
            this.render();
        };

    static async updateForm(event, _, formData) {
        const { levelup } = foundry.utils.expandObject(formData.object);
        await this.levelup.updateSource(levelup);
        this.render();
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.getDragEventData(event);
        const item = await fromUuid(data.uuid);
        if (event.target.closest('.domain-cards')) {
            const target = event.target.closest('.card-preview-container');
            if (item.type === 'domainCard') {
                const { multiclass } = this.levelup.classUpgradeChoices;
                const isMulticlass = !multiclass ? false : item.system.domain === multiclass.domain;
                if (
                    !this.actor.system.domains.includes(item.system.domain) &&
                    this.levelup.classUpgradeChoices?.multiclass?.domain !== item.system.domain
                ) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardWrongDomain'));
                    return;
                }

                const levelBase = isMulticlass ? Math.ceil(this.levelup.currentLevel / 2) : this.levelup.currentLevel;
                const levelMax = target.dataset.limit ? Math.min(Number(target.dataset.limit), levelBase) : levelBase;
                if (levelMax < item.system.level) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardToHighLevel'));
                    return;
                }

                const cardExistsInCharacter = this.actor.items.find(x => x.name === item.name); // Any other way to check? The item is a copy so different ids
                const cardExistsInLevelup = Object.values(this.levelup.levels).some(level => {
                    const achievementExists = Object.values(level.achievements.domainCards).some(
                        card => card.uuid === item.uuid
                    );
                    const advancementExists = Object.keys(level.choices).some(choiceKey => {
                        if (choiceKey !== 'domainCard') return false;
                        const choice = level.choices[choiceKey];
                        return Object.values(choice).some(checkbox => checkbox.data.includes(item.uuid));
                    });

                    return achievementExists || advancementExists;
                });
                if (cardExistsInCharacter || cardExistsInLevelup) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.domainCardDuplicate'));
                    return;
                }

                await this.levelup.updateSource({ [target.dataset.path]: item.uuid });
                this.render();
            }
        } else if (event.target.closest('.multiclass-cards')) {
            const target = event.target.closest('.multiclass-cards');
            if (item.type === 'class') {
                if (item.name === this.actor.system.class.value.name) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.alreadySelectedClass'));
                    return;
                }

                const secondaryData = Object.keys(
                    foundry.utils.getProperty(this.levelup, `${target.dataset.path}.secondaryData`)
                ).reduce((acc, key) => {
                    acc[`-=${key}`] = null;
                    return acc;
                }, {});
                await this.levelup.updateSource({
                    multiclass: {
                        class: item.uuid,
                        level: this.levelup.currentLevel,
                        tier: Number(target.dataset.tier)
                    },
                    [target.dataset.path]: {
                        tier: Number(target.dataset.tier),
                        minCost: Number(target.dataset.minCost),
                        amount: target.dataset.amount ? Number(target.dataset.amount) : null,
                        value: target.dataset.value,
                        type: target.dataset.type,
                        data: item.uuid,
                        secondaryData: secondaryData
                    }
                });
                this.render();
            }
        }
    }

    async selectionClick(event) {
        event.stopPropagation();
        const button = event.currentTarget;

        const update = {};
        if (!button.checked) {
            const basePath = `levels.${this.levelup.currentLevel}.choices`;
            const current = foundry.utils.getProperty(this.levelup, `${basePath}.${button.dataset.option}`);
            if (Number(button.dataset.cost) > 1 || Object.keys(current).length === 1) {
                // Simple handling that doesn't cover potential Custom LevelTiers.
                update[`${basePath}.-=${button.dataset.option}`] = null;
            } else {
                update[`${basePath}.${button.dataset.option}.-=${button.dataset.checkboxNr}`] = null;
            }
        } else {
            if (this.levelup.levels[this.levelup.currentLevel].nrSelections.available < Number(button.dataset.cost)) {
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.insufficentAdvancements'));
                this.render();
                return;
            }

            const updateData = {
                tier: Number(button.dataset.tier),
                minCost: Number(button.dataset.cost),
                amount: button.dataset.amount ? Number(button.dataset.amount) : null,
                value: button.dataset.value,
                type: button.dataset.type
            };

            if (button.dataset.type === 'domainCard') {
                updateData.secondaryData = {
                    limit: Math.max(...this.levelup.tiers[button.dataset.tier].belongingLevels)
                };
            }

            update[
                `levels.${this.levelup.currentLevel}.choices.${button.dataset.option}.${button.dataset.checkboxNr}`
            ] = updateData;
        }

        await this.levelup.updateSource(update);
        this.render();
    }

    static async viewCompendium(event, target) {
        const type = target.dataset.compendium ?? target.dataset.type;

        const presets = {
            compendium: 'daggerheart',
            folder: type,
            render: {
                noFolder: true
            }
        };

        if (type == 'domains') {
            const domains = this.actor.system.domains,
                multiclassDomain = this.levelup.classUpgradeChoices?.multiclass?.domain;
            if (multiclassDomain) {
                if (!domains.includes(x => x === multiclassDomain)) domains.push(multiclassDomain);
            }
            presets.filter = {
                'level.max': { key: 'level.max', value: this.levelup.currentLevel },
                'system.domain': { key: 'system.domain', value: domains }
            };
        }

        return (this.itemBrowser = await new ItemBrowser({ presets }).render({ force: true }));
    }

    static async selectPreview(_, button) {
        const remove = button.dataset.selected;
        await this.levelup.updateSource({
            [`${button.dataset.path}`]: {
                data: remove ? [] : [button.dataset.uuid],
                secondaryData: {
                    featureState: button.dataset.featureState,
                    isMulticlass: button.dataset.isMulticlass
                }
            }
        });

        this.render();
    }

    static async selectDomain(_, button) {
        const option = foundry.utils.getProperty(this.levelup, button.dataset.path);
        const domain = option.secondaryData.domain ? null : button.dataset.domain;
        const update = { [`${button.dataset.path}.secondaryData.domain`]: domain };

        const domainCards = this.levelup.levels[this.levelup.currentLevel].achievements.domainCards;
        const illegalDomainCards = option.secondaryData.domain
            ? Object.keys(domainCards)
                  .map(key => ({ ...domainCards[key], key }))
                  .filter(
                      x => x.uuid && foundry.utils.fromUuidSync(x.uuid).system.domain === option.secondaryData.domain
                  )
            : [];
        illegalDomainCards.forEach(card => {
            update[`levels.${this.levelup.currentLevel}.achievements.domainCards.${card.key}.uuid`] = null;
        });

        await this.levelup.updateSource(update);
        this.render();
    }

    static async selectSubclass(_, button) {
        const option = foundry.utils.getProperty(this.levelup, button.dataset.path);
        const subclass = option.secondaryData.subclass ? null : button.dataset.subclass;

        await this.levelup.updateSource({
            [`${button.dataset.path}.secondaryData.subclass`]: subclass
        });
        this.render();
    }

    static async updateCurrentLevel(_, button) {
        if (!button.dataset.forward) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.delevel.title')
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.delevel.content')
            });

            if (!confirmed) return;

            await this.levelup.updateSource({
                currentLevel: Math.min(this.levelup.currentLevel - 1, this.levelup.startLevel),
                levels: Object.keys(this.levelup.levels).reduce((acc, key) => {
                    const level = this.levelup.levels[key];
                    if (Number(key) === this.levelup.currentLevel) {
                        acc[key] = {
                            achievements: {
                                experiences: getDeleteKeys(level.achievements.experiences, 'name', ''),
                                domainCards: getDeleteKeys(level.achievements.domainCards, 'uuid', null)
                            },
                            choices: getDeleteKeys(level.choices)
                        };
                    }
                    return acc;
                }, {})
            });
        } else {
            await this.levelup.updateSource({
                currentLevel: Math.min(this.levelup.currentLevel + 1, this.levelup.endLevel)
            });
        }

        this.tabGroups.primary = 'advancements';
        this.render();
    }

    static activatePart(_, button) {
        this.tabGroups.primary = button.dataset.part;
        this.render();
    }

    static async save(_, button) {
        button.disabled = true;

        const levelupData = Object.keys(this.levelup.levels).reduce((acc, level) => {
            if (level >= this.levelup.startLevel) {
                acc[level] = this.levelup.levels[level].toObject();
            }

            return acc;
        }, {});

        await this.actor.levelUp(levelupData);
        if (this.itemBrowser) this.itemBrowser.close();
        this.close();
    }
}

class DhLevelTiers extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tiers: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelTier))
        };
    }

    get availableChoicesPerLevel() {
        return Object.values(this.tiers).reduce((acc, tier) => {
            for (var level = tier.levels.start; level < tier.levels.end + 1; level++) {
                acc[level] = tier.availableOptions;
            }

            return acc;
        }, {});
    }
}

class DhLevelTier extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tier: new fields.NumberField({ required: true, integer: true }),
            name: new fields.StringField({ required: true }),
            levels: new fields.SchemaField({
                start: new fields.NumberField({ required: true, integer: true }),
                end: new fields.NumberField({ required: true, integer: true })
            }),
            initialAchievements: new fields.SchemaField({
                experience: new fields.SchemaField({
                    nr: new fields.NumberField({ required: true, initial: 1 }),
                    modifier: new fields.NumberField({ required: true, initial: 2 })
                }),
                proficiency: new fields.NumberField({ integer: true, initial: 1 })
            }),
            availableOptions: new fields.NumberField({ required: true, initial: 2 }),
            domainCardByLevel: new fields.NumberField({ initial: 1 }),
            options: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelOption))
        };
    }
}

class DhLevelOption extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            label: new fields.StringField({ required: true }),
            checkboxSelections: new fields.NumberField({ required: true, integer: true, initial: 1 }),
            minCost: new fields.NumberField({ required: true, integer: true, initial: 1 }),
            type: new fields.StringField({ required: true, choices: LevelOptionType }),
            value: new fields.NumberField({ integer: true }),
            amount: new fields.NumberField({ integer: true })
        };
    }
}

const CompanionLevelOptionType = {
    hope: {
        id: 'hope',
        label: 'Light In The Dark'
    },
    creatureComfort: {
        id: 'creatureComfort',
        label: 'Creature Comfort',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.creatureComfort.name',
                img: 'icons/magic/life/heart-cross-purple-orange.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.creatureComfort.description',
                toPartner: true
            }
        ]
    },
    armored: {
        id: 'armored',
        label: 'Armored',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.armored.name',
                img: 'icons/equipment/shield/kite-wooden-oak-glow.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.armored.description',
                toPartner: true
            }
        ]
    },
    vicious: {
        id: 'vicious',
        label: 'Viscious'
    },
    resilient: {
        id: 'resilient',
        label: 'Resilient'
    },
    bonded: {
        id: 'bonded',
        label: 'Bonded',
        features: [
            {
                name: 'DAGGERHEART.APPLICATIONS.Levelup.actions.bonded.name',
                img: 'icons/magic/life/heart-red-blue.webp',
                description: 'DAGGERHEART.APPLICATIONS.Levelup.actions.bonded.description',
                toPartner: true
            }
        ]
    },
    aware: {
        id: 'aware',
        label: 'Aware'
    }
};

const LevelOptionType = {
    trait: {
        id: 'trait',
        label: 'Character Trait',
        dataPath: ''
    },
    hitPoint: {
        id: 'hitPoint',
        label: 'Hit Points',
        dataPath: 'resources.hitPoints',
        dataPathData: {
            property: 'max',
            dependencies: ['value']
        }
    },
    stress: {
        id: 'stress',
        label: 'Stress',
        dataPath: 'resources.stress',
        dataPathData: {
            property: 'max',
            dependencies: ['value']
        }
    },
    evasion: {
        id: 'evasion',
        label: 'Evasion',
        dataPath: 'evasion'
    },
    proficiency: {
        id: 'proficiency',
        label: 'Proficiency'
    },
    experience: {
        id: 'experience',
        label: 'Experience'
    },
    domainCard: {
        id: 'domainCard',
        label: 'Domain Card'
    },
    subclass: {
        id: 'subclass',
        label: 'Subclass'
    },
    multiclass: {
        id: 'multiclass',
        label: 'Multiclass'
    },
    ...CompanionLevelOptionType
};

const defaultLevelTiers = {
    tiers: {
        2: {
            tier: 2,
            name: 'Tier 2',
            levels: {
                start: 2,
                end: 4
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                }
            }
        },
        3: {
            tier: 3,
            name: 'Tier 3',
            levels: {
                start: 5,
                end: 7
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                },
                subclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.subclass',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.subclass.id
                },
                proficiency: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.proficiency',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.proficiency.id,
                    value: 1
                },
                multiclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.multiclass',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.multiclass.id
                }
            }
        },
        4: {
            tier: 4,
            name: 'Tier 4',
            levels: {
                start: 8,
                end: 10
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                },
                proficiency: 1
            },
            availableOptions: 2,
            domainCardByLevel: 1,
            options: {
                trait: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.trait',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.trait.id,
                    amount: 2
                },
                hitPoint: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.hitPoint',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.hitPoint.id,
                    value: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.stress',
                    checkboxSelections: 2,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.experience',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 2
                },
                domainCard: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.domainCard',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.domainCard.id,
                    amount: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.evasion',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 1
                },
                subclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.subclass',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: LevelOptionType.subclass.id
                },
                proficiency: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.proficiency',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.proficiency.id,
                    value: 1
                },
                multiclass: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.multiclass',
                    checkboxSelections: 2,
                    minCost: 2,
                    type: LevelOptionType.multiclass.id
                }
            }
        }
    }
};

const defaultCompanionTier = {
    tiers: {
        2: {
            tier: 2,
            name: 'Companion Choices',
            levels: {
                start: 2,
                end: 10
            },
            initialAchievements: {
                experience: {
                    nr: 1,
                    modifier: 2
                }
            },
            /* Improved this. Quick solution for companions */
            extraAchievements: {
                5: {
                    experience: {
                        nr: 1,
                        modifier: 2
                    }
                },
                8: {
                    experience: {
                        nr: 1,
                        modifier: 2
                    }
                }
            },
            availableOptions: 1,
            domainCardByLevel: 0,
            options: {
                experience: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.intelligent',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.experience.id,
                    value: 1,
                    amount: 1
                },
                hope: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.lightInTheDark',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.hope.id,
                    value: 1
                },
                creatureComfort: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.creatureComfort',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.creatureComfort.id,
                    value: 1
                },
                armored: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.armored',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.armored.id,
                    value: 1
                },
                vicious: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.vicious',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: CompanionLevelOptionType.vicious.id,
                    value: 1,
                    amount: 1
                },
                stress: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.resilient',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.stress.id,
                    value: 1
                },
                bonded: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.bonded',
                    checkboxSelections: 1,
                    minCost: 1,
                    type: CompanionLevelOptionType.bonded.id,
                    value: 1
                },
                evasion: {
                    label: 'DAGGERHEART.APPLICATIONS.Levelup.options.aware',
                    checkboxSelections: 3,
                    minCost: 1,
                    type: LevelOptionType.evasion.id,
                    value: 2,
                    amount: 1
                }
            }
        }
    }
};

class DhLevelup extends foundry.abstract.DataModel {
    static initializeData(levelTierData, pcLevelData) {
        const startLevel = pcLevelData.level.current + 1;
        const currentLevel = pcLevelData.level.current + 1;
        const endLevel = pcLevelData.level.changed;

        const tiers = {};
        const levels = {};
        const tierKeys = Object.keys(levelTierData.tiers);
        tierKeys.forEach(key => {
            const tier = levelTierData.tiers[key];
            const belongingLevels = [];
            for (var i = tier.levels.start; i <= tier.levels.end; i++) {
                if (i <= endLevel) {
                    const initialAchievements = i === tier.levels.start ? tier.initialAchievements : {};
                    const experiences = initialAchievements.experience
                        ? [...Array(initialAchievements.experience.nr).keys()].reduce((acc, _) => {
                              acc[foundry.utils.randomID()] = {
                                  name: '',
                                  modifier: initialAchievements.experience.modifier
                              };
                              return acc;
                          }, {})
                        : {};

                    const domainCards = [...Array(tier.domainCardByLevel).keys()].reduce((acc, _) => {
                        const id = foundry.utils.randomID();
                        acc[id] = { uuid: null, itemUuid: null, level: i };
                        return acc;
                    }, {});

                    levels[i] = DhLevelupLevel.initializeData(pcLevelData.levelups[i], tier.maxSelections[i], {
                        ...initialAchievements,
                        experiences,
                        domainCards
                    });
                }

                belongingLevels.push(i);
            }

            /* Improve. Temporary handling for Companion new experiences */
            Object.keys(tier.extraAchievements ?? {}).forEach(key => {
                const level = Number(key);
                if (level >= startLevel && level <= endLevel) {
                    const levelExtras = tier.extraAchievements[level];
                    if (levelExtras.experience) {
                        levels[level].achievements.experiences[foundry.utils.randomID()] = {
                            name: '',
                            modifier: levelExtras.experience.modifier
                        };
                    }
                }
            });

            tiers[key] = {
                name: tier.name,
                belongingLevels: belongingLevels,
                options: Object.keys(tier.options).reduce((acc, key) => {
                    acc[key] = tier.options[key].toObject?.() ?? tier.options[key];
                    return acc;
                }, {})
            };
        });

        return {
            tiers,
            levels,
            startLevel,
            currentLevel,
            endLevel
        };
    }

    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            tiers: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({ required: true }),
                    belongingLevels: new fields.ArrayField(new fields.NumberField({ required: true, integer: true })),
                    options: new fields.TypedObjectField(
                        new fields.SchemaField({
                            label: new fields.StringField({ required: true }),
                            checkboxSelections: new fields.NumberField({ required: true, integer: true }),
                            minCost: new fields.NumberField({ required: true, integer: true }),
                            type: new fields.StringField({ required: true, choices: LevelOptionType }),
                            value: new fields.NumberField({ integer: true }),
                            amount: new fields.NumberField({ integer: true })
                        })
                    )
                })
            ),
            levels: new fields.TypedObjectField(new fields.EmbeddedDataField(DhLevelupLevel)),
            startLevel: new fields.NumberField({ required: true, integer: true }),
            currentLevel: new fields.NumberField({ required: true, integer: true }),
            endLevel: new fields.NumberField({ required: true, integer: true })
        };
    }

    #levelFinished(levelKey) {
        const allSelectionsMade = this.levels[levelKey].nrSelections.available === 0;
        const allChoicesMade = Object.keys(this.levels[levelKey].choices).every(choiceKey => {
            const choice = this.levels[levelKey].choices[choiceKey];
            return Object.values(choice).every(checkbox => {
                switch (choiceKey) {
                    case 'trait':
                    case 'experience':
                    case 'domainCard':
                    case 'subclass':
                    case 'vicious':
                        return checkbox.data.length === (checkbox.amount ?? 1);
                    case 'multiclass':
                        const classSelected = checkbox.data.length === 1;
                        const domainSelected = checkbox.secondaryData.domain;
                        const subclassSelected = checkbox.secondaryData.subclass;
                        return classSelected && domainSelected && subclassSelected;
                    default:
                        return true;
                }
            });
        });
        const experiencesSelected = !this.levels[levelKey].achievements.experiences
            ? true
            : Object.values(this.levels[levelKey].achievements.experiences).every(exp => exp.name);
        const domainCardsSelected = Object.values(this.levels[levelKey].achievements.domainCards)
            .filter(x => x.level <= this.endLevel)
            .every(card => card.uuid);
        const allAchievementsSelected = experiencesSelected && domainCardsSelected;

        return allSelectionsMade && allChoicesMade && allAchievementsSelected;
    }

    get currentLevelFinished() {
        return this.#levelFinished(this.currentLevel);
    }

    get allLevelsFinished() {
        return Object.keys(this.levels)
            .filter(level => Number(level) >= this.startLevel)
            .every(this.#levelFinished.bind(this));
    }

    get unmarkedTraits() {
        const possibleLevels = Object.values(this.tiers).reduce((acc, tier) => {
            if (tier.belongingLevels.includes(this.currentLevel)) acc = tier.belongingLevels;
            return acc;
        }, []);

        return Object.keys(this.levels)
            .filter(key => possibleLevels.some(x => x === Number(key)))
            .reduce(
                (acc, levelKey) => {
                    const level = this.levels[levelKey];
                    Object.values(level.choices).forEach(choice =>
                        Object.values(choice).forEach(checkbox => {
                            if (
                                checkbox.type === 'trait' &&
                                checkbox.data.length > 0 &&
                                Number(levelKey) !== this.currentLevel
                            ) {
                                checkbox.data.forEach(data => delete acc[data]);
                            }
                        })
                    );

                    return acc;
                },
                { ...abilities }
            );
    }

    get classUpgradeChoices() {
        let subclasses = [];
        let multiclass = null;
        Object.keys(this.levels).forEach(levelKey => {
            const level = this.levels[levelKey];
            Object.values(level.choices).forEach(choice => {
                Object.values(choice).forEach(checkbox => {
                    if (checkbox.type === 'multiclass') {
                        multiclass = {
                            class: checkbox.data.length > 0 ? checkbox.data[0] : null,
                            domain: checkbox.secondaryData.domain ?? null,
                            subclass: checkbox.secondaryData.subclass ?? null,
                            tier: checkbox.tier,
                            level: levelKey
                        };
                    }
                    if (checkbox.type === 'subclass') {
                        subclasses.push({
                            tier: checkbox.tier,
                            level: levelKey
                        });
                    }
                });
            });
        });
        return { subclasses, multiclass };
    }

    get tiersForRendering() {
        const tierKeys = Object.keys(this.tiers);
        const selections = Object.keys(this.levels).reduce(
            (acc, key) => {
                const level = this.levels[key];
                Object.keys(level.choices).forEach(optionKey => {
                    const choice = level.choices[optionKey];
                    Object.keys(choice).forEach(checkboxNr => {
                        const checkbox = choice[checkboxNr];
                        if (!acc[checkbox.tier][optionKey]) acc[checkbox.tier][optionKey] = {};
                        Object.keys(choice).forEach(checkboxNr => {
                            acc[checkbox.tier][optionKey][checkboxNr] = { ...checkbox, level: Number(key) };
                        });
                    });
                });

                return acc;
            },
            tierKeys.reduce((acc, key) => {
                acc[key] = {};
                return acc;
            }, {})
        );

        const { multiclass, subclasses } = this.classUpgradeChoices;
        return tierKeys.map((tierKey, tierIndex) => {
            const tier = this.tiers[tierKey];
            const multiclassInTier = multiclass?.tier === Number(tierKey);
            const subclassInTier = subclasses.some(x => x.tier === Number(tierKey));

            return {
                name: tier.name,
                active: this.currentLevel >= Math.min(...tier.belongingLevels),
                groups: Object.keys(tier.options).map(optionKey => {
                    const option = tier.options[optionKey];

                    const checkboxes = [...Array(option.checkboxSelections).keys()].flatMap(index => {
                        const checkboxNr = index + 1;
                        const checkboxData = selections[tierKey]?.[optionKey]?.[checkboxNr];
                        const checkbox = { ...option, checkboxNr, tier: tierKey };

                        if (checkboxData) {
                            checkbox.level = checkboxData.level;
                            checkbox.selected = true;
                            checkbox.disabled = checkbox.level !== this.currentLevel;
                        }

                        if (optionKey === 'multiclass') {
                            if ((multiclass && !multiclassInTier) || subclassInTier) {
                                checkbox.disabled = true;
                            }
                        }

                        if (optionKey === 'subclass' && multiclassInTier) {
                            checkbox.disabled = true;
                        }

                        return checkbox;
                    });

                    let label = game.i18n.localize(option.label);
                    if (optionKey === 'domainCard') {
                        const maxLevel = tier.belongingLevels[tier.belongingLevels.length - 1];
                        label = game.i18n.format(option.label, { maxLevel });
                    }

                    return {
                        label: label,
                        checkboxGroups: chunkify(checkboxes, option.minCost, chunkedBoxes => {
                            const anySelected = chunkedBoxes.some(x => x.selected);
                            const anyDisabled = chunkedBoxes.some(x => x.disabled);
                            return {
                                multi: option.minCost > 1,
                                checkboxes: chunkedBoxes.map(x => ({
                                    ...x,
                                    selected: anySelected,
                                    disabled: anyDisabled
                                }))
                            };
                        })
                    };
                })
            };
        });
    }
}

class DhLevelupLevel extends foundry.abstract.DataModel {
    static initializeData(levelData = { selections: [] }, maxSelections, achievements) {
        return {
            maxSelections: maxSelections,
            achievements: {
                experiences: levelData.achievements?.experiences ?? achievements.experiences ?? {},
                domainCards: levelData.achievements?.domainCards
                    ? levelData.achievements.domainCards.reduce((acc, card, index) => {
                          acc[index] = { ...card };
                          return acc;
                      }, {})
                    : (achievements.domainCards ?? {}),
                proficiency: levelData.achievements?.proficiency ?? achievements.proficiency ?? null
            },
            choices: levelData.selections.reduce((acc, data) => {
                if (!acc[data.optionKey]) acc[data.optionKey] = {};
                acc[data.optionKey][data.checkboxNr] = { ...data };

                return acc;
            }, {})
        };
    }

    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            maxSelections: new fields.NumberField({ required: true, integer: true }),
            achievements: new fields.SchemaField({
                experiences: new fields.TypedObjectField(
                    new fields.SchemaField({
                        name: new fields.StringField({ required: true }),
                        modifier: new fields.NumberField({ required: true, integer: true })
                    })
                ),
                domainCards: new fields.TypedObjectField(
                    new fields.SchemaField({
                        uuid: new fields.StringField({ required: true, nullable: true, initial: null }),
                        itemUuid: new fields.StringField({ required: true }),
                        level: new fields.NumberField({ required: true, integer: true })
                    })
                ),
                proficiency: new fields.NumberField({ integer: true })
            }),
            choices: new fields.TypedObjectField(
                new fields.TypedObjectField(
                    new fields.SchemaField({
                        tier: new fields.NumberField({ required: true, integer: true }),
                        minCost: new fields.NumberField({ required: true, integer: true }),
                        amount: new fields.NumberField({ integer: true }),
                        value: new fields.StringField(),
                        data: new fields.ArrayField(new fields.StringField()),
                        secondaryData: new fields.TypedObjectField(new fields.StringField()),
                        type: new fields.StringField({ required: true })
                    })
                )
            )
        };
    }

    get nrSelections() {
        const selections = Object.keys(this.choices).reduce((acc, choiceKey) => {
            const choice = this.choices[choiceKey];
            acc += Object.values(choice).reduce((acc, x) => acc + x.minCost, 0);

            return acc;
        }, 0);

        return {
            selections: selections,
            available: this.maxSelections - selections
        };
    }
}

class DhCharacterLevelUp extends DhlevelUp {
    constructor(actor) {
        super(actor);

        this.levelTiers = this.addBonusChoices(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers)
        );
        const playerLevelupData = actor.system.levelData;
        this.levelup = new DhLevelup(DhLevelup.initializeData(this.levelTiers, playerLevelupData));
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'selections':
                const advancementChoices = Object.keys(currentLevel.choices).reduce((acc, choiceKey) => {
                    Object.keys(currentLevel.choices[choiceKey]).forEach(checkboxNr => {
                        const checkbox = currentLevel.choices[choiceKey][checkboxNr];
                        const data = {
                            ...checkbox,
                            path: `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}`,
                            level: this.levelup.currentLevel
                        };

                        if (!acc[choiceKey]) acc[choiceKey] = [];
                        acc[choiceKey].push(data);
                    });

                    return acc;
                }, {});

                const traits = Object.values(advancementChoices.trait ?? {});
                const traitValues = traits.filter(trait => trait.data.length > 0).flatMap(trait => trait.data);
                context.traits = {
                    values: traitValues,
                    active: traits.length > 0,
                    progress: {
                        selected: traitValues.length,
                        max: traits.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                const experienceIncreases = Object.values(advancementChoices.experience ?? {});
                const experienceIncreaseValues = experienceIncreases
                    .filter(exp => exp.data.length > 0)
                    .flatMap(exp => exp.data);
                context.experienceIncreases = {
                    values: experienceIncreaseValues,
                    active: experienceIncreases.length > 0,
                    progress: {
                        selected: experienceIncreaseValues.length,
                        max: experienceIncreases.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                context.newExperiences = Object.keys(currentLevel.achievements.experiences).map(key => {
                    const experience = currentLevel.achievements.experiences[key];
                    return {
                        ...experience,
                        level: this.levelup.currentLevel,
                        key: key
                    };
                });

                const allDomainCards = {
                    ...advancementChoices.domainCard,
                    ...currentLevel.achievements.domainCards
                };
                const allDomainCardKeys = Object.keys(allDomainCards);

                const classDomainsData = this.actor.system.class.value.system.domains.map(domain => ({
                    domain,
                    multiclass: false
                }));
                const multiclassDomainsData = (this.actor.system.multiclass?.value?.system?.domains ?? []).map(
                    domain => ({ domain, multiclass: true })
                );
                const domainsData = [...classDomainsData, ...multiclassDomainsData];
                const multiclassDomain = this.levelup.classUpgradeChoices?.multiclass?.domain;
                if (multiclassDomain) {
                    if (!domainsData.some(x => x.domain === multiclassDomain))
                        domainsData.push({ domain: multiclassDomain, multiclass: true });
                }

                context.domainCards = [];
                for (var key of allDomainCardKeys) {
                    const domainCard = allDomainCards[key];
                    if (domainCard.level > this.levelup.endLevel) continue;

                    const uuid = domainCard.data?.length > 0 ? domainCard.data[0] : domainCard.uuid;
                    const card = uuid ? await foundry.utils.fromUuid(uuid) : {};

                    context.domainCards.push({
                        ...(card.toObject?.() ?? card),
                        emptySubtexts: domainsData.map(domain => {
                            const levelBase = domain.multiclass
                                ? Math.ceil(this.levelup.currentLevel / 2)
                                : this.levelup.currentLevel;
                            const levelMax = domainCard.secondaryData?.limit
                                ? Math.min(domainCard.secondaryData.limit, levelBase)
                                : levelBase;

                            return game.i18n.format('DAGGERHEART.APPLICATIONS.Levelup.selections.emptyDomainCardHint', {
                                domain: game.i18n.localize(CONFIG.DH.DOMAIN.allDomains()[domain.domain].label),
                                level: levelMax
                            });
                        }),
                        path: domainCard.data
                            ? `${domainCard.path}.data`
                            : `levels.${domainCard.level}.achievements.domainCards.${key}.uuid`,
                        limit: domainCard.secondaryData?.limit ?? null,
                        compendium: 'domains'
                    });
                }

                const subclassSelections = advancementChoices.subclass?.flatMap(x => x.data) ?? [];
                const possibleSubclasses = [this.actor.system.class.subclass];
                if (this.actor.system.multiclass?.subclass) {
                    possibleSubclasses.push(this.actor.system.multiclass.subclass);
                }

                context.subclassCards = [];
                if (advancementChoices.subclass?.length > 0) {
                    const featureStateIncrease = Object.values(this.levelup.levels).reduce((acc, level) => {
                        acc += Object.values(level.choices).filter(choice => {
                            return Object.values(choice).every(checkbox => checkbox.type === 'subclass');
                        }).length;
                        return acc;
                    }, 0);

                    for (var subclass of possibleSubclasses) {
                        const choice =
                            advancementChoices.subclass.find(x => x.data[0] === subclass.uuid) ??
                            advancementChoices.subclass.find(x => x.data.length === 0);
                        const featureState = subclass.system.featureState + featureStateIncrease;
                        const data = await foundry.utils.fromUuid(subclass.uuid);
                        context.subclassCards.push({
                            ...data.toObject(),
                            path: choice?.path,
                            uuid: data.uuid,
                            selected: subclassSelections.includes(subclass.uuid),
                            featureState: featureState,
                            featureLabel: game.i18n.localize(subclassFeatureLabels[featureState]),
                            isMulticlass: subclass.system.isMulticlass ? 'true' : 'false'
                        });
                    }
                }

                const multiclasses = Object.values(advancementChoices.multiclass ?? {});
                if (multiclasses?.[0]) {
                    const data = multiclasses[0];
                    const multiclass = data.data.length > 0 ? await foundry.utils.fromUuid(data.data[0]) : {};

                    context.multiclass = {
                        ...data,
                        ...(multiclass.toObject?.() ?? multiclass),
                        type: 'multiclass',
                        uuid: multiclass.uuid,
                        domains:
                            multiclass?.system?.domains.map(key => {
                                const domain = CONFIG.DH.DOMAIN.allDomains()[key];
                                const alreadySelected = this.actor.system.class.value.system.domains.includes(key);

                                return {
                                    ...domain,
                                    selected: key === data.secondaryData.domain,
                                    disabled:
                                        (data.secondaryData.domain && key !== data.secondaryData.domain) ||
                                        alreadySelected
                                };
                            }) ?? [],
                        subclasses:
                            multiclass?.system?.subclasses.map(subclass => ({
                                ...subclass,
                                uuid: subclass.uuid,
                                selected: data.secondaryData.subclass === subclass.uuid,
                                disabled: data.secondaryData.subclass && data.secondaryData.subclass !== subclass.uuid
                            })) ?? [],
                        compendium: 'classes',
                        limit: 1
                    };
                }

                break;
            case 'summary':
                const { current: currentActorLevel, changed: changedActorLevel } = this.actor.system.levelData.level;
                const actorArmor = this.actor.system.armor;
                const levelKeys = Object.keys(this.levelup.levels);
                let achivementProficiency = 0;
                const achievementCards = [];
                let achievementExperiences = [];
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    achivementProficiency += level.achievements.proficiency ?? 0;
                    const cards = level.achievements.domainCards ? Object.values(level.achievements.domainCards) : null;
                    if (cards) {
                        for (var card of cards) {
                            const itemCard = await foundry.utils.fromUuid(card.uuid);
                            achievementCards.push(itemCard);
                        }
                    }

                    achievementExperiences = level.achievements.experiences
                        ? Object.values(level.achievements.experiences).reduce((acc, experience) => {
                              if (experience.name) acc.push(experience);
                              return acc;
                          }, [])
                        : [];
                }

                context.achievements = {
                    proficiency: {
                        old: this.actor.system.proficiency,
                        new: this.actor.system.proficiency + achivementProficiency,
                        shown: achivementProficiency > 0
                    },
                    damageThresholds: {
                        major: {
                            old: this.actor.system.damageThresholds.major,
                            new: this.actor.system.damageThresholds.major + changedActorLevel - currentActorLevel
                        },
                        severe: {
                            old: this.actor.system.damageThresholds.severe,
                            new:
                                this.actor.system.damageThresholds.severe +
                                (actorArmor
                                    ? changedActorLevel - currentActorLevel
                                    : (changedActorLevel - currentActorLevel) * 2)
                        },
                        unarmored: !actorArmor
                    },
                    domainCards: {
                        values: achievementCards,
                        shown: achievementCards.length > 0
                    },
                    experiences: {
                        values: achievementExperiences,
                        shown: achievementExperiences.length > 0
                    }
                };

                const advancement = {};
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    for (var choiceKey of Object.keys(level.choices)) {
                        const choice = level.choices[choiceKey];
                        for (var checkbox of Object.values(choice)) {
                            switch (choiceKey) {
                                case 'proficiency':
                                case 'hitPoint':
                                case 'stress':
                                case 'evasion':
                                    advancement[choiceKey] = advancement[choiceKey]
                                        ? advancement[choiceKey] + Number(checkbox.value)
                                        : Number(checkbox.value);
                                    break;
                                case 'trait':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = {};
                                    for (var traitKey of checkbox.data) {
                                        if (!advancement[choiceKey][traitKey]) advancement[choiceKey][traitKey] = 0;
                                        advancement[choiceKey][traitKey] += 1;
                                    }
                                    break;
                                case 'domainCard':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    if (checkbox.data.length === 1) {
                                        const choiceItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                        advancement[choiceKey].push(choiceItem.toObject());
                                    }
                                    break;
                                case 'experience':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    const data = checkbox.data.map(data => {
                                        const experience = Object.keys(this.actor.system.experiences).find(
                                            x => x === data
                                        );
                                        return this.actor.system.experiences[experience]?.name ?? '';
                                    });
                                    advancement[choiceKey].push({ data: data, value: checkbox.value });
                                    break;
                                case 'subclass':
                                    if (checkbox.data[0]) {
                                        const subclassItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                        if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                        advancement[choiceKey].push({
                                            ...subclassItem.toObject(),
                                            featureLabel: game.i18n.localize(
                                                subclassFeatureLabels[Number(checkbox.secondaryData.featureState)]
                                            )
                                        });
                                    }
                                    break;
                                case 'multiclass':
                                    const multiclassItem = await foundry.utils.fromUuid(checkbox.data[0]);
                                    const subclass = multiclassItem
                                        ? await foundry.utils.fromUuid(checkbox.secondaryData.subclass)
                                        : null;
                                    advancement[choiceKey] = multiclassItem
                                        ? {
                                              ...multiclassItem.toObject(),
                                              domain: checkbox.secondaryData.domain
                                                  ? game.i18n.localize(
                                                        CONFIG.DH.DOMAIN.allDomains()[checkbox.secondaryData.domain]
                                                            .label
                                                    )
                                                  : null,
                                              subclass: subclass ? subclass.name : null
                                          }
                                        : {};
                                    break;
                            }
                        }
                    }
                }

                context.advancements = {
                    statistics: {
                        proficiency: {
                            old: context.achievements.proficiency.new,
                            new: context.achievements.proficiency.new + (advancement.proficiency ?? 0)
                        },
                        hitPoints: {
                            old: this.actor.system.resources.hitPoints.max,
                            new: this.actor.system.resources.hitPoints.max + (advancement.hitPoint ?? 0)
                        },
                        stress: {
                            old: this.actor.system.resources.stress.max,
                            new: this.actor.system.resources.stress.max + (advancement.stress ?? 0)
                        },
                        evasion: {
                            old: this.actor.system.evasion,
                            new: this.actor.system.evasion + (advancement.evasion ?? 0)
                        }
                    },
                    traits: Object.keys(this.actor.system.traits).reduce((acc, traitKey) => {
                        if (advancement.trait?.[traitKey]) {
                            if (!acc) acc = {};
                            acc[traitKey] = {
                                label: game.i18n.localize(abilities[traitKey].label),
                                old: this.actor.system.traits[traitKey].value,
                                new: this.actor.system.traits[traitKey].value + advancement.trait[traitKey]
                            };
                        }
                        return acc;
                    }, null),
                    domainCards: advancement.domainCard ?? [],
                    experiences:
                        advancement.experience?.flatMap(x => x.data.map(data => ({ name: data, modifier: x.value }))) ??
                        [],
                    multiclass: advancement.multiclass,
                    subclass: advancement.subclass
                };

                context.advancements.statistics.proficiency.shown =
                    context.advancements.statistics.proficiency.new > context.advancements.statistics.proficiency.old;
                context.advancements.statistics.hitPoints.shown =
                    context.advancements.statistics.hitPoints.new > context.advancements.statistics.hitPoints.old;
                context.advancements.statistics.stress.shown =
                    context.advancements.statistics.stress.new > context.advancements.statistics.stress.old;
                context.advancements.statistics.evasion.shown =
                    context.advancements.statistics.evasion.new > context.advancements.statistics.evasion.old;
                context.advancements.statistics.shown =
                    context.advancements.statistics.proficiency.shown ||
                    context.advancements.statistics.hitPoints.shown ||
                    context.advancements.statistics.stress.shown ||
                    context.advancements.statistics.evasion.shown;

                break;
        }

        return context;
    }
}

class DhCompanionLevelUp extends DhlevelUp {
    constructor(actor) {
        super(actor);

        this.levelTiers = this.addBonusChoices(defaultCompanionTier);
        const playerLevelupData = actor.system.levelData;
        this.levelup = new DhLevelup(DhLevelup.initializeData(this.levelTiers, playerLevelupData));
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        const currentLevel = this.levelup.levels[this.levelup.currentLevel];
        switch (partId) {
            case 'selections':
                const advancementChoices = Object.keys(currentLevel.choices).reduce((acc, choiceKey) => {
                    Object.keys(currentLevel.choices[choiceKey]).forEach(checkboxNr => {
                        const checkbox = currentLevel.choices[choiceKey][checkboxNr];
                        const data = {
                            ...checkbox,
                            path: `levels.${this.levelup.currentLevel}.choices.${choiceKey}.${checkboxNr}`,
                            level: this.levelup.currentLevel
                        };

                        if (!acc[choiceKey]) acc[choiceKey] = [];
                        acc[choiceKey].push(data);
                    });

                    return acc;
                }, {});

                const experienceIncreases = Object.values(advancementChoices.experience ?? {});
                const experienceIncreaseValues = experienceIncreases
                    .filter(exp => exp.data.length > 0)
                    .flatMap(exp => exp.data);
                context.experienceIncreases = {
                    values: experienceIncreaseValues,
                    active: experienceIncreases.length > 0,
                    progress: {
                        selected: experienceIncreaseValues.length,
                        max: experienceIncreases.reduce((acc, exp) => acc + exp.amount, 0)
                    }
                };

                context.newExperiences = Object.keys(currentLevel.achievements.experiences).map(key => {
                    const experience = currentLevel.achievements.experiences[key];
                    return {
                        ...experience,
                        level: this.levelup.currentLevel,
                        key: key
                    };
                });

                context.vicious = advancementChoices.vicious ? Object.values(advancementChoices.vicious) : null;
                context.viciousChoices = {
                    damage: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.selections.viciousDamage'),
                    range: game.i18n.localize('DAGGERHEART.APPLICATIONS.Levelup.selections.viciousRange')
                };

                break;
            case 'summary':
                const levelKeys = Object.keys(this.levelup.levels);
                const actorDamageDice = this.actor.system.attack.damage.parts[0].value.dice;
                const actorRange = this.actor.system.attack.range;

                let achievementExperiences = [];
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    achievementExperiences = level.achievements.experiences
                        ? Object.values(level.achievements.experiences).reduce((acc, experience) => {
                              if (experience.name) acc.push(experience);
                              return acc;
                          }, [])
                        : [];
                }
                context.achievements = {
                    experiences: {
                        values: achievementExperiences,
                        shown: achievementExperiences.length > 0
                    }
                };

                context.achievements = context.achievements.experiences.shown ? context.achievements : undefined;

                const advancement = {};
                for (var levelKey of levelKeys) {
                    const level = this.levelup.levels[levelKey];
                    if (Number(levelKey) < this.levelup.startLevel) continue;

                    for (var choiceKey of Object.keys(level.choices)) {
                        const choice = level.choices[choiceKey];
                        for (var checkbox of Object.values(choice)) {
                            switch (choiceKey) {
                                case 'stress':
                                case 'evasion':
                                    advancement[choiceKey] = advancement[choiceKey]
                                        ? advancement[choiceKey] + Number(checkbox.value)
                                        : Number(checkbox.value);
                                    break;
                                case 'experience':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = [];
                                    const data = checkbox.data.map(data => {
                                        const experience = Object.keys(this.actor.system.experiences).find(
                                            x => x === data
                                        );
                                        return this.actor.system.experiences[experience]?.name ?? '';
                                    });
                                    advancement[choiceKey].push({ data: data, value: checkbox.value });
                                    break;
                                case 'vicious':
                                    if (!advancement[choiceKey]) advancement[choiceKey] = { damage: null, range: null };
                                    const isDamage = checkbox.data[0] === 'damage';
                                    const options = isDamage ? diceTypes : range;
                                    const keys = Object.keys(options);
                                    const actorKey = keys.indexOf(isDamage ? actorDamageDice : actorRange);
                                    const currentIndex = advancement[choiceKey][checkbox.data[0]]
                                        ? keys.indexOf(advancement[choiceKey][checkbox.data[0]])
                                        : actorKey;
                                    advancement[choiceKey][checkbox.data[0]] =
                                        options[keys[Math.min(currentIndex + 1, keys.length - 1)]];
                                default:
                                    if (!advancement.simple) advancement.simple = {};
                                    advancement.simple[choiceKey] = game.i18n.localize(
                                        LevelOptionType[checkbox.type].label
                                    );
                                    break;
                            }
                        }
                    }
                }

                context.advancements = {
                    statistics: {
                        stress: {
                            old: this.actor.system.resources.stress.max,
                            new: this.actor.system.resources.stress.max + (advancement.stress ?? 0)
                        },
                        evasion: {
                            old: this.actor.system.evasion,
                            new: this.actor.system.evasion + (advancement.evasion ?? 0)
                        }
                    },
                    experiences:
                        advancement.experience?.flatMap(x => x.data.map(data => ({ name: data, modifier: x.value }))) ??
                        [],
                    vicious: {
                        damage: advancement.vicious?.damage
                            ? {
                                  old: actorDamageDice,
                                  new: advancement.vicious.damage
                              }
                            : null,
                        range: advancement.vicious?.range
                            ? {
                                  old: game.i18n.localize(`DAGGERHEART.CONFIG.Range.${actorRange}.name`),
                                  new: game.i18n.localize(advancement.vicious.range.label)
                              }
                            : null
                    },
                    simple: advancement.simple ?? {}
                };

                context.advancements.statistics.stress.shown =
                    context.advancements.statistics.stress.new > context.advancements.statistics.stress.old;
                context.advancements.statistics.evasion.shown =
                    context.advancements.statistics.evasion.new > context.advancements.statistics.evasion.old;
                context.advancements.statistics.shown =
                    context.advancements.statistics.stress.shown || context.advancements.statistics.evasion.shown;
        }

        return context;
    }
}

var _module$c = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CharacterLevelup: DhCharacterLevelUp,
    CompanionLevelup: DhCompanionLevelUp,
    Levelup: DhlevelUp
});

class DhAppearance extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            displayFear: new fields.StringField({
                required: true,
                choices: fearDisplay,
                initial: fearDisplay.token.value,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.displayFear.label'
            }),
            diceSoNice: new fields.SchemaField({
                hope: new fields.SchemaField({
                    foreground: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    background: new fields.ColorField({ required: true, initial: '#ffe760' }),
                    outline: new fields.ColorField({ required: true, initial: '#000000' }),
                    edge: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    texture: new fields.StringField({ initial: 'astralsea' }),
                    colorset: new fields.StringField({ initial: 'inspired' }),
                    material: new fields.StringField({ initial: 'metal' }),
                    system: new fields.StringField({ initial: 'standard' })
                }),
                fear: new fields.SchemaField({
                    foreground: new fields.ColorField({ required: true, initial: '#000000' }),
                    background: new fields.ColorField({ required: true, initial: '#0032b1' }),
                    outline: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    edge: new fields.ColorField({ required: true, initial: '#000000' }),
                    texture: new fields.StringField({ initial: 'astralsea' }),
                    colorset: new fields.StringField({ initial: 'inspired' }),
                    material: new fields.StringField({ initial: 'metal' }),
                    system: new fields.StringField({ initial: 'standard' })
                }),
                advantage: new fields.SchemaField({
                    foreground: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    background: new fields.ColorField({ required: true, initial: '#008000' }),
                    outline: new fields.ColorField({ required: true, initial: '#000000' }),
                    edge: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    texture: new fields.StringField({ initial: 'astralsea' }),
                    colorset: new fields.StringField({ initial: 'inspired' }),
                    material: new fields.StringField({ initial: 'metal' }),
                    system: new fields.StringField({ initial: 'standard' })
                }),
                disadvantage: new fields.SchemaField({
                    foreground: new fields.ColorField({ required: true, initial: '#000000' }),
                    background: new fields.ColorField({ required: true, initial: '#b30000' }),
                    outline: new fields.ColorField({ required: true, initial: '#ffffff' }),
                    edge: new fields.ColorField({ required: true, initial: '#000000' }),
                    texture: new fields.StringField({ initial: 'astralsea' }),
                    colorset: new fields.StringField({ initial: 'inspired' }),
                    material: new fields.StringField({ initial: 'metal' }),
                    system: new fields.StringField({ initial: 'standard' })
                })
            }),
            showGenericStatusEffects: new fields.BooleanField({
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.showGenericStatusEffects.label'
            }),
            extendCharacterDescriptions: new fields.BooleanField({
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.extendCharacterDescriptions.label'
            }),
            extendAdversaryDescriptions: new fields.BooleanField({
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.extendAdversaryDescriptions.label'
            }),
            extendEnvironmentDescriptions: new fields.BooleanField({
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.extendEnvironmentDescriptions.label'
            }),
            extendItemDescriptions: new fields.BooleanField({
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Appearance.FIELDS.extendItemDescriptions.label'
            })
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$8, ApplicationV2: ApplicationV2$7 } = foundry.applications.api;

class DHAppearanceSettings extends HandlebarsApplicationMixin$8(ApplicationV2$7) {
    constructor() {
        super({});

        this.settings = new DhAppearance(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance).toObject()
        );
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-appearance-settings',
        classes: ['daggerheart', 'dialog', 'dh-style', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: this.reset,
            save: this.save,
            preview: this.preview
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        main: {
            template: 'systems/daggerheart/templates/settings/appearance-settings.hbs'
        }
    };

    /** @inheritdoc */
    static TABS = {
        diceSoNice: {
            tabs: [
                { id: 'hope', label: 'DAGGERHEART.GENERAL.hope' },
                { id: 'fear', label: 'DAGGERHEART.GENERAL.fear' },
                { id: 'advantage', label: 'DAGGERHEART.GENERAL.Advantage.full' },
                { id: 'disadvantage', label: 'DAGGERHEART.GENERAL.Disadvantage.full' }
            ],
            initial: 'hope'
        }
    };

    changeTab(tab, group, options) {
        super.changeTab(tab, group, options);

        this.render();
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        context.showDiceSoNice = game.modules.get('dice-so-nice')?.active;
        if (game.dice3d) {
            context.diceSoNiceTextures = game.dice3d.exports.TEXTURELIST;
            context.diceSoNiceColorsets = game.dice3d.exports.COLORSETS;
            context.diceSoNiceMaterials = Object.keys(game.dice3d.DiceFactory.material_options).map(key => ({
                key: key,
                name: `DICESONICE.Material${key.capitalize()}`
            }));
            context.diceSoNiceSystems = [];
            for (const [key, system] of game.dice3d.DiceFactory.systems.entries()) {
                context.diceSoNiceSystems.push({ key, name: system.name });
            }
        }

        context.diceTab = {
            key: this.tabGroups.diceSoNice,
            source: this.settings._source.diceSoNice[this.tabGroups.diceSoNice],
            fields: this.settings.schema.fields.diceSoNice.fields[this.tabGroups.diceSoNice].fields
        };

        return context;
    }

    static async updateData(event, element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource(updatedSettings);
        this.render();
    }

    static async preview() {
        const source = this.settings._source.diceSoNice[this.tabGroups.diceSoNice];
        let faces = 'd12';
        switch (this.tabGroups.diceSoNice) {
            case 'advantage':
            case 'disadvantage':
                faces = 'd6';
        }
        const preset = await getDiceSoNicePreset(source, faces);
        const diceSoNiceRoll = await new Roll(`1${faces}`).evaluate();
        diceSoNiceRoll.dice[0].options.appearance = preset.appearance;
        diceSoNiceRoll.dice[0].options.modelFile = preset.modelFile;

        await game.dice3d.showForRoll(diceSoNiceRoll, game.user, false);
    }

    static async reset() {
        this.settings = new DhAppearance();
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, this.settings.toObject());

        this.close();
    }

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }
}

class DhAutomation extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            hopeFear: new fields.SchemaField({
                gm: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hopeFear.gm.label'
                }),
                players: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hopeFear.players.label'
                })
            }),
            levelupAuto: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.levelupAuto.label'
            }),
            actionPoints: new fields.BooleanField({
                required: true,
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.actionPoints.label'
            }),
            hordeDamage: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.hordeDamage.label'
            }),
            effects: new fields.SchemaField({
                rangeDependent: new fields.BooleanField({
                    initial: true,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.effects.rangeDependent.label'
                })
            }),
            damageReductionRulesDefault: new fields.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.ruleChoice,
                initial: CONFIG.DH.GENERAL.ruleChoice.onWithToggle.id,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.damageReductionRulesDefault.label'
            }),
            resourceScrollTexts: new fields.BooleanField({
                required: true,
                initial: true,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.resourceScrollTexts.label'
            }),
            playerCanEditSheet: new fields.BooleanField({
                required: true,
                initial: false,
                label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.playerCanEditSheet.label'
            }),
            defeated: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.enabled.label'
                }),
                overlay: new fields.BooleanField({
                    required: true,
                    initial: true,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.overlay.label'
                }),
                characterDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditions,
                    initial: CONFIG.DH.GENERAL.defeatedConditions.unconscious.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.characterDefault.label'
                }),
                adversaryDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditions,
                    initial: CONFIG.DH.GENERAL.defeatedConditions.defeated.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.adversaryDefault.label'
                }),
                companionDefault: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.defeatedConditions,
                    initial: CONFIG.DH.GENERAL.defeatedConditions.defeated.id,
                    label: 'DAGGERHEART.SETTINGS.Automation.FIELDS.defeated.companionDefault.label'
                })
            })
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$7 } = foundry.applications.api;

//Just used by action config

function DhpApplicationMixin(Base) {
    return class DhpSheetV2 extends HandlebarsApplicationMixin$7(Base) {
        constructor(options = {}) {
            super(options);

            this._dragDrop = this._createDragDropHandlers();
        }

        _attachPartListeners(partId, htmlElement, options) {
            super._attachPartListeners(partId, htmlElement, options);

            this._dragDrop.forEach(d => d.bind(htmlElement));
        }

        static DEFAULT_OPTIONS = {
            position: {
                width: 480,
                height: 'auto'
            },
            actions: {
                onEditImage: this._onEditImage
            },
            dragDrop: []
        };

        async _prepareContext(_options, objectPath = 'document') {
            const context = await super._prepareContext(_options);
            context.source = this[objectPath];
            context.fields = this[objectPath].schema.fields;
            context.systemFields = this[objectPath].system ? this[objectPath].system.schema.fields : {};

            return context;
        }

        static _onEditImage(event, target) {
            const attr = target.dataset.edit;
            const current = foundry.utils.getProperty(this.document, attr);
            const { img } = this.document.constructor.getDefaultArtwork?.(this.document.toObject()) ?? {};
            const fp = new foundry.applications.apps.FilePicker.implementation({
                current,
                type: 'image',
                redirectToRoot: img ? [img] : [],
                callback: async path => this._updateImage.bind(this)(path),
                top: this.position.top + 40,
                left: this.position.left + 10
            });
            return fp.browse();
        }

        async _updateImage(path) {
            await this.document.update({ img: path });
        }

        _createDragDropHandlers() {
            return this.options.dragDrop.map(d => {
                // d.permissions = {
                //   dragstart: this._canDragStart.bind(this),
                //   drop: this._canDragDrop.bind(this)
                // };
                d.callbacks = {
                    dragstart: this._onDragStart.bind(this),
                    // dragover: this._onDragOver.bind(this),
                    drop: this._onDrop.bind(this)
                };
                return new foundry.applications.ux.DragDrop.implementation(d);
            });
        }

        async _onDragStart(event) {}
        _onDrop(event) {}

        _getTabs(tabs) {
            for (const v of Object.values(tabs)) {
                v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
                v.cssClass = v.active ? 'active' : '';
            }

            return tabs;
        }
    };
}

const { ApplicationV2: ApplicationV2$6 } = foundry.applications.api;
class DHActionConfig extends DhpApplicationMixin(ApplicationV2$6) {
    constructor(action, sheetUpdate) {
        super({});

        this.action = action;
        this.sheetUpdate = sheetUpdate;
        this.openSection = null;
    }

    get title() {
        return `${game.i18n.localize('DAGGERHEART.GENERAL.Tabs.settings')}: ${this.action.name}`;
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'dh-style', 'dialog', 'max-800'],
        window: {
            icon: 'fa-solid fa-wrench',
            resizable: false
        },
        position: { width: 600, height: 'auto' },
        actions: {
            toggleSection: this.toggleSection,
            addEffect: this.addEffect,
            removeEffect: this.removeEffect,
            addElement: this.addElement,
            removeElement: this.removeElement,
            editEffect: this.editEffect,
            addDamage: this.addDamage,
            removeDamage: this.removeDamage
        },
        form: {
            handler: this.updateForm,
            submitOnChange: true,
            closeOnSubmit: false
        }
    };

    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        base: {
            id: 'base',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/base.hbs'
        },
        configuration: {
            id: 'configuration',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/configuration.hbs'
        },
        effect: {
            id: 'effect',
            template: 'systems/daggerheart/templates/sheets-settings/action-settings/effect.hbs'
        }
    };

    static TABS = {
        base: {
            active: true,
            cssClass: '',
            group: 'primary',
            id: 'base',
            icon: null,
            label: 'Base'
        },
        config: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'config',
            icon: null,
            label: 'Configuration'
        },
        effect: {
            active: false,
            cssClass: '',
            group: 'primary',
            id: 'effect',
            icon: null,
            label: 'Effect'
        }
    };

    static CLEAN_ARRAYS = ['damage.parts', 'cost', 'effects'];

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options, 'action');
        context.source = this.action.toObject(false);
        context.openSection = this.openSection;
        context.tabs = this._getTabs(this.constructor.TABS);
        context.config = CONFIG.DH;
        if (!!this.action.effects) context.effects = this.action.effects.map(e => this.action.item.effects.get(e._id));
        if (this.action.damage?.hasOwnProperty('includeBase') && this.action.type === 'attack')
            context.hasBaseDamage = !!this.action.parent.attack;
        context.getEffectDetails = this.getEffectDetails.bind(this);
        context.costOptions = this.getCostOptions();
        context.getRollTypeOptions = this.getRollTypeOptions();
        context.disableOption = this.disableOption.bind(this);
        context.isNPC = this.action.actor?.isNPC;
        context.baseSaveDifficulty = this.action.actor?.baseSaveDifficulty;
        context.baseAttackBonus = this.action.actor?.system.attack?.roll.bonus;
        context.hasRoll = this.action.hasRoll;

        const settingsTiers = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers;
        context.tierOptions = [
            { key: 1, label: game.i18n.localize('DAGGERHEART.GENERAL.Tiers.1') },
            ...Object.values(settingsTiers).map(x => ({ key: x.tier, label: x.name }))
        ];
        return context;
    }

    static toggleSection(_, button) {
        this.openSection = button.dataset.section === this.openSection ? null : button.dataset.section;
        this.render(true);
    }

    getCostOptions() {
        const options = foundry.utils.deepClone(CONFIG.DH.GENERAL.abilityCosts);
        const resource = this.action.parent.resource;
        if (resource) {
            options[this.action.parent.parent.id] = {
                label: 'DAGGERHEART.GENERAL.itemResource',
                group: 'Global'
            };
        }

        return options;
    }

    getRollTypeOptions() {
        const types = foundry.utils.deepClone(CONFIG.DH.GENERAL.rollTypes);
        if (!this.action.actor) return types;
        Object.values(types).forEach(t => {
            if (this.action.actor.type !== 'character' && t.playerOnly) delete types[t.id];
        });
        return types;
    }

    disableOption(index, costOptions, choices) {
        const filtered = foundry.utils.deepClone(costOptions);
        Object.keys(filtered).forEach(o => {
            if (choices.find((c, idx) => c.type === o && index !== idx)) filtered[o].disabled = true;
        });
        return filtered;
    }

    getEffectDetails(id) {
        return this.action.item.effects.get(id);
    }

    _prepareSubmitData(_event, formData) {
        const submitData = foundry.utils.expandObject(formData.object);
        for (const keyPath of this.constructor.CLEAN_ARRAYS) {
            const data = foundry.utils.getProperty(submitData, keyPath);
            const dataValues = data ? Object.values(data) : [];
            if (keyPath === 'cost') {
                for (var value of dataValues) {
                    const item = this.action.parent.parent.id === value.key;
                    value.keyIsID = Boolean(item);
                }
            }

            if (data) foundry.utils.setProperty(submitData, keyPath, dataValues);
        }
        return submitData;
    }

    static async updateForm(event, _, formData) {
        const submitData = this._prepareSubmitData(event, formData),
            data = foundry.utils.mergeObject(this.action.toObject(), submitData);
        this.action = await this.action.update(data);

        this.sheetUpdate?.(this.action);
        this.render();
    }

    static addElement(event) {
        const data = this.action.toObject(),
            key = event.target.closest('[data-key]').dataset.key;
        if (!this.action[key]) return;
        data[key].push({});
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static removeElement(event, button) {
        event.stopPropagation();
        const data = this.action.toObject(),
            key = event.target.closest('[data-key]').dataset.key,
            index = button.dataset.index;
        data[key].splice(index, 1);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static addDamage(event) {
        if (!this.action.damage.parts) return;
        const data = this.action.toObject(),
            part = {};
        if (this.action.actor?.isNPC) part.value = { multiplier: 'flat' };
        data.damage.parts.push(part);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static removeDamage(event, button) {
        if (!this.action.damage.parts) return;
        const data = this.action.toObject(),
            index = button.dataset.index;
        data.damage.parts.splice(index, 1);
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
    }

    static async addEffect(event) {
        if (!this.action.effects) return;
        const effectData = this._addEffectData.bind(this)(),
            [created] = await this.action.item.createEmbeddedDocuments('ActiveEffect', [effectData], { render: false }),
            data = this.action.toObject();
        data.effects.push({ _id: created._id });
        this.constructor.updateForm.bind(this)(null, null, { object: foundry.utils.flattenObject(data) });
        this.action.item.effects.get(created._id).sheet.render(true);
    }

    /**
     * The data for a newly created applied effect.
     * @returns {object}
     * @protected
     */
    _addEffectData() {
        return {
            name: this.action.item.name,
            img: this.action.item.img,
            origin: this.action.item.uuid,
            transfer: false
        };
    }

    static removeEffect(event, button) {
        if (!this.action.effects) return;
        const index = button.dataset.index,
            effectId = this.action.effects[index]._id;
        this.constructor.removeElement.bind(this)(event, button);
        this.action.item.deleteEmbeddedDocuments('ActiveEffect', [effectId]);
    }

    static editEffect(event) {
        const id = event.target.closest('[data-effect-id]')?.dataset?.effectId;
        this.action.item.effects.get(id).sheet.render(true);
    }
}

/**
 * A subclass of ObjectField that represents a mapping of keys to the provided DataField type.
 *
 * @param {DataField} model                    The class of DataField which should be embedded in this field.
 * @param {MappingFieldOptions} [options={}]   Options which configure the behavior of the field.
 * @property {string[]} [initialKeys]          Keys that will be created if no data is provided.
 * @property {MappingFieldInitialValueBuilder} [initialValue]  Function to calculate the initial value for a key.
 * @property {boolean} [initialKeysOnly=false]  Should the keys in the initialized data be limited to the keys provided
 *                                              by `options.initialKeys`?
 */
class MappingField extends foundry.data.fields.ObjectField {
    constructor(model, options) {
        if (!(model instanceof foundry.data.fields.DataField)) {
            throw new Error('MappingField must have a DataField as its contained element');
        }
        super(options);

        /**
         * The embedded DataField definition which is contained in this field.
         * @type {DataField}
         */
        this.model = model;
        model.parent = this;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            initialKeys: null,
            initialValue: null,
            initialKeysOnly: false
        });
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _cleanType(value, options) {
        Object.entries(value).forEach(([k, v]) => {
            if (k.startsWith('-=')) return;
            value[k] = this.model.clean(v, options);
        });
        return value;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    getInitialValue(data) {
        let keys = this.initialKeys;
        const initial = super.getInitialValue(data);
        if (!keys || !foundry.utils.isEmpty(initial)) return initial;
        if (!(keys instanceof Array)) keys = Object.keys(keys);
        for (const key of keys) initial[key] = this._getInitialValueForKey(key);
        return initial;
    }

    /* -------------------------------------------- */

    /**
     * Get the initial value for the provided key.
     * @param {string} key       Key within the object being built.
     * @param {object} [object]  Any existing mapping data.
     * @returns {*}              Initial value based on provided field type.
     */
    _getInitialValueForKey(key, object) {
        const initial = this.model.getInitialValue();
        return this.initialValue?.(key, initial, object) ?? initial;
    }

    /* -------------------------------------------- */

    /** @override */
    _validateType(value, options = {}) {
        if (foundry.utils.getType(value) !== 'Object') throw new Error('must be an Object');
        const errors = this._validateValues(value, options);
        if (!foundry.utils.isEmpty(errors)) {
            const failure = new foundry.data.validation.DataModelValidationFailure();
            failure.elements = Object.entries(errors).map(([id, failure]) => ({ id, failure }));
            throw failure.asError();
        }
    }

    /* -------------------------------------------- */

    /**
     * Validate each value of the object.
     * @param {object} value     The object to validate.
     * @param {object} options   Validation options.
     * @returns {Record<string, Error>}  An object of value-specific errors by key.
     */
    _validateValues(value, options) {
        const errors = {};
        for (const [k, v] of Object.entries(value)) {
            if (k.startsWith('-=')) continue;
            const error = this.model.validate(v, options);
            if (error) errors[k] = error;
        }
        return errors;
    }

    /* -------------------------------------------- */

    /** @override */
    initialize(value, model, options = {}) {
        if (!value) return value;
        const obj = {};
        const initialKeys = this.initialKeys instanceof Array ? this.initialKeys : Object.keys(this.initialKeys ?? {});
        const keys = this.initialKeysOnly ? initialKeys : Object.keys(value);
        for (const key of keys) {
            const data = value[key] ?? this._getInitialValueForKey(key, value);
            obj[key] = this.model.initialize(data, model, options);
        }
        return obj;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _getField(path) {
        if (path.length === 0) return this;
        else if (path.length === 1) return this.model;
        path.shift();
        return this.model._getField(path);
    }
}

/**
 * Specialized collection type for stored actions.
 * @param {DataModel} model     The parent DataModel to which this ActionCollection belongs.
 * @param {Action[]} entries  The actions to store.
 */
class ActionCollection extends Collection {
    constructor(model, entries) {
        super();
        this.#model = model;
        for (const entry of entries) {
            if (!(entry instanceof game.system.api.models.actions.actionsTypes.base)) continue;
            this.set(entry._id, entry);
        }
    }

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**
     * The parent DataModel to which this ActionCollection belongs.
     * @type {DataModel}
     */
    #model;

    /* -------------------------------------------- */

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /* -------------------------------------------- */

    /**
     * Test the given predicate against every entry in the Collection.
     * @param {function(*, number, ActionCollection): boolean} predicate  The predicate.
     * @returns {boolean}
     */
    every(predicate) {
        return this.reduce((pass, v, i) => pass && predicate(v, i, this), true);
    }

    /* -------------------------------------------- */

    /**
     * Convert the ActionCollection to an array of simple objects.
     * @param {boolean} [source=true]  Draw data for contained Documents from the underlying data source?
     * @returns {object[]}             The extracted array of primitive objects.
     */
    toObject(source = true) {
        return this.map(doc => doc.toObject(source));
    }
}

/* -------------------------------------------- */

/**
 * Field that stores actions.
 */
class ActionsField extends MappingField {
    constructor(options) {
        super(new ActionField(), options);
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    initialize(value, model, options) {
        const actions = Object.values(super.initialize(value, model, options));
        return new ActionCollection(model, actions);
    }
}

/* -------------------------------------------- */

/**
 * Field that stores action data and swaps class based on action type.
 */
class ActionField extends foundry.data.fields.ObjectField {
    getModel(value) {
        return game.system.api.models.actions.actionsTypes[value.type] ?? null;
    }

    /* -------------------------------------------- */

    /** @override */
    _cleanType(value, options) {
        if (!(typeof value === 'object')) value = {};
        const cls = this.getModel(value);
        if (cls) return cls.cleanData(value, options);
        return value;
    }

    /* -------------------------------------------- */

    /** @override */
    initialize(value, model, options = {}) {
        const cls = this.getModel(value);
        if (cls) return new cls(value, { parent: model, ...options });
        return foundry.utils.deepClone(value);
    }

    /* -------------------------------------------- */

    /**
     * Migrate this field's candidate source data.
     * @param {object} sourceData  Candidate source data of the root model.
     * @param {any} fieldData      The value of this field within the source data.
     */
    migrateSource(sourceData, fieldData) {
        const cls = this.getModel(fieldData);
        if (cls) cls.migrateDataSafe(fieldData);
    }
}

/* -------------------------------------------- */

function ActionMixin(Base) {
    class Action extends Base {
        static metadata = Object.freeze({
            name: 'Action',
            label: 'DAGGERHEART.GENERAL.Action.single',
            sheetClass: DHActionConfig
        });

        static _sheets = new Map();

        static get documentName() {
            return this.metadata.name;
        }

        get documentName() {
            return this.constructor.documentName;
        }

        static defaultName() {
            return this.documentName;
        }

        get relativeUUID() {
            return `.Item.${this.item.id}.Action.${this.id}`;
        }

        get uuid() {
            return `${this.item.uuid}.${this.documentName}.${this.id}`;
        }

        get sheet() {
            if (!this.constructor._sheets.has(this.uuid)) {
                const sheet = new this.constructor.metadata.sheetClass(this);
                this.constructor._sheets.set(this.uuid, sheet);
            }
            return this.constructor._sheets.get(this.uuid);
        }

        get inCollection() {
            return foundry.utils.getProperty(this.parent, this.systemPath) instanceof Collection;
        }

        get remainingUses() {
            if (!this.uses) return null;

            return Math.max(
                (this.uses.max ? itemAbleRollParse(this.uses.max, this.actor) : 0) - (this.uses.value ?? 0),
                0
            );
        }

        static async create(data, operation = {}) {
            const { parent, renderSheet } = operation;
            let { type } = data;
            if (!type || !game.system.api.models.actions.actionsTypes[type]) {
                ({ type } =
                    (await foundry.applications.api.DialogV2.input({
                        window: { title: game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectType') },
                        position: { width: 300 },
                        classes: ['daggerheart', 'dh-style'],
                        content: await foundry.applications.handlebars.renderTemplate(
                            'systems/daggerheart/templates/actionTypes/actionType.hbs',
                            {
                                types: CONFIG.DH.ACTIONS.actionTypes,
                                itemName: parent.parent?.name
                            }
                        ),
                        ok: {
                            label: game.i18n.format('DOCUMENT.Create', {
                                type: game.i18n.localize('DAGGERHEART.GENERAL.Action.single')
                            })
                        }
                    })) ?? {});
            }
            if (!type) return;

            const cls = game.system.api.models.actions.actionsTypes[type];
            const action = new cls(
                {
                    type,
                    ...cls.getSourceConfig(parent)
                },
                {
                    parent
                }
            );
            const created = await parent.parent.update({ [`system.actions.${action.id}`]: action.toObject() });
            const newAction = created.system.actions.get(action.id);
            if (!newAction) return null;
            if (renderSheet) newAction.sheet.render({ force: true });
            return newAction;
        }

        async update(updates, options = {}) {
            const isSetting = !this.parent.parent;
            const basePath = isSetting ? this.systemPath : `system.${this.systemPath}`;
            const path = this.inCollection ? `${basePath}.${this.id}` : basePath;
            let result = null;
            if (isSetting) {
                await this.parent.updateSource({ [path]: updates }, options);
                result = this.parent;
            } else {
                result = await this.item.update({ [path]: updates }, options);
            }

            return this.inCollection
                ? foundry.utils.getProperty(result, basePath)?.get(this.id)
                : foundry.utils.getProperty(result, basePath);
        }

        delete() {
            if (!this.inCollection) return this.item;
            const action = foundry.utils.getProperty(this.item, `system.${this.systemPath}`)?.get(this.id);
            if (!action) return this.item;
            this.item.update({ [`system.${this.systemPath}.-=${this.id}`]: null });
            this.constructor._sheets.get(this.uuid)?.close();
        }

        async deleteDialog() {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize(`DAGGERHEART.GENERAL.Action.single`),
                        name: this.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', {
                    name: this.name
                })
            });
            if (!confirmed) return;
            return this.delete();
        }

        async toChat(origin) {
            const cls = getDocumentClass('ChatMessage');
            const systemData = {
                title: game.i18n.localize('DAGGERHEART.CONFIG.ActionType.action'),
                origin: origin,
                action: { name: this.name, img: this.img, tags: this.tags ? this.tags : ['Spell', 'Arcana', 'Lv 10'] },
                itemOrigin: this.item,
                description: this.description
            };
            const msg = {
                type: 'abilityUse',
                user: game.user.id,
                actor: { name: this.actor.name, img: this.actor.img },
                author: this.author,
                speaker: cls.getSpeaker(),
                title: game.i18n.localize('DAGGERHEART.UI.Chat.action.title'),
                system: systemData,
                content: await foundry.applications.handlebars.renderTemplate(
                    'systems/daggerheart/templates/ui/chat/action.hbs',
                    systemData
                ),
                flags: {
                    daggerheart: {
                        cssClass: 'dh-chat-message dh-style'
                    }
                }
            };

            ChatMessage.applyRollMode(msg, game.settings.get('core', 'rollMode'));
            cls.create(msg);
        }
    }

    return Action;
}

class DhHomebrew extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            maxFear: new fields.NumberField({
                required: true,
                integer: true,
                min: 0,
                initial: 12,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxFear.label'
            }),
            maxLoadout: new fields.NumberField({
                required: true,
                integer: true,
                min: 0,
                initial: 5,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxLoadout.label'
            }),
            maxDomains: new fields.NumberField({
                required: true,
                integer: true,
                min: 1,
                initial: 2,
                label: 'DAGGERHEART.SETTINGS.Homebrew.FIELDS.maxDomains.label'
            }),
            traitArray: new fields.ArrayField(new fields.NumberField({ required: true, integer: true }), {
                initial: () => [2, 1, 1, 0, 0, -1]
            }),
            currency: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.enabled'
                }),
                title: new fields.StringField({
                    required: true,
                    initial: 'Gold',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.currencyName'
                }),
                coins: new fields.StringField({
                    required: true,
                    initial: 'Coins',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.coinName'
                }),
                handfuls: new fields.StringField({
                    required: true,
                    initial: 'Handfuls',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.handfulName'
                }),
                bags: new fields.StringField({
                    required: true,
                    initial: 'Bags',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.bagName'
                }),
                chests: new fields.StringField({
                    required: true,
                    initial: 'Chests',
                    label: 'DAGGERHEART.SETTINGS.Homebrew.currency.chestName'
                })
            }),
            restMoves: new fields.SchemaField({
                longRest: new fields.SchemaField({
                    nrChoices: new fields.NumberField({ required: true, integer: true, min: 1, initial: 2 }),
                    moves: new fields.TypedObjectField(
                        new fields.SchemaField({
                            name: new fields.StringField({ required: true }),
                            icon: new fields.StringField({ required: true }),
                            img: new fields.FilePathField({
                                initial: 'icons/magic/life/cross-worn-green.webp',
                                categories: ['IMAGE'],
                                base64: false
                            }),
                            description: new fields.HTMLField(),
                            actions: new ActionsField()
                        }),
                        { initial: defaultRestOptions.longRest() }
                    )
                }),
                shortRest: new fields.SchemaField({
                    nrChoices: new fields.NumberField({ required: true, integer: true, min: 1, initial: 2 }),
                    moves: new fields.TypedObjectField(
                        new fields.SchemaField({
                            name: new fields.StringField({ required: true }),
                            icon: new fields.StringField({ required: true }),
                            img: new fields.FilePathField({
                                initial: 'icons/magic/life/cross-worn-green.webp',
                                categories: ['IMAGE'],
                                base64: false
                            }),
                            description: new fields.HTMLField(),
                            actions: new ActionsField()
                        }),
                        { initial: defaultRestOptions.shortRest() }
                    )
                })
            }),
            domains: new fields.TypedObjectField(
                new fields.SchemaField({
                    id: new fields.StringField({ required: true }),
                    label: new fields.StringField({ required: true, initial: '', label: 'DAGGERHEART.GENERAL.label' }),
                    src: new fields.FilePathField({
                        categories: ['IMAGE'],
                        base64: false,
                        label: 'Image'
                    }),
                    description: new fields.HTMLField()
                })
            )
        };
    }
}

class DhVariantRules extends foundry.abstract.DataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.SETTINGS.VariantRules'];

    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            actionTokens: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.SETTINGS.VariantRules.FIELDS.actionTokens.enabled.label'
                }),
                tokens: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 3,
                    label: 'DAGGERHEART.SETTINGS.VariantRules.FIELDS.actionTokens.tokens.label'
                })
            }),
            rangeMeasurement: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: true,
                    label: 'DAGGERHEART.GENERAL.enabled'
                }),
                melee: new fields.NumberField({
                    required: true,
                    initial: 5,
                    label: 'DAGGERHEART.CONFIG.Range.melee.name'
                }),
                veryClose: new fields.NumberField({
                    required: true,
                    initial: 15,
                    label: 'DAGGERHEART.CONFIG.Range.veryClose.name'
                }),
                close: new fields.NumberField({
                    required: true,
                    initial: 30,
                    label: 'DAGGERHEART.CONFIG.Range.close.name'
                }),
                far: new fields.NumberField({ required: true, initial: 60, label: 'DAGGERHEART.CONFIG.Range.far.name' })
            })
        };
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$6, ApplicationV2: ApplicationV2$5 } = foundry.applications.api;

class DhAutomationSettings extends HandlebarsApplicationMixin$6(ApplicationV2$5) {
    constructor() {
        super({});

        this.settings = new DhAutomation(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).toObject()
        );
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-automation-settings',
        classes: ['daggerheart', 'dh-style', 'dialog', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: this.reset,
            save: this.save
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        header: { template: 'systems/daggerheart/templates/settings/automation-settings/header.hbs' },
        general: { template: 'systems/daggerheart/templates/settings/automation-settings/general.hbs' },
        rules: { template: 'systems/daggerheart/templates/settings/automation-settings/rules.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/automation-settings/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        main: {
            tabs: [{ id: 'general' }, { id: 'rules' }],
            initial: 'general',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    static async updateData(event, element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource(updatedSettings);
        this.render();
    }

    static async reset() {
        this.settings = new DhAutomation();
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation, this.settings.toObject());
        this.close();
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$5, ApplicationV2: ApplicationV2$4 } = foundry.applications.api;

class DhHomebrewSettings extends HandlebarsApplicationMixin$5(ApplicationV2$4) {
    constructor() {
        super({});

        this.settings = new DhHomebrew(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).toObject()
        );

        this.selected = {
            domain: null
        };
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-homebrew-settings',
        classes: ['daggerheart', 'dh-style', 'dialog', 'setting', 'homebrew-settings'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            addItem: this.addItem,
            editItem: this.editItem,
            removeItem: this.removeItem,
            resetMoves: this.resetMoves,
            addDomain: this.addDomain,
            toggleSelectedDomain: this.toggleSelectedDomain,
            deleteDomain: this.deleteDomain,
            save: this.save,
            reset: this.reset
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        settings: { template: 'systems/daggerheart/templates/settings/homebrew-settings/settings.hbs' },
        domains: { template: 'systems/daggerheart/templates/settings/homebrew-settings/domains.hbs' },
        downtime: { template: 'systems/daggerheart/templates/settings/homebrew-settings/downtime.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/homebrew-settings/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        main: {
            tabs: [{ id: 'settings' }, { id: 'domains' }, { id: 'downtime' }],
            initial: 'settings',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        switch (partId) {
            case 'domains':
                const selectedDomain = this.selected.domain ? this.settings.domains[this.selected.domain] : null;
                const enrichedDescription = selectedDomain
                    ? await foundry.applications.ux.TextEditor.implementation.enrichHTML(selectedDomain.description)
                    : null;

                if (enrichedDescription !== null) context.selectedDomain = { ...selectedDomain, enrichedDescription };
                context.configDomains = CONFIG.DH.DOMAIN.domains;
                context.homebrewDomains = this.settings.domains;
                break;
        }

        return context;
    }

    static async updateData(_event, _element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource({
            ...updatedSettings,
            traitArray: Object.values(updatedSettings.traitArray)
        });
        this.render();
    }

    static async addItem(_, target) {
        await this.settings.updateSource({
            [`restMoves.${target.dataset.type}.moves.${foundry.utils.randomID()}`]: {
                name: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.newDowntimeMove'),
                img: 'icons/magic/life/cross-worn-green.webp',
                description: '',
                actions: []
            }
        });
        this.render();
    }

    static async editItem(_, target) {
        const move = this.settings.restMoves[target.dataset.type].moves[target.dataset.id];
        const path = `restMoves.${target.dataset.type}.moves.${target.dataset.id}`;
        const editedMove = await game.system.api.applications.sheetConfigs.DowntimeConfig.configure(
            move,
            path,
            this.settings
        );
        if (!editedMove) return;

        await this.updateAction.bind(this)(editedMove, target.dataset.type, target.dataset.id);
    }

    async updateAction(data, type, id) {
        await this.settings.updateSource({
            [`restMoves.${type}.moves.${id}`]: {
                actions: data.actions,
                name: data.name,
                icon: data.icon,
                img: data.img,
                description: data.description
            }
        });
        this.render();
    }

    static async removeItem(_, target) {
        await this.settings.updateSource({
            [`restMoves.${target.dataset.type}.moves.-=${target.dataset.id}`]: null
        });
        this.render();
    }

    static async resetMoves(_, target) {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.SETTINGS.Homebrew.resetMovesTitle', {
                    type: game.i18n.localize(
                        `DAGGERHEART.APPLICATIONS.Downtime.${target.dataset.type === 'shortRest' ? 'shortRest' : 'longRest'}.title`
                    )
                })
            },
            content: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.resetMovesText')
        });

        if (!confirmed) return;

        const fields = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).schema.fields;

        const removeUpdate = Object.keys(this.settings.restMoves[target.dataset.type].moves).reduce((acc, key) => {
            acc[`-=${key}`] = null;

            return acc;
        }, {});

        const updateBase =
            target.dataset.type === 'shortRest'
                ? fields.restMoves.fields.shortRest.fields
                : fields.restMoves.fields.longRest.fields;
        const update = {
            nrChoices: updateBase.nrChoices.initial,
            moves: Object.keys(updateBase.moves.initial).reduce((acc, key) => {
                const move = updateBase.moves.initial[key];
                acc[key] = {
                    ...move,
                    name: game.i18n.localize(move.name),
                    description: game.i18n.localize(move.description),
                    actions: move.actions.reduce((acc, key) => {
                        const action = move.actions[key];
                        acc[key] = {
                            ...action,
                            name: game.i18n.localize(action.name)
                        };
                        return acc;
                    }, {})
                };

                return acc;
            }, {})
        };

        await this.settings.updateSource({
            [`restMoves.${target.dataset.type}`]: {
                ...update,
                moves: {
                    ...removeUpdate,
                    ...update.moves
                }
            }
        });

        this.render();
    }

    static async addDomain(event) {
        event.preventDefault();
        const content = new foundry.data.fields.StringField({
            label: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputLabel'),
            hint: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputHint'),
            required: true
        }).toFormGroup({}, { name: 'domainName', localize: true }).outerHTML;

        async function callback(_, button) {
            const domainName = button.form.elements.domainName.value;
            if (!domainName) return;

            const newSlug = slugify(domainName);
            const existingDomains = [
                ...Object.values(this.settings.domains),
                ...Object.values(CONFIG.DH.DOMAIN.domains)
            ];
            if (existingDomains.find(x => slugify(game.i18n.localize(x.label)) === newSlug)) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.duplicateDomain'));
                return;
            }

            this.settings.updateSource({
                [`domains.${newSlug}`]: {
                    id: newSlug,
                    label: domainName,
                    src: 'icons/svg/portal.svg'
                }
            });

            this.selected.domain = newSlug;
            this.render();
        }

        foundry.applications.api.DialogV2.prompt({
            content: content,
            rejectClose: false,
            modal: true,
            ok: { callback: callback.bind(this) },
            window: {
                title: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.newDomainInputTitle')
            },
            position: { width: 400 }
        });
    }

    static toggleSelectedDomain(_, target) {
        this.selected.domain = this.selected.domain === target.id ? null : target.id;
        this.render();
    }

    static async deleteDomain() {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.domains.deleteDomain')
            },
            content: game.i18n.format('DAGGERHEART.SETTINGS.Homebrew.domains.deleteDomainText', {
                name: this.settings.domains[this.selected.domain].label
            })
        });

        if (!confirmed) return;

        await this.settings.updateSource({
            [`domains.-=${this.selected.domain}`]: null
        });

        const currentSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew);
        if (currentSettings.domains[this.selected.domain]) {
            await currentSettings.updateSource({ [`domains.-=${this.selected.domain}`]: null });
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, currentSettings);
        }

        const updateClasses = game.items.filter(x => x.type === 'class');
        for (let actor of game.actors) {
            updateClasses.push(...actor.items.filter(x => x.type === 'class'));
        }

        for (let c of updateClasses) {
            if (c.system.domains.includes(this.selected.domain)) {
                const newDomains =
                    c.system.domains.length === 1
                        ? [CONFIG.DH.DOMAIN.domains.arcana.id]
                        : c.system.domains.filter(x => x !== this.selected.domain);
                await c.update({ 'system.domains': newDomains });
            }
            c.sheet.render();
        }

        const updateDomainCards = game.items.filter(
            x => x.type === 'domainCard' && x.system.domain === this.selected.domain
        );
        for (let d of updateDomainCards) {
            await d.update({ 'system.domain': CONFIG.DH.DOMAIN.domains.arcana.id });
            d.sheet.render();
        }

        this.selected.domain = null;
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, this.settings.toObject());
        this.close();
    }

    static async reset() {
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.SETTINGS.ResetSettings.resetConfirmationTitle')
            },
            content: game.i18n.format('DAGGERHEART.SETTINGS.ResetSettings.resetConfirmationText', {
                settings: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.name')
            })
        });
        if (!confirmed) return;

        const resetSettings = new DhHomebrew();
        let localizedSettings = this.localizeObject(resetSettings.toObject());
        this.settings.updateSource(localizedSettings);
        this.render();
    }

    localizeObject(obj) {
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (typeof value === 'object' && value !== null) {
                    obj[key] = this.localizeObject(value);
                } else {
                    if (typeof value === 'string' && value.startsWith('DAGGERHEART.')) {
                        obj[key] = game.i18n.localize(value);
                    }
                }
            }
        }
        return obj;
    }

    _getTabs(tabs) {
        for (const v of Object.values(tabs)) {
            v.active = this.tabGroups[v.group] ? this.tabGroups[v.group] === v.id : v.active;
            v.cssClass = v.active ? 'active' : '';
        }

        return tabs;
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$4, ApplicationV2: ApplicationV2$3 } = foundry.applications.api;

class DHVariantRuleSettings extends HandlebarsApplicationMixin$4(ApplicationV2$3) {
    constructor() {
        super({});

        this.settings = new DhVariantRules(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).toObject()
        );
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Menu.title');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        id: 'daggerheart-appearance-settings',
        classes: ['daggerheart', 'dialog', 'dh-style', 'setting'],
        position: { width: '600', height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            reset: this.reset,
            save: this.save
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        main: {
            template: 'systems/daggerheart/templates/settings/variant-rules.hbs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.settingFields = this.settings;

        return context;
    }

    static async updateData(event, element, formData) {
        const updatedSettings = foundry.utils.expandObject(formData.object);

        await this.settings.updateSource(updatedSettings);
        this.render();
    }

    static async reset() {
        this.settings = new DhVariantRules();
        this.render();
    }

    static async save() {
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules, this.settings.toObject());
        this.close();
    }
}

var _module$b = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhAppearanceSettings: DHAppearanceSettings,
    DhAutomationSettings: DhAutomationSettings,
    DhHomebrewSettings: DhHomebrewSettings,
    DhVariantRuleSettings: DHVariantRuleSettings
});

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$3 } = foundry.applications.api;

const typeSettingsMap = {
    character: 'extendCharacterDescriptions',
    adversary: 'extendAdversaryDescriptions',
    environment: 'extendEnvironmentDescriptions',
    ancestry: 'extendItemDescriptions',
    community: 'extendItemDescriptions',
    class: 'extendItemDescriptions',
    subclass: 'extendItemDescriptions',
    feature: 'extendItemDescriptions',
    domainCard: 'extendItemDescriptions',
    loot: 'extendItemDescriptions',
    consumable: 'extendItemDescriptions',
    weapon: 'extendItemDescriptions',
    armor: 'extendItemDescriptions',
    beastform: 'extendItemDescriptions'
};

/**
 * @typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction
 */

/**
 * @typedef {object} DragDropConfig
 * @property {string} [dragSelector] - A CSS selector that identifies draggable elements.
 * @property {string} [dropSelector] - A CSS selector that identifies drop targets.
 *
 * @typedef {object} ContextMenuConfig
 * @property {() => ContextMenuEntry[]} handler - A handler function that provides initial context options
 * @property {string} selector - A CSS selector to which the ContextMenu will be bound
 * @property {object} [options] - Additional options which affect ContextMenu construction
 * @property {HTMLElement} [options.container] - A parent HTMLElement which contains the selector target
 * @property {string} [options.hookName] - The hook name
 * @property {boolean} [options.parentClassHooks=true] - Whether to call hooks for the parent classes in the inheritance chain.
 *
 * @typedef {Object} TagOption
 * @property {string} label
 * @property {string} [src]
 *
 * @typedef {object} TagifyConfig
 * @property {String} selector - The CSS selector for get the element to transform into a tag input
 * @property {Record<string, TagOption> | (() => Record<string, TagOption>)} options - Available tag options as key-value pairs
 * @property {TagChangeCallback} callback - Callback function triggered when tags change
 * @property {TagifyOptions} [tagifyOptions={}] - Additional configuration for Tagify
 *
 * @callback TagChangeCallback
 * @param {Array<{value: string, name: string, src?: string}>} selectedOptions - Current selected tags
 * @param {{option: string, removed: boolean}} change - What changed (added/removed tag)
 * @param {HTMLElement} inputElement - Original input element
 *
 *
 * @typedef {Object} TagifyOptions
 * @property {number} [maxTags] - Maximum number of allowed tags
 */

/**
 * @typedef {import("@client/applications/api/handlebars-application.mjs").HandlebarsRenderOptions} HandlebarsRenderOptions
 * @typedef {foundry.applications.types.ApplicationConfiguration} FoundryAppConfig
 *
 * @typedef {FoundryAppConfig & HandlebarsRenderOptions & {
 *   dragDrop?: DragDropConfig[],
 *   tagifyConfigs?: TagifyConfig[],
 *   contextMenus?: ContextMenuConfig[],
 * }} DHSheetV2Configuration
 */

/**
 * @template {new (...args: any[]) => {}} T
 * @arg Base {T}
 */
function DHApplicationMixin(Base) {
    class DHSheetV2 extends HandlebarsApplicationMixin$3(Base) {
        /**
         * @param {DHSheetV2Configuration} [options={}]
         */
        constructor(options = {}) {
            super(options);
            /**
             * @type {foundry.applications.ux.DragDrop[]}
             * @private
             */
            this._dragDrop = this._createDragDropHandlers();
        }

        /**
         * The default options for the sheet.
         * @type {DHSheetV2Configuration}
         */
        static DEFAULT_OPTIONS = {
            classes: ['daggerheart', 'sheet', 'dh-style'],
            actions: {
                triggerContextMenu: DHSheetV2.#triggerContextMenu,
                createDoc: DHSheetV2.#createDoc,
                editDoc: DHSheetV2.#editDoc,
                deleteDoc: DHSheetV2.#deleteDoc,
                toChat: DHSheetV2.#toChat,
                useItem: DHSheetV2.#useItem,
                toggleEffect: DHSheetV2.#toggleEffect,
                toggleExtended: DHSheetV2.#toggleExtended,
                addNewItem: DHSheetV2.#addNewItem,
                browseItem: DHSheetV2.#browseItem
            },
            contextMenus: [
                {
                    handler: DHSheetV2.#getEffectContextOptions,
                    selector: '[data-item-uuid][data-type="effect"]',
                    options: {
                        parentClassHooks: false,
                        fixed: true
                    }
                },
                {
                    handler: DHSheetV2.#getActionContextOptions,
                    selector: '[data-item-uuid][data-type="action"]',
                    options: {
                        parentClassHooks: false,
                        fixed: true
                    }
                }
            ],
            dragDrop: [{ dragSelector: '.inventory-item[data-type="effect"]', dropSelector: null }],
            tagifyConfigs: []
        };

        /**
         * Related documents that should cause a rerender of this application when updated.
         */
        get relatedDocs() {
            return [];
        }

        /* -------------------------------------------- */

        /**@inheritdoc */
        _attachPartListeners(partId, htmlElement, options) {
            super._attachPartListeners(partId, htmlElement, options);
            this._dragDrop.forEach(d => d.bind(htmlElement));
        }

        /**@inheritdoc */
        async _onFirstRender(context, options) {
            await super._onFirstRender(context, options);

            const docs = [];
            for (const docData of this.relatedDocs) {
                if (!docData) continue;
                const doc = await foundry.utils.fromUuid(docData.uuid);
                docs.push(doc);
            }

            docs.filter(doc => doc).forEach(doc => (doc.apps[this.id] = this));

            if (!!this.options.contextMenus.length) this._createContextMenus();

            this.#autoExtendDescriptions(context);
        }

        /** @inheritDoc */
        _onClose(options) {
            super._onClose(options);
            this.relatedDocs.filter(doc => doc).map(doc => delete doc.apps[this.id]);
        }

        /**@inheritdoc */
        async _onRender(context, options) {
            await super._onRender(context, options);
            this._createTagifyElements(this.options.tagifyConfigs);
            await this.#prepareInventoryDescription(context);
        }

        /* -------------------------------------------- */
        /*  Sync Parts                                  */
        /* -------------------------------------------- */

        /**@inheritdoc */
        _syncPartState(partId, newElement, priorElement, state) {
            super._syncPartState(partId, newElement, priorElement, state);
            for (const el of priorElement.querySelectorAll('.extensible.extended')) {
                const { actionId, itemUuid } = el.parentElement.dataset;
                const selector = `${actionId ? `[data-action-id="${actionId}"]` : `[data-item-uuid="${itemUuid}"]`} .extensible`;
                const newExtensible = newElement.querySelector(selector);
                newExtensible?.classList.add('extended');
            }
        }

        /* -------------------------------------------- */
        /*  Tags                                        */
        /* -------------------------------------------- */

        /**
         * Creates Tagify elements from configuration objects
         * @param {TagifyConfig[]} tagConfigs - Array of Tagify configuration objects
         * @throws {TypeError} If tagConfigs is not an array
         * @throws {Error} If required properties are missing in config objects
         * @param {TagifyConfig[]} tagConfigs
         */
        _createTagifyElements(tagConfigs) {
            if (!Array.isArray(tagConfigs)) throw new TypeError('tagConfigs must be an array');

            tagConfigs.forEach(config => {
                try {
                    const { selector, options, callback, tagifyOptions = {} } = config;

                    // Validate required fields
                    if (!selector || !options || !callback) {
                        throw new Error('Invalid TagifyConfig - missing required properties', config);
                    }

                    // Find target element
                    const element = this.element.querySelector(selector);
                    if (!element) {
                        throw new Error(`Element not found with selector: ${selector}`);
                    }
                    // Resolve dynamic options if function provided
                    const resolvedOptions = typeof options === 'function' ? options.call(this) : options;

                    // Initialize Tagify
                    tagifyElement(element, resolvedOptions, callback.bind(this), tagifyOptions);
                } catch (error) {
                    console.error('Error initializing Tagify:', error);
                }
            });
        }

        /* -------------------------------------------- */
        /*  Drag and Drop                               */
        /* -------------------------------------------- */

        /**
         * Creates drag-drop handlers from the configured options.
         * @returns {foundry.applications.ux.DragDrop[]}
         * @private
         */
        _createDragDropHandlers() {
            return this.options.dragDrop.map(d => {
                d.callbacks = {
                    dragstart: this._onDragStart.bind(this),
                    drop: this._onDrop.bind(this)
                };
                return new foundry.applications.ux.DragDrop.implementation(d);
            });
        }

        /**
         * Handle dragStart event.
         * @param {DragEvent} event
         * @protected
         */
        async _onDragStart(event) {
            const inventoryItem = event.currentTarget.closest('.inventory-item');
            if (inventoryItem) {
                const { type, itemUuid } = inventoryItem.dataset;
                if (type === 'effect') {
                    const effect = await foundry.utils.fromUuid(itemUuid);
                    const effectData = {
                        type: 'ActiveEffect',
                        data: { ...effect.toObject(), _id: null },
                        fromInternal: this.document.uuid
                    };
                    event.dataTransfer.setData('text/plain', JSON.stringify(effectData));
                    event.dataTransfer.setDragImage(inventoryItem.querySelector('img'), 60, 0);
                }
            }
        }

        /**
         * Handle drop event.
         * @param {DragEvent} event
         * @protected
         */
        _onDrop(event) {
            event.stopPropagation();
            const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
            if (data.fromInternal === this.document.uuid) return;

            if (data.type === 'ActiveEffect') {
                this.document.createEmbeddedDocuments('ActiveEffect', [data.data]);
            }
        }

        /* -------------------------------------------- */
        /*  Context Menu                                */
        /* -------------------------------------------- */

        /**
         * Create all configured context menus for this application ins tance.
         */
        _createContextMenus() {
            for (const config of this.options.contextMenus) {
                const { handler, selector, options } = config;
                this._createContextMenu(handler.bind(this), selector, options);
            }
        }

        /* -------------------------------------------- */

        /**
         * Get the set of ContextMenu options for ActiveEffects.
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
         * @this {DHSheetV2}
         * @protected
         */
        static #getEffectContextOptions() {
            /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
            const options = [
                {
                    name: 'disableEffect',
                    icon: 'fa-solid fa-lightbulb',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && !doc.disabled;
                    },
                    callback: async target => (await getDocFromElement(target)).update({ disabled: true })
                },
                {
                    name: 'enableEffect',
                    icon: 'fa-regular fa-lightbulb',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && doc.disabled;
                    },
                    callback: async target => (await getDocFromElement(target)).update({ disabled: false })
                }
            ].map(option => ({
                ...option,
                name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
                icon: `<i class="${option.icon}"></i>`
            }));

            return [...options, ...this._getContextMenuCommonOptions.call(this, { toChat: true })];
        }

        /**
         * Get the set of ContextMenu options for Actions.
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
         * @this {DHSheetV2}
         * @protected
         */
        static #getActionContextOptions() {
            /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
            const options = [];
            return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
        }

        /**
         * Get the common ContextMenu options for an element.
         * @param {Object} options
         * @param {boolean} [options.usable=false] - Whether to include an option to use the item or apply damage.
         * @param {boolean} [options.toChat=false] - Whether to include an option to send the item to chat.
         * @param {boolean} [options.deletable=true] - Whether to include an option to delete the item.
         *
         * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]}
         */
        _getContextMenuCommonOptions({ usable = false, toChat = false, deletable = true }) {
            const options = [
                {
                    name: 'CONTROLS.CommonEdit',
                    icon: 'fa-solid fa-pen-to-square',
                    condition: target => {
                        const { dataset } = target.closest('[data-item-uuid]');
                        const doc = getDocFromElementSync(target);
                        return (
                            (!dataset.noCompendiumEdit && !doc) ||
                            (doc && (!doc?.hasOwnProperty('systemPath') || doc?.inCollection))
                        );
                    },
                    callback: async target => (await getDocFromElement(target)).sheet.render({ force: true })
                }
            ];

            if (usable) {
                options.unshift({
                    name: 'DAGGERHEART.GENERAL.damage',
                    icon: 'fa-solid fa-explosion',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc?.system?.attack?.damage.parts.length || doc?.damage?.parts.length;
                    },
                    callback: async (target, event) => {
                        const doc = await getDocFromElement(target),
                            action = doc?.system?.attack ?? doc;
                        return action && action.use(event, { byPassRoll: true });
                    }
                });

                options.unshift({
                    name: 'DAGGERHEART.APPLICATIONS.ContextMenu.useItem',
                    icon: 'fa-solid fa-burst',
                    condition: target => {
                        const doc = getDocFromElementSync(target);
                        return doc && !(doc.type === 'domainCard' && doc.system.inVault);
                    },
                    callback: async (target, event) => (await getDocFromElement(target)).use(event)
                });
            }

            if (toChat)
                options.push({
                    name: 'DAGGERHEART.APPLICATIONS.ContextMenu.sendToChat',
                    icon: 'fa-solid fa-message',
                    callback: async target => (await getDocFromElement(target)).toChat(this.document.id)
                });

            if (deletable)
                options.push({
                    name: 'CONTROLS.CommonDelete',
                    icon: 'fa-solid fa-trash',
                    callback: async (target, event) => {
                        const doc = await getDocFromElement(target);
                        if (event.shiftKey) return doc.delete();
                        else return doc.deleteDialog();
                    }
                });

            return options.map(option => ({
                ...option,
                icon: `<i class="${option.icon}"></i>`
            }));
        }

        /* -------------------------------------------- */
        /*  Prepare Context                             */
        /* -------------------------------------------- */

        /**@inheritdoc*/
        async _prepareContext(options) {
            const context = await super._prepareContext(options);
            context.config = CONFIG.DH;
            context.source = this.document;
            context.fields = this.document.schema.fields;
            context.systemFields = this.document.system.schema.fields;
            context.settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance);
            return context;
        }

        /* -------------------------------------------- */
        /*  Prepare Descriptions                        */
        /* -------------------------------------------- */

        /**
         * Prepares and enriches an inventory item or action description for display.
         * @returns {Promise<void>}
         */
        async #prepareInventoryDescription(context) {
            // Get all inventory item elements with a data-item-uuid attribute
            const inventoryItems = this.element.querySelectorAll('.inventory-item[data-item-uuid]');
            for (const el of inventoryItems) {
                // Get the doc uuid from the element
                const { itemUuid } = el?.dataset || {};
                if (!itemUuid) continue;

                //get doc by uuid
                const doc = await fromUuid(itemUuid);

                //get inventory-item description element
                const descriptionElement = el.querySelector('.invetory-description');
                if (!doc || !descriptionElement) continue;

                // localize the description (idk if it's still necessary)
                const description = game.i18n.localize(doc.system?.description ?? doc.description);

                // Enrich the description and attach it;
                const isAction = doc.documentName === 'Action';
                descriptionElement.innerHTML = await foundry.applications.ux.TextEditor.implementation.enrichHTML(
                    description,
                    {
                        relativeTo: isAction ? doc.parent : doc,
                        rollData: doc.getRollData?.(),
                        secrets: isAction ? doc.parent.isOwner : doc.isOwner
                    }
                );
            }
        }

        /* -------------------------------------------- */
        /*  Extend Descriptions by Settings             */
        /* -------------------------------------------- */

        /**
         * Extend inventory description when enabled in settings.
         * @returns {Promise<void>}
         */
        async #autoExtendDescriptions(context) {
            const inventoryItems = this.element.querySelectorAll('.inventory-item[data-item-uuid]');
            for (const el of inventoryItems) {
                // Get the doc uuid from the element
                const { itemUuid } = el?.dataset || {};
                if (!itemUuid) continue;

                //get doc by uuid
                const doc = await fromUuid(itemUuid);

                //check the type of the document
                const actorType =
                    doc?.type === 'adversary' && context.document?.type === 'environment'
                        ? typeSettingsMap[doc?.type]
                        : doc.actor?.type;

                // If the actor type is defined and the setting is enabled, extend the description
                if (typeSettingsMap[actorType]) {
                    const settingKey = typeSettingsMap[actorType];
                    if (context.settings[settingKey]) this.#activeExtended(el);
                }
            }
        }

        /* -------------------------------------------- */
        /*  Application Clicks Actions                  */
        /* -------------------------------------------- */

        static async #addNewItem(event, target) {
            const createChoice = await foundry.applications.api.DialogV2.wait({
                classes: ['dh-style', 'two-big-buttons'],
                buttons: [
                    {
                        action: 'create',
                        label: 'Create Item',
                        icon: 'fa-solid fa-plus'
                    },
                    {
                        action: 'browse',
                        label: 'Browse Compendium',
                        icon: 'fa-solid fa-book'
                    }
                ]
            });

            if (!createChoice) return;

            if (createChoice === 'browse') return DHSheetV2.#browseItem.call(this, event, target);
            else return DHSheetV2.#createDoc.call(this, event, target);
        }

        static async #browseItem(event, target) {
            const type = target.dataset.compendium ?? target.dataset.type;

            const presets = {};

            switch (type) {
                case 'loot':
                case 'consumable':
                case 'armor':
                case 'weapon':
                    presets.compendium = 'daggerheart';
                    presets.folder = 'equipments';
                    presets.render = {
                        noFolder: true
                    };
                    presets.filter = {
                        type: { key: 'type', value: type, forced: true }
                    };
                    break;
                case 'domainCard':
                    presets.compendium = 'daggerheart';
                    presets.folder = 'domains';
                    presets.render = {
                        noFolder: true
                    };
                    presets.filter = {
                        'level.max': { key: 'level.max', value: this.document.system.levelData.level.current },
                        'system.domain': { key: 'system.domain', value: this.document.system.domains }
                    };
                    break;
                default:
                    return;
            }

            return new ItemBrowser({ presets }).render({ force: true });
        }

        /**
         * Create an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #createDoc(event, target) {
            const { documentClass, type, inVault, disabled } = target.dataset;
            const parentIsItem = this.document.documentName === 'Item';
            const featureOnCharacter = this.document.parent?.type === 'character' && type === 'feature';
            const parent = featureOnCharacter
                ? this.document.parent
                : parentIsItem && documentClass === 'Item'
                  ? type === 'action'
                      ? this.document.system
                      : null
                  : this.document;

            let systemData = {};
            if (featureOnCharacter) {
                systemData = {
                    originItemType: this.document.type,
                    identifier: this.document.system.isMulticlass ? 'multiclass' : null
                };
            }

            const cls =
                type === 'action' ? game.system.api.models.actions.actionsTypes.base : getDocumentClass(documentClass);
            const data = {
                name: cls.defaultName({ type, parent }),
                type,
                system: systemData
            };
            if (inVault) data['system.inVault'] = true;
            if (disabled) data.disabled = true;

            const doc = await cls.create(data, { parent, renderSheet: !event.shiftKey });
            if (parentIsItem && type === 'feature') {
                await this.document.update({
                    'system.features': this.document.system.toObject().features.concat(doc.uuid)
                });
            }
            return doc;
        }

        /**
         * Renders an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #editDoc(_event, target) {
            const doc = await getDocFromElement(target);
            if (doc) return doc.sheet.render({ force: true });
        }

        /**
         * Delete an embedded document.
         * @type {ApplicationClickAction}
         */
        static async #deleteDoc(event, target) {
            const doc = await getDocFromElement(target);
            if (doc) {
                if (event.shiftKey) return doc.delete();
                else return await doc.deleteDialog();
            }
        }

        /**
         * Send item to Chat
         * @type {ApplicationClickAction}
         */
        static async #toChat(_event, target) {
            let doc = await getDocFromElement(target);
            return doc.toChat(doc.uuid);
        }

        /**
         * Use a item
         * @type {ApplicationClickAction}
         */
        static async #useItem(event, target) {
            let doc = await getDocFromElement(target);
            await doc.use(event);
        }

        /**
         * Toggle a ActiveEffect
         * @type {ApplicationClickAction}
         */
        static async #toggleEffect(_, target) {
            const doc = await getDocFromElement(target);
            await doc.update({ disabled: !doc.disabled });
        }

        /**
         * Trigger the context menu.
         * @type {ApplicationClickAction}
         */
        static #triggerContextMenu(event, _) {
            return CONFIG.ux.ContextMenu.triggerContextMenu(event);
        }

        /**
         * Toggle the 'extended' class on the .extensible element inside inventory-item-content
         * @type {ApplicationClickAction}
         * @this {DHSheetV2}
         */
        static async #toggleExtended(_, target) {
            const container = target.closest('.inventory-item');
            const extensible = container?.querySelector('.extensible');
            extensible?.classList.toggle('extended');
        }

        async #activeExtended(element) {
            const extensible = element?.querySelector('.extensible');
            extensible?.classList.add('extended');
        }
    }

    return DHSheetV2;
}

const { DocumentSheetV2 } = foundry.applications.api;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * Base settings sheet for Daggerheart actors.
 * @extends {DHApplicationMixin<DocumentSheetV2>}
 */
class DHBaseActorSettings extends DHApplicationMixin(DocumentSheetV2) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['dialog'],
        window: {
            icon: 'fa-solid fa-wrench',
            resizable: false,
            title: 'DAGGERHEART.GENERAL.Tabs.settings'
        },
        position: { width: 455, height: 'auto' },
        actions: {},
        form: {
            submitOnChange: true
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /** @inheritDoc */
    _initializeApplicationOptions(options) {
        options = super._initializeApplicationOptions(options);
        options.classes = options.classes.filter(c => c !== 'sheet');
        return options;
    }

    /**@returns {foundry.documents.Actor} */
    get actor() {
        return this.document;
    }

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.isNPC = this.actor.isNPC;

        if (context.systemFields.attack) {
            context.systemFields.attack.fields = this.actor.system.attack.schema.fields;
        }

        return context;
    }
}

const { ActorSheetV2 } = foundry.applications.sheets;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * A base actor sheet extending {@link ActorSheetV2} via {@link DHApplicationMixin}
 */
class DHBaseActorSheet extends DHApplicationMixin(ActorSheetV2) {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['actor'],
        position: {
            width: 480
        },
        form: {
            submitOnChange: true
        },
        actions: {
            openSettings: DHBaseActorSheet.#openSettings,
            sendExpToChat: DHBaseActorSheet.#sendExpToChat,
            increaseActionUses: event => DHBaseActorSheet.#modifyActionUses(event, true)
        },
        contextMenus: [
            {
                handler: DHBaseActorSheet.#getFeatureContextOptions,
                selector: '[data-item-uuid][data-type="feature"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ],
        dragDrop: [{ dragSelector: '.inventory-item[data-type="attack"]', dropSelector: null }]
    };

    /* -------------------------------------------- */

    /**@type {typeof DHBaseActorSettings}*/
    #settingSheet;

    /**@returns {DHBaseActorSettings|null} */
    get settingSheet() {
        const SheetClass = this.document.system.metadata.settingSheet;
        return (this.#settingSheet ??= SheetClass ? new SheetClass({ document: this.document }) : null);
    }

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.isNPC = this.document.isNPC;
        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'effects':
                await this._prepareEffectsContext(context, options);
                break;
        }
        return context;
    }

    /**@inheritdoc */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.item-button .action-uses-button').forEach(element => {
            element.addEventListener('contextmenu', DHBaseActorSheet.#modifyActionUses);
        });
    }

    /**
     * Prepare render context for the Effect part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareEffectsContext(context, _options) {
        context.effects = {
            actives: [],
            inactives: []
        };

        for (const effect of this.actor.allApplicableEffects()) {
            const list = effect.active ? context.effects.actives : context.effects.inactives;
            list.push(effect);
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for Features.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {DHBaseActorSheet}
     * @protected
     */
    static #getFeatureContextOptions() {
        return this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Open the Actor Setting Sheet
     * @type {ApplicationClickAction}
     */
    static async #openSettings() {
        await this.settingSheet.render({ force: true });
    }

    /**
     * Send Experience to Chat
     * @type {ApplicationClickAction}
     */
    static async #sendExpToChat(_, button) {
        const experience = this.document.system.experiences[button.dataset.id];
        const cls = getDocumentClass('ChatMessage');

        const systemData = {
            actor: { name: this.actor.name, img: this.actor.img },
            author: game.users.get(game.user.id),
            action: {
                name: `${experience.name} ${experience.value.signedString()}`,
                img: '/icons/sundries/misc/admission-ticket-blue.webp'
            },
            itemOrigin: {
                name: game.i18n.localize('DAGGERHEART.GENERAL.Experience.single')
            },
            description: experience.description
        };

        const msg = {
            user: game.user.id,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/action.hbs',
                systemData
            ),
            title: game.i18n.localize('DAGGERHEART.ACTIONS.Config.displayInChat'),
            speaker: cls.getSpeaker(),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);
    }

    /**
     *
     */
    static async #modifyActionUses(event, increase) {
        event.stopPropagation();
        event.preventDefault();
        const actionId = event.target.dataset.itemUuid;
        const action = await foundry.utils.fromUuid(actionId);

        const newValue = (action.uses.value ?? 0) + (increase ? 1 : -1);
        await action.update({ 'uses.value': Math.min(Math.max(newValue, 0), action.uses.max ?? 0) });
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    /**
     * On dragStart on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDragStart(event) {
        const attackItem = event.currentTarget.closest('.inventory-item[data-type="attack"]');

        if (attackItem) {
            const attackData = {
                type: 'Attack',
                actorUuid: this.document.uuid,
                img: this.document.system.attack.img,
                fromInternal: true
            };
            event.dataTransfer.setData('text/plain', JSON.stringify(attackData));
            event.dataTransfer.setDragImage(attackItem.querySelector('img'), 60, 0);
        } else if (this.document.type !== 'environment') {
            super._onDragStart(event);
        }
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class AdversarySheet extends DHBaseActorSheet {
    static DEFAULT_OPTIONS = {
        classes: ['adversary'],
        position: { width: 660, height: 766 },
        window: { resizable: true },
        actions: {
            reactionRoll: AdversarySheet.#reactionRoll
        },
        window: {
            resizable: true
        }
    };

    static PARTS = {
        sidebar: { template: 'systems/daggerheart/templates/sheets/actors/adversary/sidebar.hbs' },
        header: { template: 'systems/daggerheart/templates/sheets/actors/adversary/header.hbs' },
        features: { template: 'systems/daggerheart/templates/sheets/actors/adversary/features.hbs' },
        notes: { template: 'systems/daggerheart/templates/sheets/actors/adversary/notes.hbs' },
        effects: { template: 'systems/daggerheart/templates/sheets/actors/adversary/effects.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'effects' }, { id: 'notes' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.systemFields.attack.fields = this.document.system.attack.schema.fields;
        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                await this._prepareHeaderContext(context, options);
                break;
            case 'notes':
                await this._prepareNotesContext(context, options);
                break;
        }
        return context;
    }

    /**@inheritdoc */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.inventory-item-resource').forEach(element => {
            element.addEventListener('change', this.updateItemResource.bind(this));
            element.addEventListener('click', e => e.stopPropagation());
        });
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareNotesContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            notes: 'notes'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /**
     * Prepare render context for the Header part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareHeaderContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        context.description = await TextEditor.implementation.enrichHTML(system.description, {
            secrets: this.document.isOwner,
            relativeTo: this.document
        });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Performs a reaction roll for an Adversary.
     * @type {ApplicationClickAction}
     */
    static #reactionRoll(event) {
        const config = {
            event,
            title: `Reaction Roll: ${this.actor.name}`,
            headerTitle: 'Adversary Reaction Roll',
            roll: {
                type: 'reaction'
            },
            type: 'trait',
            hasRoll: true,
            data: this.actor.getRollData()
        };

        this.actor.diceRoll(config);
    }

    /* -------------------------------------------- */
    /*  Application Listener Actions                */
    /* -------------------------------------------- */

    async updateItemResource(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        const max = event.currentTarget.max ? Number(event.currentTarget.max) : null;
        const value = max ? Math.min(Number(event.currentTarget.value), max) : event.currentTarget.value;
        await item.update({ 'system.resource.value': value });
        this.render();
    }
}

/**
 * @typedef {Object} FilterItem
 * @property {string} group - The group name this filter belongs to (e.g., "Type").
 * @property {string} name - The display name of the filter (e.g., "Weapons").
 * @property {import("@client/applications/ux/search-filter.mjs").FieldFilter} filter - The filter condition.
 */

class FilterMenu extends foundry.applications.ux.ContextMenu {
    /**
     * Filter Menu
     * @param {HTMLElement} container - Container element
     * @param {string} selector - CSS selector for menu targets
     * @param {Array} menuItems - Array of menu entries
     * @param {Function} callback - Callback when filters change
     * @param {Object} [options] - Additional options
     */
    constructor(container, selector, menuItems, callback, options = {}) {
        // Set default options
        const mergedOptions = {
            eventName: 'click',
            fixed: true,
            ...options,
            jQuery: false
        };

        super(container, selector, menuItems, mergedOptions);

        // Initialize filter states
        this.menuItems = menuItems.map(item => ({
            ...item,
            enabled: false
        }));

        this.callback = callback;
        this.contentElement = container.querySelector(mergedOptions.contentSelector);

        const syntheticEvent = {
            type: 'pointerdown',
            bubbles: true,
            cancelable: true,
            pointerType: 'mouse',
            isPrimary: true,
            button: 0
        };

        this.callback(syntheticEvent, this.contentElement, this.getActiveFilterData());
    }

    /** @inheritdoc */
    async render(target, options = {}) {
        await super.render(target, { ...options, animate: false });

        // Create menu structure
        const menu = document.createElement('menu');
        menu.className = 'filter-menu';

        // Group items by their group property
        const groups = this.#groupItems(this.menuItems);

        // Create sections for each group
        for (const [groupName, items] of Object.entries(groups)) {
            if (!items.length) continue;

            const section = this.#createSection(groupName, items);
            menu.appendChild(section);
        }

        // Update menu and set position
        this.element.replaceChildren(menu);

        menu.addEventListener('click', this.#handleClick.bind(this));

        this._setPosition(this.element, target, options);

        if (options.animate !== false) await this._animate(true);
        return this._onRender(options);
    }

    /**
     * Groups an array of items by their `group`.
     * @param {Array<Object>} items - The array of items to group. Each item is expected to have an optional `group` property.
     * @returns {Object<string, Array<Object>>} An object where keys are group names and values are arrays of items belonging to each group.
     */
    #groupItems(items) {
        return items.reduce((groups, item) => {
            const group = item.group ?? '_none';
            groups[group] = groups[group] || [];
            groups[group].push(item);
            return groups;
        }, {});
    }

    /**
     * Creates a DOM section element for a group of items with corresponding filter buttons.
     * @param {string} groupName - The name of the group, used as the section label.
     * @param {Array<Object>} items - The items to create buttons for. Each item should have:
     * @returns {HTMLDivElement} The section DOM element containing the label and buttons.
     */
    #createSection(groupName, items) {
        const section = document.createElement('fieldset');
        section.className = 'filter-section';

        const header = document.createElement('legend');
        header.textContent = groupName;
        section.appendChild(header);

        const buttons = document.createElement('div');
        buttons.className = 'filter-buttons';

        items.forEach(item => {
            const button = document.createElement('button');
            button.className = `filter-button ${item.enabled ? 'active' : ''}`;
            button.textContent = item.name;
            item.element = button;
            buttons.appendChild(button);
        });

        section.appendChild(buttons);
        return section;
    }

    /**
     * Get filter data from active filters
     * @returns {Array} Array of filter configurations
     */
    getActiveFilterData() {
        return this.menuItems.filter(item => item.enabled).map(item => item.filter);
    }

    /**
     * Handles click events on filter buttons.
     * Toggles the active state of the clicked button and updates the corresponding item's `enabled` state.
     * Then triggers the provided callback with the event, the content element, and the current active filter data.
     * @param {PointerEvent} event - The click event triggered by interacting with a filter button.
     * @returns {void}
     */
    #handleClick(event) {
        event.preventDefault();
        event.stopPropagation();

        const button = event.target.closest('.filter-button');
        if (!button) return;

        const clickedItem = this.menuItems.find(item => item.element === button);
        if (!clickedItem) return;

        const isActive = button.classList.toggle('active');
        clickedItem.enabled = isActive;

        const filters = this.getActiveFilterData();

        if (filters.length > 0) {
            this.target.classList.add('fa-beat', 'active');
        } else {
            this.target.classList.remove('fa-beat', 'active');
        }

        this.callback(event, this.contentElement, filters);
    }

    /**
     * Generate and return a sorted array of inventory filters.
     * @returns {Array<Object>} An array of filter objects, sorted by name within each group.
     */
    static get invetoryFilters() {
        const { OPERATORS } = foundry.applications.ux.SearchFilter;

        const typesFilters = Object.entries(CONFIG.Item.dataModels)
            .filter(([, { metadata }]) => metadata.isInventoryItem)
            .map(([type, { metadata }]) => ({
                group: game.i18n.localize('Type'),
                name: game.i18n.localize(metadata.label),
                filter: {
                    field: 'type',
                    operator: OPERATORS.EQUALS,
                    value: type
                }
            }));

        const burdenFilter = Object.values(CONFIG.DH.GENERAL.burden).map(({ value, label }) => ({
            group: game.i18n.localize('DAGGERHEART.GENERAL.burden'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.burden',
                operator: OPERATORS.EQUALS,
                value: value
            }
        }));

        const damageTypeFilter = Object.values(CONFIG.DH.GENERAL.damageTypes).map(({ id, abbreviation }) => ({
            group: 'Damage Type', //TODO localize
            name: game.i18n.localize(abbreviation),
            filter: {
                field: 'system.damage.type',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const sort = arr => game.i18n.sortObjects(arr, 'name');

        return [...sort(typesFilters), ...sort(burdenFilter), ...sort(damageTypeFilter)];
    }

    /**
     * Generate and return a sorted array of inventory filters.
     * @returns {Array<Object>} An array of filter objects, sorted by name within each group.
     */
    static get cardsFilters() {
        const { OPERATORS } = foundry.applications.ux.SearchFilter;

        const typesFilters = Object.values(CONFIG.DH.DOMAIN.cardTypes).map(({ id, label }) => ({
            group: game.i18n.localize('Type'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.type',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const domainFilter = Object.values(CONFIG.DH.DOMAIN.allDomains()).map(({ id, label }) => ({
            group: game.i18n.localize('DAGGERHEART.GENERAL.Domain.single'),
            name: game.i18n.localize(label),
            filter: {
                field: 'system.domain',
                operator: OPERATORS.EQUALS,
                value: id
            }
        }));

        const sort = arr => game.i18n.sortObjects(arr, 'name');

        return [...sort(typesFilters), ...sort(domainFilter)];
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

const { TextEditor: TextEditor$2 } = foundry.applications.ux;
class CharacterSheet extends DHBaseActorSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['character'],
        position: { width: 850, height: 800 },
        actions: {
            toggleVault: CharacterSheet.#toggleVault,
            rollAttribute: CharacterSheet.#rollAttribute,
            toggleHope: CharacterSheet.#toggleHope,
            toggleLoadoutView: CharacterSheet.#toggleLoadoutView,
            openPack: CharacterSheet.#openPack,
            makeDeathMove: CharacterSheet.#makeDeathMove,
            levelManagement: CharacterSheet.#levelManagement,
            toggleEquipItem: CharacterSheet.#toggleEquipItem,
            toggleResourceDice: CharacterSheet.#toggleResourceDice,
            handleResourceDice: CharacterSheet.#handleResourceDice,
            useDowntime: this.useDowntime,
            tempBrowser: CharacterSheet.#tempBrowser
        },
        window: {
            resizable: true
        },
        dragDrop: [
            {
                dragSelector: '[data-item-id][draggable="true"]',
                dropSelector: null
            }
        ],
        contextMenus: [
            {
                handler: CharacterSheet.#getDomainCardContextOptions,
                selector: '[data-item-uuid][data-type="domainCard"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            },
            {
                handler: CharacterSheet.#getEquipamentContextOptions,
                selector: '[data-item-uuid][data-type="armor"], [data-item-uuid][data-type="weapon"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            },
            {
                handler: CharacterSheet.#getItemContextOptions,
                selector: '[data-item-uuid][data-type="consumable"], [data-item-uuid][data-type="loot"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ]
    };

    /**@override */
    static PARTS = {
        sidebar: {
            id: 'sidebar',
            template: 'systems/daggerheart/templates/sheets/actors/character/sidebar.hbs'
        },
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets/actors/character/header.hbs'
        },
        features: {
            id: 'features',
            template: 'systems/daggerheart/templates/sheets/actors/character/features.hbs'
        },
        loadout: {
            id: 'loadout',
            template: 'systems/daggerheart/templates/sheets/actors/character/loadout.hbs'
        },
        inventory: {
            id: 'inventory',
            template: 'systems/daggerheart/templates/sheets/actors/character/inventory.hbs'
        },
        biography: {
            id: 'biography',
            template: 'systems/daggerheart/templates/sheets/actors/character/biography.hbs'
        },
        effects: {
            id: 'effects',
            template: 'systems/daggerheart/templates/sheets/actors/character/effects.hbs'
        }
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'loadout' }, { id: 'inventory' }, { id: 'biography' }, { id: 'effects' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.inventory-item-resource').forEach(element => {
            element.addEventListener('change', this.updateItemResource.bind(this));
            element.addEventListener('click', e => e.stopPropagation());
        });
        htmlElement.querySelectorAll('.inventory-item-quantity').forEach(element => {
            element.addEventListener('change', this.updateItemQuantity.bind(this));
        });

        // Add listener for armor marks input
        htmlElement.querySelectorAll('.armor-marks-input').forEach(element => {
            element.addEventListener('change', this.updateArmorMarks.bind(this));
        });
    }

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        this.element
            .querySelector('.level-value')
            ?.addEventListener('change', event => this.document.updateLevel(Number(event.currentTarget.value)));

        this._createFilterMenus();
        this._createSearchFilter();
    }

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.attributes = Object.keys(this.document.system.traits).reduce((acc, key) => {
            acc[key] = {
                ...this.document.system.traits[key],
                name: game.i18n.localize(CONFIG.DH.ACTOR.abilities[key].name),
                verbs: CONFIG.DH.ACTOR.abilities[key].verbs.map(x => game.i18n.localize(x))
            };

            return acc;
        }, {});

        context.inventory = {
            currency: {
                title: game.i18n.localize('DAGGERHEART.CONFIG.Gold.title'),
                coins: game.i18n.localize('DAGGERHEART.CONFIG.Gold.coins'),
                handfuls: game.i18n.localize('DAGGERHEART.CONFIG.Gold.handfuls'),
                bags: game.i18n.localize('DAGGERHEART.CONFIG.Gold.bags'),
                chests: game.i18n.localize('DAGGERHEART.CONFIG.Gold.chests')
            }
        };

        const homebrewCurrency = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).currency;
        if (homebrewCurrency.enabled) {
            context.inventory.currency = homebrewCurrency;
        }

        if (context.inventory.length === 0) {
            context.inventory = Array(1).fill(Array(5).fill([]));
        }

        return context;
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                const { playerCanEditSheet, levelupAuto } = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.Automation
                );
                context.showSettings = game.user.isGM || !levelupAuto || (levelupAuto && playerCanEditSheet);
                break;
            case 'loadout':
                await this._prepareLoadoutContext(context, options);
                break;
            case 'sidebar':
                await this._prepareSidebarContext(context, options);
                break;
            case 'biography':
                await this._prepareBiographyContext(context, options);
                break;
        }

        return context;
    }

    /**
     * Prepare render context for the Loadout part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareLoadoutContext(context, _options) {
        context.cardView = !game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.displayDomainCardsAsList);
    }

    /**
     * Prepare render context for the Sidebar part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareSidebarContext(context, _options) {
        context.isDeath = this.document.system.deathMoveViable;
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareBiographyContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            background: 'biography.background',
            connections: 'biography.connections'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for DomainCards.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getDomainCardContextOptions() {
        /**@type {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} */
        const options = [
            {
                name: 'toLoadout',
                icon: 'fa-solid fa-arrow-up',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && doc.system.inVault;
                },
                callback: async target => {
                    const doc = await getDocFromElement(target);
                    const actorLoadout = doc.actor.system.loadoutSlot;
                    if (actorLoadout.available) return doc.update({ 'system.inVault': false });
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.loadoutMaxReached'));
                }
            },
            {
                name: 'toVault',
                icon: 'fa-solid fa-arrow-down',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && !doc.system.inVault;
                },
                callback: async target => (await getDocFromElement(target)).update({ 'system.inVault': true })
            }
        ].map(option => ({
            ...option,
            name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
            icon: `<i class="${option.icon}"></i>`
        }));

        return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
    }

    /**
     * Get the set of ContextMenu options for Armors and Weapons.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getEquipamentContextOptions() {
        const options = [
            {
                name: 'equip',
                icon: 'fa-solid fa-hands',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && !doc.system.equipped;
                },
                callback: (target, event) => CharacterSheet.#toggleEquipItem.call(this, event, target)
            },
            {
                name: 'unequip',
                icon: 'fa-solid fa-hands',
                condition: target => {
                    const doc = getDocFromElementSync(target);
                    return doc && doc.system.equipped;
                },
                callback: (target, event) => CharacterSheet.#toggleEquipItem.call(this, event, target)
            }
        ].map(option => ({
            ...option,
            name: `DAGGERHEART.APPLICATIONS.ContextMenu.${option.name}`,
            icon: `<i class="${option.icon}"></i>`
        }));

        return [...options, ...this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true })];
    }

    /**
     * Get the set of ContextMenu options for Consumable and Loot.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {CharacterSheet}
     * @protected
     */
    static #getItemContextOptions() {
        return this._getContextMenuCommonOptions.call(this, { usable: true, toChat: true });
    }
    /* -------------------------------------------- */
    /*  Filter Tracking                             */
    /* -------------------------------------------- */

    /**
     * The currently active search filter.
     * @type {foundry.applications.ux.SearchFilter}
     */
    #search = {};

    /**
     * The currently active search filter.
     * @type {FilterMenu}
     */
    #menu = {};

    /**
     * Tracks which item IDs are currently displayed, organized by filter type and section.
     * @type {{
     *   inventory: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     *   loadout: {
     *     search: Set<string>,
     *     menu: Set<string>
     *   },
     * }}
     */
    #filteredItems = {
        inventory: {
            search: new Set(),
            menu: new Set()
        },
        loadout: {
            search: new Set(),
            menu: new Set()
        }
    };

    /* -------------------------------------------- */
    /*  Search Inputs                               */
    /* -------------------------------------------- */

    /**
     * Create and initialize search filter instances for the inventory and loadout sections.
     *
     * Sets up two {@link foundry.applications.ux.SearchFilter} instances:
     * - One for the inventory, which filters items in the inventory grid.
     * - One for the loadout, which filters items in the loadout/card grid.
     * @private
     */
    _createSearchFilter() {
        //Filters could be a application option if needed
        const filters = [
            {
                key: 'inventory',
                input: 'input[type="search"].search-inventory',
                content: '[data-application-part="inventory"] .items-section',
                callback: this._onSearchFilterInventory.bind(this)
            },
            {
                key: 'loadout',
                input: 'input[type="search"].search-loadout',
                content: '[data-application-part="loadout"] .items-section',
                callback: this._onSearchFilterCard.bind(this)
            }
        ];

        for (const { key, input, content, callback } of filters) {
            const filter = new foundry.applications.ux.SearchFilter({
                inputSelector: input,
                contentSelector: content,
                callback
            });
            filter.bind(this.element);
            this.#search[key] = filter;
        }
    }

    /**
     * Handle invetory items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterInventory(_event, query, rgx, html) {
        this.#filteredItems.inventory.search.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.inventory.search.add(item.id);
            const { menu } = this.#filteredItems.inventory;
            li.hidden = !(menu.has(item.id) && matchesSearch);
        }
    }

    /**
     * Handle card items search and filtering.
     * @param {KeyboardEvent} event  The keyboard input event.
     * @param {string} query         The input search string.
     * @param {RegExp} rgx           The regular expression query that should be matched against.
     * @param {HTMLElement} html     The container to filter items from.
     * @protected
     */
    async _onSearchFilterCard(_event, query, rgx, html) {
        this.#filteredItems.loadout.search.clear();

        for (const li of html.querySelectorAll('.items-list .inventory-item, .card-list .card-item')) {
            const item = await getDocFromElement(li);
            const matchesSearch = !query || foundry.applications.ux.SearchFilter.testQuery(rgx, item.name);
            if (matchesSearch) this.#filteredItems.loadout.search.add(item.id);
            const { menu } = this.#filteredItems.loadout;
            li.hidden = !(menu.has(item.id) && matchesSearch);
        }
    }

    /* -------------------------------------------- */
    /*  Filter Menus                                */
    /* -------------------------------------------- */

    _createFilterMenus() {
        //Menus could be a application option if needed
        const menus = [
            {
                key: 'inventory',
                container: '[data-application-part="inventory"]',
                content: '.items-section',
                callback: this._onMenuFilterInventory.bind(this),
                target: '.filter-button',
                filters: FilterMenu.invetoryFilters
            },
            {
                key: 'loadout',
                container: '[data-application-part="loadout"]',
                content: '.items-section',
                callback: this._onMenuFilterLoadout.bind(this),
                target: '.filter-button',
                filters: FilterMenu.cardsFilters
            }
        ];

        menus.forEach(m => {
            const container = this.element.querySelector(m.container);
            this.#menu[m.key] = new FilterMenu(container, m.target, m.filters, m.callback, {
                contentSelector: m.content
            });
        });
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     * @param {import('../ux/filter-menu.mjs').FilterItem[]} filters
     */
    async _onMenuFilterInventory(_event, html, filters) {
        this.#filteredItems.inventory.menu.clear();

        for (const li of html.querySelectorAll('.inventory-item')) {
            const item = await getDocFromElement(li);

            const matchesMenu =
                filters.length === 0 || filters.some(f => foundry.applications.ux.SearchFilter.evaluateFilter(item, f));
            if (matchesMenu) this.#filteredItems.inventory.menu.add(item.id);

            const { search } = this.#filteredItems.inventory;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /**
     * Callback when filters change
     * @param {PointerEvent} event
     * @param {HTMLElement} html
     * @param {import('../ux/filter-menu.mjs').FilterItem[]} filters
     */
    async _onMenuFilterLoadout(_event, html, filters) {
        this.#filteredItems.loadout.menu.clear();

        for (const li of html.querySelectorAll('.items-list .inventory-item, .card-list .card-item')) {
            const item = await getDocFromElement(li);

            const matchesMenu =
                filters.length === 0 || filters.some(f => foundry.applications.ux.SearchFilter.evaluateFilter(item, f));
            if (matchesMenu) this.#filteredItems.loadout.menu.add(item.id);

            const { search } = this.#filteredItems.loadout;
            li.hidden = !(search.has(item.id) && matchesMenu);
        }
    }

    /* -------------------------------------------- */
    /*  Application Listener Actions                */
    /* -------------------------------------------- */

    async updateItemResource(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        const max = event.currentTarget.max ? Number(event.currentTarget.max) : null;
        const value = max ? Math.min(Number(event.currentTarget.value), max) : event.currentTarget.value;
        await item.update({ 'system.resource.value': value });
        this.render();
    }

    async updateItemQuantity(event) {
        const item = await getDocFromElement(event.currentTarget);
        if (!item) return;

        await item.update({ 'system.quantity': event.currentTarget.value });
        this.render();
    }

    async updateArmorMarks(event) {
        const armor = this.document.system.armor;
        if (!armor) return;

        const maxMarks = this.document.system.armorScore;
        const value = Math.min(Math.max(Number(event.currentTarget.value), 0), maxMarks);
        await armor.update({ 'system.marks.value': value });
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Opens the character level management window.
     * If the character requires setup, opens the character creation interface.
     * If class or subclass is missing, shows an error notification.
     * @type {ApplicationClickAction}
     */
    static #levelManagement() {
        if (this.document.system.needsCharacterSetup)
            return new DhCharacterCreation(this.document).render({ force: true });

        const { value, subclass } = this.document.system.class;
        if (!value || !subclass)
            return ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClassOrSubclass'));

        new DhCharacterLevelUp(this.document).render({ force: true });
    }

    /**
     * Opens the Death Move interface for the character.
     * @type {ApplicationClickAction}
     */
    static async #makeDeathMove() {
        await new DhpDeathMove(this.document).render({ force: true });
    }

    /**
     * Opens a compendium pack given its dataset key.
     * @type {ApplicationClickAction}
     */
    static async #openPack(_event, button) {
        const { key } = button.dataset;

        const presets = {
            compendium: 'daggerheart',
            folder: key,
            filter:
                key === 'subclasses'
                    ? {
                          'system.linkedClass.uuid': {
                              key: 'system.linkedClass.uuid',
                              value: this.document.system.class.value._stats.compendiumSource
                          }
                      }
                    : undefined,
            render: {
                noFolder: true
            }
        };

        return new ItemBrowser({ presets }).render({ force: true });
    }

    /**
     * Rolls an attribute check based on the clicked button's dataset attribute.
     * @type {ApplicationClickAction}
     */
    static async #rollAttribute(event, button) {
        const abilityLabel = game.i18n.localize(abilities[button.dataset.attribute].label);
        const config = {
            event: event,
            title: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${this.actor.name}`,
            headerTitle: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: abilityLabel
            }),
            roll: {
                trait: button.dataset.attribute
            },
            hasRoll: true
        };
        const result = await this.document.diceRoll({
            ...config,
            headerTitle: `${game.i18n.localize('DAGGERHEART.GENERAL.dualityRoll')}: ${this.actor.name}`,
            title: game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                ability: abilityLabel
            })
        });

        this.consumeResource(result?.costs);
    }

    // Remove when Action Refactor part #2 done
    async consumeResource(costs) {
        if (!costs?.length) return;
        const usefulResources = {
            ...foundry.utils.deepClone(this.actor.system.resources),
            fear: {
                value: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
                max: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                reversed: false
            }
        };
        const resources = game.system.api.fields.ActionFields.CostField.getRealCosts(costs).map(c => {
            const resource = usefulResources[c.key];
            return {
                key: c.key,
                value: (c.total ?? c.value) * (resource.isReversed ? 1 : -1),
                target: resource.target,
                keyIsID: resource.keyIsID
            };
        });

        await this.actor.modifyResource(resources);
    }

    //TODO: redo toggleEquipItem method

    /**
     * Toggles the equipped state of an item (armor or weapon).
     * @type {ApplicationClickAction}
     */
    static async #toggleEquipItem(_event, button) {
        const item = await getDocFromElement(button);
        if (!item) return;
        if (item.system.equipped) {
            await item.update({ 'system.equipped': false });
            return;
        }

        switch (item.type) {
            case 'armor':
                const currentArmor = this.document.system.armor;
                if (currentArmor) {
                    await currentArmor.update({ 'system.equipped': false });
                }

                await item.update({ 'system.equipped': true });
                break;
            case 'weapon':
                if (this.document.effects.find(x => !x.disabled && x.type === 'beastform')) {
                    return ui.notifications.warn(
                        game.i18n.localize('DAGGERHEART.UI.Notifications.beastformEquipWeapon')
                    );
                }

                await this.document.system.constructor.unequipBeforeEquip.bind(this.document.system)(item);

                await item.update({ 'system.equipped': true });
                break;
        }
    }

    /**
     * Toggles the current view of the character's loadout display.
     * @type {ApplicationClickAction}
     */
    static async #toggleLoadoutView(_, button) {
        const newAbilityView = button.dataset.value !== 'true';
        await game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.displayDomainCardsAsList, newAbilityView);
        this.render();
    }

    /**
     * Toggles a hope resource value.
     * @type {ApplicationClickAction}
     */
    static async #toggleHope(_, button) {
        const hopeValue = Number.parseInt(button.dataset.value);
        const newValue = this.document.system.resources.hope.value >= hopeValue ? hopeValue - 1 : hopeValue;
        await this.document.update({ 'system.resources.hope.value': newValue });
    }

    /**
     * Toggles whether an item is stored in the vault.
     * @type {ApplicationClickAction}
     */
    static async #toggleVault(_event, button) {
        const doc = await getDocFromElement(button);
        const { available } = this.document.system.loadoutSlot;
        if (doc.system.inVault && !available) {
            return ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.loadoutMaxReached'));
        }

        await doc?.update({ 'system.inVault': !doc.system.inVault });
    }

    /**
     * Toggle the used state of a resource dice.
     * @type {ApplicationClickAction}
     */
    static async #toggleResourceDice(event, target) {
        const item = await getDocFromElement(target);

        const { dice } = event.target.closest('.item-resource').dataset;
        const diceState = item.system.resource.diceStates[dice];

        await item.update({
            [`system.resource.diceStates.${dice}.used`]: diceState ? !diceState.used : true
        });
    }

    /**
     * Temp
     */
    static async #tempBrowser(_, target) {
        new ItemBrowser().render({ force: true });
    }

    /**
     * Handle the roll values of resource dice.
     * @type {ApplicationClickAction}
     */
    static async #handleResourceDice(_, target) {
        const item = await getDocFromElement(target);
        if (!item) return;

        const rollValues = await game.system.api.applications.dialogs.ResourceDiceDialog.create(item, this.document);
        if (!rollValues) return;

        await item.update({
            'system.resource.diceStates': rollValues.reduce((acc, state, index) => {
                acc[index] = { value: state.value, used: state.used };
                return acc;
            }, {})
        });
    }

    /**
     *  Open the downtime application.
     * @type {ApplicationClickAction}
     */
    static useDowntime(_, button) {
        new game.system.api.applications.dialogs.Downtime(this.document, button.dataset.type === 'shortRest').render({
            force: true
        });
    }

    async _onDragStart(event) {
        const item = await getDocFromElement(event.target);

        const dragData = {
            type: item.documentName,
            uuid: item.uuid
        };

        event.dataTransfer.setData('text/plain', JSON.stringify(dragData));

        super._onDragStart(event);
    }

    async _onDrop(event) {
        // Prevent event bubbling to avoid duplicate handling
        event.preventDefault();
        event.stopPropagation();

        super._onDrop(event);
        this._onDropItem(event, TextEditor$2.getDragEventData(event));
    }

    async _onDropItem(event, data) {
        const item = await Item.implementation.fromDropData(data);
        const itemData = item.toObject();

        if (item.type === 'domainCard' && !this.document.system.loadoutSlot.available) {
            itemData.system.inVault = true;
        }

        if (this.document.uuid === item.parent?.uuid) return this._onSortItem(event, itemData);
        const createdItem = await this._onDropItemCreate(itemData);

        return createdItem;
    }

    async _onDropItemCreate(itemData, event) {
        itemData = itemData instanceof Array ? itemData : [itemData];
        return this.document.createEmbeddedDocuments('Item', itemData);
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DhCompanionSheet extends DHBaseActorSheet {
    static DEFAULT_OPTIONS = {
        classes: ['actor', 'companion'],
        position: { width: 340 },
        actions: {
            levelManagement: DhCompanionSheet.#levelManagement
        }
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/actors/companion/header.hbs' },
        details: { template: 'systems/daggerheart/templates/sheets/actors/companion/details.hbs' },
        effects: { template: 'systems/daggerheart/templates/sheets/actors/companion/effects.hbs' }
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'effects' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /** @inheritDoc */
    async _onRender(context, options) {
        await super._onRender(context, options);

        this.element
            .querySelector('.level-value')
            ?.addEventListener('change', event => this.document.updateLevel(Number(event.currentTarget.value)));
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Opens the companions level management window.
     * @type {ApplicationClickAction}
     */
    static #levelManagement() {
        new DhCompanionLevelUp(this.document).render({ force: true });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DhpEnvironment extends DHBaseActorSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['environment'],
        position: {
            width: 500,
            height: 725
        },
        window: {
            resizable: true
        },
        actions: {},
        dragDrop: [{ dragSelector: '.action-section .inventory-item', dropSelector: null }]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/actors/environment/header.hbs' },
        features: { template: 'systems/daggerheart/templates/sheets/actors/environment/features.hbs' },
        potentialAdversaries: {
            template: 'systems/daggerheart/templates/sheets/actors/environment/potentialAdversaries.hbs'
        },
        notes: { template: 'systems/daggerheart/templates/sheets/actors/environment/notes.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'features' }, { id: 'potentialAdversaries' }, { id: 'notes' }],
            initial: 'features',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        context = await super._preparePartContext(partId, context, options);
        switch (partId) {
            case 'header':
                await this._prepareHeaderContext(context, options);
                break;
            case 'notes':
                await this._prepareNotesContext(context, options);
                break;
        }
        return context;
    }

    /**
     * Prepare render context for the Biography part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareNotesContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        const paths = {
            notes: 'notes'
        };

        for (const [key, path] of Object.entries(paths)) {
            const value = foundry.utils.getProperty(system, path);
            context[key] = {
                field: system.schema.getField(path),
                value,
                enriched: await TextEditor.implementation.enrichHTML(value, {
                    secrets: this.document.isOwner,
                    relativeTo: this.document
                })
            };
        }
    }

    /**
     * Prepare render context for the Header part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareHeaderContext(context, _options) {
        const { system } = this.document;
        const { TextEditor } = foundry.applications.ux;

        context.description = await TextEditor.implementation.enrichHTML(system.description, {
            secrets: this.document.isOwner,
            relativeTo: this.document
        });
    }

    /* -------------------------------------------- */

    async _onDragStart(event) {
        const item = event.currentTarget.closest('.inventory-item');

        if (item) {
            const adversaryData = { type: 'Actor', uuid: item.dataset.itemUuid };
            event.dataTransfer.setData('text/plain', JSON.stringify(adversaryData));
            event.dataTransfer.setDragImage(item, 60, 0);
        }
    }
}

var _module$a = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Adversary: AdversarySheet,
    Character: CharacterSheet,
    Companion: DhCompanionSheet,
    Environment: DhpEnvironment
});

const { ItemSheetV2 } = foundry.applications.sheets;

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

/**
 * A base item sheet extending {@link ItemSheetV2} via {@link DHApplicationMixin}
 */
class DHBaseItemSheet extends DHApplicationMixin(ItemSheetV2) {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['item'],
        position: { width: 600 },
        window: { resizable: true },
        form: {
            submitOnChange: true
        },
        actions: {
            addFeature: DHBaseItemSheet.#addFeature,
            deleteFeature: DHBaseItemSheet.#deleteFeature,
            addResource: DHBaseItemSheet.#addResource,
            removeResource: DHBaseItemSheet.#removeResource
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features .drop-section' },
            { dragSelector: '.feature-item', dropSelector: null },
            { dragSelector: '.action-item', dropSelector: null }
        ],
        contextMenus: [
            {
                handler: DHBaseItemSheet.#getFeatureContextOptions,
                selector: '[data-item-uuid][data-type="feature"]',
                options: {
                    parentClassHooks: false,
                    fixed: true
                }
            }
        ]
    };

    /* -------------------------------------------- */

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'settings' }, { id: 'actions' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /* -------------------------------------------- */
    /*  Prepare Context                             */
    /* -------------------------------------------- */

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        await super._preparePartContext(partId, context, options);
        const { TextEditor } = foundry.applications.ux;

        switch (partId) {
            case 'description':
                const value = foundry.utils.getProperty(this.document, 'system.description') ?? '';
                context.enrichedDescription = await TextEditor.enrichHTML(value, {
                    relativeTo: this.item,
                    rollData: this.item.getRollData(),
                    secrets: this.item.isOwner
                });
                break;
            case 'effects':
                await this._prepareEffectsContext(context, options);
                break;
            case 'features':
                context.isGM = game.user.isGM;
                break;
        }

        return context;
    }

    /**
     * Prepare render context for the Effect part.
     * @param {ApplicationRenderContext} context
     * @param {ApplicationRenderOptions} options
     * @returns {Promise<void>}
     * @protected
     */
    async _prepareEffectsContext(context, _options) {
        context.effects = {
            actives: [],
            inactives: []
        };

        for (const effect of this.item.effects) {
            const list = effect.active ? context.effects.actives : context.effects.inactives;
            list.push(effect);
        }
    }

    /* -------------------------------------------- */
    /*  Context Menu                                */
    /* -------------------------------------------- */

    /**
     * Get the set of ContextMenu options for Features.
     * @returns {import('@client/applications/ux/context-menu.mjs').ContextMenuEntry[]} - The Array of context options passed to the ContextMenu instance
     * @this {DHBaseItemSheet}
     * @protected
     */
    static #getFeatureContextOptions() {
        const options = this._getContextMenuCommonOptions({ usable: true, toChat: true, deletable: false });
        options.push({
            name: 'CONTROLS.CommonDelete',
            icon: '<i class="fa-solid fa-trash"></i>',
            callback: async target => {
                const feature = await getDocFromElement(target);
                if (!feature) return;
                const confirmed = await foundry.applications.api.DialogV2.confirm({
                    window: {
                        title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                            type: game.i18n.localize(`TYPES.Item.feature`),
                            name: feature.name
                        })
                    },
                    content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', {
                        name: feature.name
                    })
                });
                if (!confirmed) return;
                await this.document.update({
                    'system.features': this.document.system.toObject().features.filter(uuid => uuid !== feature.uuid)
                });
            }
        });
        return options;
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Add a new feature to the item, prompting the user for its type.
     * @type {ApplicationClickAction}
     */
    static async #addFeature(_, target) {
        const { type } = target.dataset;
        const cls = foundry.documents.Item.implementation;

        const multiclass = this.document.system.isMulticlass ? 'multiclass' : null;
        let systemData = {};
        if (this.document.parent?.type === 'character') {
            systemData = {
                originItemType: this.document.type,
                identifier: multiclass ?? type
            };
        }

        const item = await cls.create(
            {
                type: 'feature',
                name: cls.defaultName({ type: 'feature' }),
                system: systemData
            },
            { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
        );
        await this.document.update({
            'system.features': [...this.document.system.features, { type, item }].map(x => ({
                ...x,
                item: x.item?.uuid
            }))
        });
    }

    /**
     * Remove a feature from the item.
     * @type {ApplicationClickAction}
     */
    static async #deleteFeature(_, element) {
        const target = element.closest('[data-item-uuid]');
        const feature = await getDocFromElement(target);
        if (!feature) {
            await this.document.update({
                'system.features': this.document.system.features
                    .filter(x => x.item)
                    .map(x => ({ ...x, item: x.item.uuid }))
            });
        } else
            await this.document.update({
                'system.features': this.document.system.features
                    .filter(x => target.dataset.type !== x.type || x.item.uuid !== feature.uuid)
                    .map(x => ({ ...x, item: x.item.uuid }))
            });
    }

    /**
     * Add a resource to the item.
     * @type {ApplicationClickAction}
     */
    static async #addResource() {
        await this.document.update({
            'system.resource': { type: 'simple', value: 0 }
        });
    }

    /**
     * Remove the resource from the item.
     * @type {ApplicationClickAction}
     */
    static async #removeResource() {
        await this.document.update({
            'system.resource': null
        });
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    /**
     * On dragStart on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDragStart(event) {
        const featureItem = event.currentTarget.closest('.feature-item');

        if (featureItem) {
            const feature = this.document.system.features.find(x => x?.id === featureItem.id);
            if (!feature) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.featureIsMissing'));
                return;
            }

            const featureData = { type: 'Item', data: { ...feature.toObject(), _id: null }, fromInternal: true };
            event.dataTransfer.setData('text/plain', JSON.stringify(featureData));
            event.dataTransfer.setDragImage(featureItem.querySelector('img'), 60, 0);
        } else {
            const actionItem = event.currentTarget.closest('.action-item');
            if (actionItem) {
                const action = this.document.system.actions[actionItem.dataset.index];
                if (!action) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.actionIsMissing'));
                    return;
                }

                const actionData = {
                    type: 'Action',
                    data: { ...action.toObject(), id: action.id, itemUuid: this.document.uuid },
                    fromInternal: true
                };
                event.dataTransfer.setData('text/plain', JSON.stringify(actionData));
                event.dataTransfer.setDragImage(actionItem.querySelector('img'), 60, 0);
            } else {
                super._onDragStart(event);
            }
        }
    }

    /**
     * On drop on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDrop(event) {
        super._onDrop(event);

        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        if (data.fromInternal) return;

        const target = event.target.closest('fieldset.drop-section');
        let item = await fromUuid(data.uuid);
        if (item?.type === 'feature') {
            const cls = foundry.documents.Item.implementation;

            if (this.document.parent?.type === 'character') {
                const itemData = item.toObject();
                const multiclass = this.document.system.isMulticlass ? 'multiclass' : null;
                item = await cls.create(
                    {
                        ...itemData,
                        _stats: { compendiumSource: this.document.uuid },
                        system: {
                            ...itemData.system,
                            originItemType: this.document.type,
                            identifier: multiclass ?? target.dataset.type
                        }
                    },
                    { parent: this.document.parent }
                );
            }

            if (target.dataset.type) {
                await this.document.update(
                    {
                        'system.features': [...this.document.system.features, { type: target.dataset.type, item }].map(
                            x => ({
                                ...x,
                                item: x.item?.uuid
                            })
                        )
                    },
                    { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
                );
            } else {
                await this.document.update(
                    {
                        'system.features': [...this.document.system.features, item].map(x => x.uuid)
                    },
                    { parent: this.document.parent?.type === 'character' ? this.document.parent : undefined }
                );
            }
        }
    }
}

class DHHeritageSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        position: { width: 450, height: 700 }
    };

    /**@override */
    static PARTS = {
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @override*/
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'features' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };
}

function ItemAttachmentSheet(Base) {
    return class extends Base {
        static DEFAULT_OPTIONS = {
            ...super.DEFAULT_OPTIONS,
            dragDrop: [
                ...(super.DEFAULT_OPTIONS.dragDrop || []),
                { dragSelector: null, dropSelector: '.attachments-section' }
            ],
            actions: {
                ...super.DEFAULT_OPTIONS.actions,
                removeAttachment: this.#removeAttachment
            }
        };

        static PARTS = {
            ...super.PARTS,
            attachments: {
                template: 'systems/daggerheart/templates/sheets/global/tabs/tab-attachments.hbs',
                scrollable: ['.attachments']
            }
        };

        static TABS = {
            ...super.TABS,
            primary: {
                ...super.TABS?.primary,
                tabs: [...(super.TABS?.primary?.tabs || []) /*{ id: 'attachments' }*/], // Disabled until fixed
                initial: super.TABS?.primary?.initial || 'description',
                labelPrefix: super.TABS?.primary?.labelPrefix || 'DAGGERHEART.GENERAL.Tabs'
            }
        };

        async _preparePartContext(partId, context) {
            await super._preparePartContext(partId, context);

            if (partId === 'attachments') {
                context.attachedItems = await prepareAttachmentContext(this.document);
            }

            return context;
        }

        async _onDrop(event) {
            const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);

            const attachmentsSection = event.target.closest('.attachments-section');
            if (!attachmentsSection) return super._onDrop(event);

            event.preventDefault();
            event.stopPropagation();

            const item = await Item.implementation.fromDropData(data);
            if (!item) return;

            // Call the data model's public method
            await this.document.system.addAttachment(item);
        }

        static async #removeAttachment(event, target) {
            // Call the data model's public method
            await this.document.system.removeAttachment(target.dataset.uuid);
        }

        async _preparePartContext(partId, context) {
            await super._preparePartContext(partId, context);

            if (partId === 'attachments') {
                // Keep this simple UI preparation in the mixin
                const attachedUUIDs = this.document.system.attached;
                context.attachedItems = await Promise.all(
                    attachedUUIDs.map(async uuid => {
                        const item = await fromUuid(uuid);
                        return {
                            uuid: uuid,
                            name: item?.name || 'Unknown Item',
                            img: item?.img || 'icons/svg/item-bag.svg'
                        };
                    })
                );
            }

            return context;
        }
    };
}

var _modules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHApplicationMixin: DHApplicationMixin,
    DHBaseActorSettings: DHBaseActorSettings,
    DHBaseActorSheet: DHBaseActorSheet,
    DHBaseItemSheet: DHBaseItemSheet,
    DHHeritageSheet: DHHeritageSheet,
    DHItemAttachmentSheet: ItemAttachmentSheet
});

class AncestrySheet extends DHHeritageSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['ancestry']
    };

    /**@inheritdoc */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/ancestry/header.hbs' },
        ...super.PARTS,
        features: { template: 'systems/daggerheart/templates/sheets/items/ancestry/features.hbs' }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }

    /* -------------------------------------------- */
    /*  Application Drag/Drop                       */
    /* -------------------------------------------- */

    /**
     * On drop on the item.
     * @param {DragEvent} event - The drag event
     */
    async _onDrop(event) {
        const data = TextEditor.getDragEventData(event);
        if (data.type === 'ActiveEffect') return super._onDrop(event);

        const target = event.target.closest('fieldset.drop-section');
        const typeField =
            this.document.system[target.dataset.type === 'primary' ? 'primaryFeature' : 'secondaryFeature'];

        if (!typeField) {
            super._onDrop(event);
        }
    }
}

class ArmorSheet extends ItemAttachmentSheet(DHBaseItemSheet) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['armor'],
        tagifyConfigs: [
            {
                selector: '.features-input',
                options: () => CONFIG.DH.ITEM.armorFeatures,
                callback: ArmorSheet.#onFeatureSelect
            }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/armor/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/armor/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        },
        ...super.PARTS
    };

    /**@inheritdoc */
    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);

        switch (partId) {
            case 'settings':
                context.features = this.document.system.armorFeatures.map(x => x.value);
                break;
        }

        return context;
    }

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onFeatureSelect(selectedOptions) {
        await this.document.update({ 'system.armorFeatures': selectedOptions.map(x => ({ value: x.value })) });
    }
}

class BeastformSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['beastform']
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/beastform/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        settings: { template: 'systems/daggerheart/templates/sheets/items/beastform/settings.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-features.hbs',
            scrollable: ['.features']
        },
        advanced: { template: 'systems/daggerheart/templates/sheets/items/beastform/advanced.hbs' },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    static TABS = {
        primary: {
            tabs: [{ id: 'settings' }, { id: 'features' }, { id: 'advanced' }, { id: 'effects' }],
            initial: 'settings',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features;
    }

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        const advantageOnInput = htmlElement.querySelector('.advantageon-input');
        if (advantageOnInput) {
            const tagifyElement = new Q(advantageOnInput, {
                tagTextProp: 'name',
                templates: {
                    tag(tagData) {
                        return `<tag
                                    contenteditable='false'
                                    spellcheck='false'
                                    tabIndex="${this.settings.a11y.focusableTags ? 0 : -1}"
                                    class="${this.settings.classNames.tag} ${tagData.class ? tagData.class : ''}"
                                    ${this.getAttributes(tagData)}> 
                            <x class="${this.settings.classNames.tagX}" role='button' aria-label='remove tag'></x>
                            <div>
                                <span class="${this.settings.classNames.tagText}">${tagData[this.settings.tagTextProp] || tagData.value}</span>
                                ${tagData.src ? `<img src="${tagData.src}"></i>` : ''}
                            </div>
                        </tag>`;
                    }
                }
            });
            tagifyElement.on('add', this.advantageOnAdd.bind(this));
            tagifyElement.on('remove', this.advantageOnRemove.bind(this));
        }
    }

    /**@inheritdoc */
    async _preparePartContext(partId, context, options) {
        await super._preparePartContext(partId, context, options);

        switch (partId) {
            case 'settings':
                context.advantageOn = JSON.stringify(
                    Object.keys(context.document.system.advantageOn).map(key => ({
                        value: key,
                        name: context.document.system.advantageOn[key].value
                    }))
                );
                break;
            case 'effects':
                context.effects.actives = context.effects.actives.map(effect => {
                    const data = effect.toObject();
                    data.uuid = effect.uuid;
                    data.id = effect.id;
                    if (effect.type === 'beastform') data.mandatory = true;

                    return data;
                });
                break;
        }

        return context;
    }

    async advantageOnAdd(event) {
        await this.document.update({
            [`system.advantageOn.${foundry.utils.randomID()}`]: { value: event.detail.data.value }
        });
    }

    async advantageOnRemove(event) {
        await this.document.update({
            [`system.advantageOn.-=${event.detail.data.value}`]: null
        });
    }
}

const { TextEditor: TextEditor$1 } = foundry.applications.ux;

class ClassSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['class'],
        position: { width: 700 },
        actions: {
            removeItemFromCollection: ClassSheet.#removeItemFromCollection,
            removeSuggestedItem: ClassSheet.#removeSuggestedItem
        },
        tagifyConfigs: [
            {
                selector: '.domain-input',
                options: () => CONFIG.DH.DOMAIN.orderedDomains(),
                callback: ClassSheet.#onDomainSelect,
                tagifyOptions: {
                    maxTags: () => game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxDomains
                }
            }
        ],
        dragDrop: [
            { dragSelector: '.suggested-item', dropSelector: null },
            { dragSelector: null, dropSelector: '.take-section' },
            { dragSelector: null, dropSelector: '.choice-a-section' },
            { dragSelector: null, dropSelector: '.choice-b-section' },
            { dragSelector: null, dropSelector: '.primary-weapon-section' },
            { dragSelector: null, dropSelector: '.secondary-weapon-section' },
            { dragSelector: null, dropSelector: '.armor-section' },
            { dragSelector: null, dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/class/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/items/class/features.hbs',
            scrollable: ['.features']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/class/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'features' }, { id: 'settings' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }

    /**@inheritdoc */
    async _onFirstRender(context, options) {
        await super._onFirstRender(context, options);

        const paths = [
            'subclasses',
            'characterGuide.suggestedPrimaryWeapon',
            'characterGuide.suggestedSecondaryWeapon',
            'characterGuide.suggestedArmor',
            'inventory.take',
            'inventory.choiceA',
            'inventory.choiceB'
        ];

        for (let path of paths) {
            const docDatas = [].concat(foundry.utils.getProperty(this.document, `system.${path}`) ?? []);

            const docs = [];
            for (var docData of docDatas) {
                const doc = await foundry.utils.fromUuid(docData.uuid);
                docs.push(doc);
            }

            docs.filter(doc => doc).forEach(doc => (doc.apps[this.id] = this));
        }
    }

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.domains = this.document.system.domains;
        return context;
    }

    /* -------------------------------------------- */

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onDomainSelect(selectedOptions) {
        await this.document.update({ 'system.domains': selectedOptions.map(x => x.value) });
    }

    /* -------------------------------------------- */

    async _onDrop(event) {
        event.stopPropagation();
        const data = TextEditor$1.getDragEventData(event);
        const item = data.data ?? (await fromUuid(data.uuid));
        const itemType = data.data ? data.type : item.type;
        const target = event.target.closest('fieldset.drop-section');
        if (itemType === 'subclass') {
            if (item.system.linkedClass) {
                return ui.notifications.warn(
                    game.i18n.format('DAGGERHEART.UI.Notifications.subclassAlreadyLinked', {
                        name: item.name,
                        class: this.document.name
                    })
                );
            }
            await item.update({ 'system.linkedClass': this.document.uuid });
            await this.document.update({
                'system.subclasses': [...this.document.system.subclasses.map(x => x.uuid), item.uuid]
            });
        } else if (['feature', 'ActiveEffect'].includes(itemType)) {
            super._onDrop(event);
        } else if (this.document.parent?.type !== 'character') {
            if (itemType === 'weapon') {
                if (target.classList.contains('primary-weapon-section')) {
                    if (!item.system.secondary)
                        await this.document.update({
                            'system.characterGuide.suggestedPrimaryWeapon': item.uuid
                        });
                } else if (target.classList.contains('secondary-weapon-section')) {
                    if (item.system.secondary)
                        await this.document.update({
                            'system.characterGuide.suggestedSecondaryWeapon': item.uuid
                        });
                }
            } else if (itemType === 'armor') {
                if (target.classList.contains('armor-section')) {
                    await this.document.update({
                        'system.characterGuide.suggestedArmor': item.uuid
                    });
                }
            } else if (target.classList.contains('choice-a-section')) {
                if (itemType === 'loot' || itemType === 'consumable') {
                    const filteredChoiceA = this.document.system.inventory.choiceA;
                    if (filteredChoiceA.length < 2)
                        await this.document.update({
                            'system.inventory.choiceA': [...filteredChoiceA.map(x => x.uuid), item.uuid]
                        });
                }
            } else if (itemType === 'loot') {
                if (target.classList.contains('take-section')) {
                    const filteredTake = this.document.system.inventory.take.filter(x => x);
                    if (filteredTake.length < 3)
                        await this.document.update({
                            'system.inventory.take': [...filteredTake.map(x => x.uuid), item.uuid]
                        });
                } else if (target.classList.contains('choice-b-section')) {
                    const filteredChoiceB = this.document.system.inventory.choiceB.filter(x => x);
                    if (filteredChoiceB.length < 2)
                        await this.document.update({
                            'system.inventory.choiceB': [...filteredChoiceB.map(x => x.uuid), item.uuid]
                        });
                }
            }
        }
    }

    /* -------------------------------------------- */
    /*  Application Clicks Actions                  */
    /* -------------------------------------------- */

    /**
     * Removes an item from an class collection by UUID.
     * @param {PointerEvent} event - The originating click event
     * @param {HTMLElement} element - The capturing HTML element which defines the [data-action="removeItemFromCollection"]
     */
    static async #removeItemFromCollection(_event, element) {
        const { uuid, target } = element.dataset;
        const prop = foundry.utils.getProperty(this.document.system, target);

        if (target === 'subclasses') {
            const subclass = await foundry.utils.fromUuid(uuid);
            await subclass.update({ 'system.linkedClass': null });
        }

        await this.document.update({ [`system.${target}`]: prop.filter(i => i.uuid !== uuid).map(x => x.uuid) });
    }

    /**
     * Removes an suggested item from the class.
     * @param {PointerEvent} _event - The originating click event
     * @param {HTMLElement} element - The capturing HTML element which defines the [data-action="removeSuggestedItem"]
     */
    static async #removeSuggestedItem(_event, element) {
        const { target } = element.dataset;
        await this.document.update({ [`system.characterGuide.${target}`]: null });
    }
}

class CommunitySheet extends DHHeritageSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['community']
    };

    /**@inheritdoc */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/community/header.hbs' },
        ...super.PARTS,
        features: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-features.hbs',
            scrollable: ['.feature']
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features;
    }
}

class ConsumableSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['consumable'],
        position: { width: 550 }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/consumable/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/consumable/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };
}

class DomainCardSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['domain-card'],
        position: { width: 450, height: 700 }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'actions' }, { id: 'settings' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/domainCard/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/domainCard/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.domain = CONFIG.DH.DOMAIN.allDomains()[this.document.system.domain];
        context.domainChoices = CONFIG.DH.DOMAIN.orderedDomains();

        return context;
    }
}

class FeatureSheet extends DHBaseItemSheet {
    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['feature'],
        actions: {}
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/feature/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        settings: { template: 'systems/daggerheart/templates/sheets/items/feature/settings.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /**@override */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'settings' }, { id: 'actions' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };
}

class LootSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['loot'],
        position: { width: 550 }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/loot/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/loot/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };
}

class SubclassSheet extends DHBaseItemSheet {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['subclass'],
        position: { width: 600 },
        window: { resizable: true }
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/subclass/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        features: {
            template: 'systems/daggerheart/templates/sheets/items/subclass/features.hbs',
            scrollable: ['.features']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/subclass/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'description' }, { id: 'features' }, { id: 'settings' }, { id: 'effects' }],
            initial: 'description',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    get relatedDocs() {
        return this.document.system.features.map(x => x.item);
    }
}

class WeaponSheet extends ItemAttachmentSheet(DHBaseItemSheet) {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['weapon'],
        tagifyConfigs: [
            {
                selector: '.features-input',
                options: () => CONFIG.DH.ITEM.weaponFeatures,
                callback: WeaponSheet.#onFeatureSelect
            }
        ]
    };

    /**@override */
    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/items/weapon/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        description: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-description.hbs' },
        actions: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-actions.hbs',
            scrollable: ['.actions']
        },
        settings: {
            template: 'systems/daggerheart/templates/sheets/items/weapon/settings.hbs',
            scrollable: ['.settings']
        },
        effects: {
            template: 'systems/daggerheart/templates/sheets/global/tabs/tab-effects.hbs',
            scrollable: ['.effects']
        },
        ...super.PARTS
    };

    /**@inheritdoc */
    async _preparePartContext(partId, context) {
        await super._preparePartContext(partId, context);
        switch (partId) {
            case 'settings':
                context.features = this.document.system.weaponFeatures.map(x => x.value);
                context.systemFields.attack.fields = this.document.system.attack.schema.fields;
                break;
        }
        return context;
    }

    /**
     * Callback function used by `tagifyElement`.
     * @param {Array<Object>} selectedOptions - The currently selected tag objects.
     */
    static async #onFeatureSelect(selectedOptions) {
        await this.document.update({ 'system.weaponFeatures': selectedOptions.map(x => ({ value: x.value })) });
    }
}

var _module$9 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Ancestry: AncestrySheet,
    Armor: ArmorSheet,
    Beastform: BeastformSheet,
    Class: ClassSheet,
    Community: CommunitySheet,
    Consumable: ConsumableSheet,
    DomainCard: DomainCardSheet,
    Feature: FeatureSheet,
    Loot: LootSheet,
    Subclass: SubclassSheet,
    Weapon: WeaponSheet
});

var _module$8 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actors: _module$a,
    api: _modules$1,
    items: _module$9
});

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHCharacterSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['character-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHCharacterSettings.#addExperience,
            removeExperience: DHCharacterSettings.#removeExperience
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/details.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/character-settings/experiences.hbs'
        }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'experiences' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);
        context.levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        return context;
    }

    /* -------------------------------------------- */

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const updates = {};

        const relinkAchievementData = [];
        const relinkSelectionData = [];
        Object.keys(this.actor.system.levelData.levelups).forEach(key => {
            const level = this.actor.system.levelData.levelups[key];

            const achievementIncludesExp = level.achievements.experiences[target.dataset.experience];
            if (achievementIncludesExp)
                relinkAchievementData.push({ levelKey: key, experience: target.dataset.experience });

            const selectionIndex = level.selections.findIndex(
                x => x.optionKey === 'experience' && x.data[0] === target.dataset.experience
            );
            if (selectionIndex !== -1)
                relinkSelectionData.push({ levelKey: key, selectionIndex, experience: target.dataset.experience });
        });

        if (relinkAchievementData.length > 0 || relinkSelectionData.length > 0) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.experienceDataRemoveConfirmation.title')
                },
                content: game.i18n.localize('DAGGERHEART.ACTORS.Character.experienceDataRemoveConfirmation.text')
            });
            if (!confirmed) return;
        }

        if (relinkAchievementData.length > 0) {
            relinkAchievementData.forEach(data => {
                updates[`system.levelData.levelups.${data.levelKey}.achievements.experiences.-=${data.experience}`] =
                    null;
            });
        } else if (relinkSelectionData.length > 0) {
            relinkSelectionData.forEach(data => {
                updates[`system.levelData.levelups.${data.levelKey}.selections`] = this.actor.system.levelData.levelups[
                    data.levelKey
                ].selections.reduce((acc, selection, index) => {
                    if (
                        index === data.selectionIndex &&
                        selection.optionKey === 'experience' &&
                        selection.data.includes(data.experience)
                    ) {
                        acc.push({ ...selection, data: selection.data.filter(x => x !== data.experience) });
                    } else {
                        acc.push(selection);
                    }

                    return acc;
                }, []);
            });
        } else {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                        type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                        name: experience.name
                    })
                },
                content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
            });
            if (!confirmed) return;
        }

        await this.actor.update({
            ...updates,
            [`system.experiences.-=${target.dataset.experience}`]: null
        });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHAdversarySettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['adversary-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHAdversarySettings.#addExperience,
            removeExperience: DHAdversarySettings.#removeExperience
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/details.hbs'
        },
        attack: {
            id: 'attack',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/attack.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/experiences.hbs'
        },
        features: {
            id: 'features',
            template: 'systems/daggerheart/templates/sheets-settings/adversary-settings/features.hbs'
        }
    };

    /** @override */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'attack' }, { id: 'experiences' }, { id: 'features' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /* -------------------------------------------- */

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                    name: experience.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
        });
        if (!confirmed) return;

        await this.actor.update({ [`system.experiences.-=${target.dataset.experience}`]: null });
    }

    async _onDragStart(event) {
        const featureItem = event.currentTarget.closest('.feature-item');

        if (featureItem) {
            const feature = this.actor.items.get(featureItem.id);
            const featureData = { type: 'Item', uuid: feature.uuid, fromInternal: true };
            event.dataTransfer.setData('text/plain', JSON.stringify(featureData));
            event.dataTransfer.setDragImage(featureItem.querySelector('img'), 60, 0);
        }
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        
        const item = await fromUuid(data.uuid);
        if (item?.type === 'feature') {
            if (data.fromInternal && item.parent?.uuid === this.actor.uuid) {
                return;
            }
            
            const itemData = item.toObject();
            delete itemData._id;
            
            await this.actor.createEmbeddedDocuments('Item', [itemData]);
        }
    }
}

function handleSocketEvent({ action = null, data = {} } = {}) {
    switch (action) {
        case socketEvent.GMUpdate:
            Hooks.callAll(socketEvent.GMUpdate, data);
            break;
        case socketEvent.DhpFearUpdate:
            Hooks.callAll(socketEvent.DhpFearUpdate);
            break;
        case socketEvent.Refresh:
            Hooks.call(socketEvent.Refresh, data);
            break;
    }
}

const socketEvent = {
    GMUpdate: 'DhGMUpdate',
    Refresh: 'DhRefresh',
    DhpFearUpdate: 'DhFearUpdate'
};

const GMUpdateEvent = {
    UpdateDocument: 'DhGMUpdateDocument',
    UpdateSetting: 'DhGMUpdateSetting',
    UpdateFear: 'DhGMUpdateFear',
    UpdateSaveMessage: 'DhGMUpdateSaveMessage'
};

const RefreshType = {
    Countdown: 'DhCoundownRefresh'
};

const registerSocketHooks = () => {
    Hooks.on(socketEvent.GMUpdate, async data => {
        if (game.user.isGM) {
            const document = data.uuid ? await fromUuid(data.uuid) : null;
            switch (data.action) {
                case GMUpdateEvent.UpdateDocument:
                    if (document && data.update) {
                        await document.update(data.update);
                    }
                    break;
                case GMUpdateEvent.UpdateSetting:
                    await game.settings.set(CONFIG.DH.id, data.uuid, data.update);
                    break;
                case GMUpdateEvent.UpdateFear:
                    await game.settings.set(
                        CONFIG.DH.id,
                        CONFIG.DH.SETTINGS.gameSettings.Resources.Fear,
                        Math.max(
                            0,
                            Math.min(
                                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                                data.update
                            )
                        )
                    );
                    break;
                case GMUpdateEvent.UpdateSaveMessage:
                    const action = await fromUuid(data.update.action),
                        message = game.messages.get(data.update.message);
                    if (!action || !message) return;
                    action.updateSaveMessage(data.update.result, message, data.update.token);
                    break;
            }

            if (data.refresh) {
                await game.socket.emit(`system.${CONFIG.DH.id}`, {
                    action: socketEvent.Refresh,
                    data: data.refresh
                });
                Hooks.call(socketEvent.Refresh, data.refresh);
            }
        }
    });
};

const registerUserQueries = () => {
    CONFIG.queries.armorSlot = DamageReductionDialog.armorSlotQuery;
    CONFIG.queries.reactionRoll = game.system.api.models.actions.actionsTypes.base.rollSaveQuery;
};

const emitAsGM = async (eventName, callback, update, uuid = null) => {
    if (!game.user.isGM) {
        return await game.socket.emit(`system.${CONFIG.DH.id}`, {
            action: socketEvent.GMUpdate,
            data: {
                action: eventName,
                uuid,
                update
            }
        });
    } else return callback(update);
};

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHCompanionSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['companion-settings'],
        position: { width: 455, height: 'auto' },
        actions: {
            addExperience: DHCompanionSettings.#addExperience,
            removeExperience: DHCompanionSettings.#removeExperience
        }
    };

    /**@inheritdoc */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/details.hbs'
        },
        experiences: {
            id: 'experiences',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/experiences.hbs'
        },
        attack: {
            id: 'attack',
            template: 'systems/daggerheart/templates/sheets-settings/companion-settings/attack.hbs'
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'attack' }, { id: 'experiences' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**@inheritdoc */
    async _onRender(context, options) {
        await super._onRender(context, options);
        this.element.querySelector('.partner-value')?.addEventListener('change', this.onPartnerChange.bind(this));
    }

    /**@inheritdoc */
    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);

        context.playerCharacters = game.actors
            .filter(x => x.type === 'character' && (x.isOwner || this.document.system.partner?.uuid === x.uuid))
            .map(x => ({ key: x.uuid, name: x.name }));

        return context;
    }

    /**
     * Handles changes to the actor's partner selection.
     * @param {Event} event - The change event triggered by the partner input element.
     */
    async onPartnerChange(event) {
        const value = event.target.value;
        const partnerDocument = value ? await foundry.utils.fromUuid(value) : this.actor.system.partner;
        const partnerUpdate = { 'system.companion': value ? this.actor.uuid : null };

        if (!partnerDocument.isOwner) {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateDocument,
                    uuid: partnerDocument.uuid,
                    update: partnerUpdate
                }
            });
        } else {
            await partnerDocument.update(partnerUpdate);
        }

        await this.actor.update({ 'system.partner': value });

        if (!value) await this.actor.updateLevel(1);
    }

    /**
     * Adds a new experience entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addExperience() {
        const newExperience = {
            name: 'Experience',
            modifier: 0
        };
        await this.actor.update({ [`system.experiences.${foundry.utils.randomID()}`]: newExperience });
    }

    /**
     * Removes an experience entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeExperience(_, target) {
        const experience = this.actor.system.experiences[target.dataset.experience];
        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize(`DAGGERHEART.GENERAL.Experience.single`),
                    name: experience.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: experience.name })
        });
        if (!confirmed) return;

        await this.actor.update({ [`system.experiences.-=${target.dataset.experience}`]: null });
    }
}

/**
 * @typedef {foundry.data.types.StringFieldOptions} StringFieldOptions
 * @typedef {foundry.data.types.DataFieldContext} DataFieldContext
 */

/**
 * @typedef _FormulaFieldOptions
 * @property {boolean} [deterministic] - Is this formula not allowed to have dice values?
 */

/**
 * @typedef {StringFieldOptions & _FormulaFieldOptions} FormulaFieldOptions
 */

/**
 * Special case StringField which represents a formula.
 */
class FormulaField extends foundry.data.fields.StringField {
    /**
     * @param {FormulaFieldOptions} [options] - Options which configure the behavior of the field
     * @param {foundry.data.types.DataFieldContext} [context] - Additional context which describes the field
     */
    constructor(options, context) {
        super(options, context);
    }

    /** @inheritDoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            deterministic: false
        });
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _validateType(value) {
        /* A bit suss, but seems to work */
        let roll = null;
        try {
            roll = new Roll(value.replace(/@([a-z.0-9_-]+)/gi, '1'));
        } catch (_) {
            roll = new Roll(value.replace(/@([a-z.0-9_-]+)/gi, 'd6'));
        }
        roll.evaluateSync({ strict: false });
        if (this.options.deterministic && !roll.isDeterministic)
            throw new Error(`must not contain dice terms: ${value}`);
        super._validateType(value);
    }

    /* -------------------------------------------- */
    /*  Active Effect Integration                   */
    /* -------------------------------------------- */

    /** @override */
    _castChangeDelta(delta) {
        return this._cast(delta).trim();
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeAdd(value, delta, model, change) {
        if (!value) return delta;
        const operator = delta.startsWith('-') ? '-' : '+';
        delta = delta.replace(/^[+-]/, '').trim();
        return `${value} ${operator} ${delta}`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeMultiply(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length > 1) return `(${value}) * ${delta}`;
        return `${value} * ${delta}`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeUpgrade(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length === 1 && terms[0].fn === 'max') return value.replace(/\)$/, `, ${delta})`);
        return `max(${value}, ${delta})`;
    }

    /* -------------------------------------------- */

    /** @override */
    _applyChangeDowngrade(value, delta, model, change) {
        if (!value) return delta;
        const terms = new Roll(value).terms;
        if (terms.length === 1 && terms[0].fn === 'min') return value.replace(/\)$/, `, ${delta})`);
        return `min(${value}, ${delta})`;
    }
}

const fields$f = foundry.data.fields;

class DamageField extends fields$f.SchemaField {
    constructor(options, context = {}) {
        const damageFields = {
            parts: new fields$f.ArrayField(new fields$f.EmbeddedDataField(DHDamageData)),
            includeBase: new fields$f.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.includeBase.label'
            })
        };
        super(damageFields, options, context);
    }
}

class DHActionDiceData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            multiplier: new fields$f.StringField({
                choices: CONFIG.DH.GENERAL.multiplierTypes,
                initial: 'prof',
                label: 'Multiplier'
            }),
            flatMultiplier: new fields$f.NumberField({ nullable: true, initial: 1, label: 'Flat Multiplier' }),
            dice: new fields$f.StringField({ choices: CONFIG.DH.GENERAL.diceTypes, initial: 'd6', label: 'Dice' }),
            bonus: new fields$f.NumberField({ nullable: true, initial: null, label: 'Bonus' }),
            custom: new fields$f.SchemaField({
                enabled: new fields$f.BooleanField({ label: 'Custom Formula' }),
                formula: new FormulaField({ label: 'Formula', initial: "" })
            })
        };
    }

    getFormula() {
        const multiplier = this.multiplier === 'flat' ? this.flatMultiplier : `@${this.multiplier}`,
            bonus = this.bonus ? (this.bonus < 0 ? ` - ${Math.abs(this.bonus)}` : ` + ${this.bonus}`) : '';
        return this.custom.enabled ? this.custom.formula : `${multiplier ?? 1}${this.dice}${bonus}`;
    }
}

class DHResourceData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            applyTo: new fields$f.StringField({
                choices: CONFIG.DH.GENERAL.healingTypes,
                required: true,
                blank: false,
                initial: CONFIG.DH.GENERAL.healingTypes.hitPoints.id,
                label: 'DAGGERHEART.ACTIONS.Settings.applyTo.label'
            }),
            resultBased: new fields$f.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.resultBased.label'
            }),
            value: new fields$f.EmbeddedDataField(DHActionDiceData),
            valueAlt: new fields$f.EmbeddedDataField(DHActionDiceData)
        };
    }
}

class DHDamageData extends DHResourceData {
    /** @override */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            base: new fields$f.BooleanField({ initial: false, readonly: true, label: 'Base' }),
            type: new fields$f.SetField(
                new fields$f.StringField({
                    choices: CONFIG.DH.GENERAL.damageTypes,
                    initial: 'physical',
                    nullable: false,
                    required: true
                }),
                {
                    label: 'Type'
                }
            )
        };
    }
}

/**
 * Describes metadata about the item data model type
 * @typedef {Object} ItemDataModelMetadata
 * @property {string} label - A localizable label used on application.
 * @property {string} type - The system type that this data model represents.
 * @property {boolean} hasDescription - Indicates whether items of this type have description field
 * @property {boolean} isQuantifiable - Indicates whether items of this type have quantity field
 * @property {boolean} isInventoryItem- Indicates whether items of this type is a Inventory Item
 */


const fields$e = foundry.data.fields;

class BaseDataItem extends foundry.abstract.TypeDataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ITEMS'];

    /** @returns {ItemDataModelMetadata}*/
    static get metadata() {
        return {
            label: 'Base Item',
            type: 'base',
            hasDescription: false,
            hasResource: false,
            isQuantifiable: false,
            isInventoryItem: false,
            hasActions: false
        };
    }

    /**@returns {ItemDataModelMetadata}*/
    get metadata() {
        return this.constructor.metadata;
    }

    /** @inheritDoc */
    static defineSchema() {
        const schema = {};

        if (this.metadata.hasDescription) schema.description = new fields$e.HTMLField({ required: true, nullable: true });

        if (this.metadata.hasResource) {
            schema.resource = new fields$e.SchemaField(
                {
                    type: new fields$e.StringField({
                        choices: CONFIG.DH.ITEM.itemResourceTypes,
                        initial: CONFIG.DH.ITEM.itemResourceTypes.simple
                    }),
                    value: new fields$e.NumberField({ integer: true, min: 0, initial: 0 }),
                    max: new FormulaField({ nullable: true, initial: null, deterministic: true }),
                    icon: new fields$e.StringField(),
                    recovery: new fields$e.StringField({
                        choices: CONFIG.DH.GENERAL.refreshTypes,
                        initial: null,
                        nullable: true
                    }),
                    progression: new fields$e.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.itemResourceProgression,
                        initial: CONFIG.DH.ITEM.itemResourceProgression.increasing.id
                    }),
                    diceStates: new fields$e.TypedObjectField(
                        new fields$e.SchemaField({
                            value: new fields$e.NumberField({ integer: true, initial: 1, min: 1 }),
                            used: new fields$e.BooleanField({ initial: false })
                        })
                    ),
                    dieFaces: new fields$e.StringField({
                        choices: CONFIG.DH.GENERAL.diceTypes,
                        initial: CONFIG.DH.GENERAL.diceTypes.d4
                    })
                },
                { nullable: true, initial: null }
            );
        }

        if (this.metadata.isQuantifiable)
            schema.quantity = new fields$e.NumberField({ integer: true, initial: 1, min: 0, required: true });

        if (this.metadata.hasActions) schema.actions = new ActionsField();

        return schema;
    }

    /* -------------------------------------------- */

    /**
     * The default icon used for newly created Item documents
     * @type {string}
     */
    static DEFAULT_ICON = null;

    /* -------------------------------------------- */

    /**
     * Convenient access to the item's actor, if it exists.
     * @returns {foundry.documents.Actor | null}
     */
    get actor() {
        return this.parent.actor;
    }

    get actionsList() {
        return this.actions;
    }

    get itemFeatures() {
        return [];
    }

    /**
     * Obtain a data object used to evaluate any dice rolls associated with this Item Type
     * @param {object} [options] - Options which modify the getRollData method.
     * @returns {object}
     */
    getRollData(options = {}) {
        const actorRollData = this.actor?.getRollData() ?? {};
        const data = { ...actorRollData, item: { ...this } };
        return data;
    }

    async _preCreate(data, options, user) {
        // Skip if no initial action is required or actions already exist
        if (this.metadata.hasInitialAction && foundry.utils.isEmpty(this.actions)) {
            const metadataType = this.metadata.type;
            const actionType = { weapon: 'attack' }[metadataType];
            const ActionClass = game.system.api.models.actions.actionsTypes[actionType];

            const action = new ActionClass(
                {
                    _id: foundry.utils.randomID(),
                    type: actionType,
                    name: game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[actionType].name),
                    ...ActionClass.getSourceConfig(this.parent)
                },
                {
                    parent: this.parent
                }
            );

            this.updateSource({ actions: [action] });
        }

        if (this.actor && this.actor.type === 'character' && this.features) {
            const features = [];
            for (let f of this.features) {
                const fBase = f.item ?? f;
                const feature = fBase.system ? fBase : await foundry.utils.fromUuid(fBase.uuid);
                features.push(
                    foundry.utils.mergeObject(
                        feature.toObject(),
                        {
                            _stats: { compendiumSource: fBase.uuid },
                            system: {
                                originItemType: this.parent.type,
                                identifier: f.item ? f.type : null,
                                multiclassOrigin: this.isMulticlass
                            }
                        },
                        { inplace: false }
                    )
                );
            }

            await this.actor.createEmbeddedDocuments('Item', features);
        }
    }

    async _preUpdate(changed, options, userId) {
        const allowed = await super._preUpdate(changed, options, userId);
        if (allowed === false) return false;

        addLinkedItemsDiff(changed.system?.features, this.features, options);

        const autoSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        const armorChanged =
            changed.system?.marks?.value !== undefined && changed.system.marks.value !== this.marks.value;
        if (armorChanged && autoSettings.resourceScrollTexts && this.parent.parent?.type === 'character') {
            const armorData = getScrollTextData(this.parent.parent.system.resources, changed.system.marks, 'armor');
            options.scrollingTextData = [armorData];
        }
    }

    _onUpdate(changed, options, userId) {
        super._onUpdate(changed, options, userId);

        updateLinkedItemApps(options, this.parent.sheet);
        createScrollText(this.parent?.parent, options.scrollingTextData);
    }
}

class DHFeature extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.feature',
            type: 'feature',
            hasDescription: true,
            hasResource: true,
            hasActions: true
        });
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/stars-stack.svg';

    /* -------------------------------------------- */

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            originItemType: new fields.StringField({
                choices: CONFIG.DH.ITEM.featureTypes,
                nullable: true,
                initial: null
            }),
            multiclassOrigin: new fields.BooleanField({ initial: false }),
            identifier: new fields.StringField()
        };
    }
}

class DhpActor extends Actor {
    /**
     * Return the first Actor active owner.
     */
    get owner() {
        const user =
            this.hasPlayerOwner && game.users.players.find(u => this.testUserPermission(u, 'OWNER') && u.active);
        if (!user) return game.user.isGM ? game.user : null;
        return user;
    }

    /**
     * Whether this actor is an NPC.
     * @returns {boolean}
     */
    get isNPC() {
        return this.system.metadata.isNPC;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static migrateData(source) {
        if (source.system?.attack && !source.system.attack.type) source.system.attack.type = 'attack';
        return super.migrateData(source);
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static getDefaultArtwork(actorData) {
        const { type } = actorData;
        const Model = CONFIG.Actor.dataModels[type];
        const img = Model.DEFAULT_ICON ?? this.DEFAULT_ICON;
        return {
            img,
            texture: {
                src: img
            }
        };
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    getEmbeddedDocument(embeddedName, id, options) {
        let doc;
        switch (embeddedName) {
            case 'Action':
                doc = this.system.actions?.get(id);
                if (!doc && this.system.attack?.id === id) doc = this.system.attack;
                break;
            default:
                return super.getEmbeddedDocument(embeddedName, id, options);
        }
        if (options?.strict && !doc) {
            throw new Error(`The key ${id} does not exist in the ${embeddedName} Collection`);
        }
        return doc;
    }

    /**@inheritdoc */
    async _preCreate(data, options, user) {
        if ((await super._preCreate(data, options, user)) === false) return false;

        // Configure prototype token settings
        const prototypeToken = {};
        if (['character', 'companion'].includes(this.type))
            Object.assign(prototypeToken, {
                sight: { enabled: true },
                actorLink: true,
                disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY
            });
        this.updateSource({ prototypeToken });
    }

    async updateLevel(newLevel) {
        if (!['character', 'companion'].includes(this.type) || newLevel === this.system.levelData.level.changed) return;

        if (newLevel > this.system.levelData.level.current) {
            const maxLevel = Object.values(
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers
            ).reduce((acc, tier) => Math.max(acc, tier.levels.end), 0);
            if (newLevel > maxLevel) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.tooHighLevel'));
            }

            await this.update({ 'system.levelData.level.changed': Math.min(newLevel, maxLevel) });
        } else {
            const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

            const usedLevel = Math.max(newLevel, 1);
            if (newLevel < 1) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.tooLowLevel'));
            }

            const updatedLevelups = Object.keys(this.system.levelData.levelups).reduce((acc, level) => {
                if (Number(level) > usedLevel) acc[`-=${level}`] = null;

                return acc;
            }, {});

            if (levelupAuto) {
                const features = [];
                const domainCards = [];
                const experiences = [];
                const subclassFeatureState = { class: null, multiclass: null };
                let multiclass = null;
                Object.keys(this.system.levelData.levelups)
                    .filter(x => x > usedLevel)
                    .forEach(levelKey => {
                        const level = this.system.levelData.levelups[levelKey];
                        const achievementCards = level.achievements.domainCards.map(x => x.itemUuid);
                        const advancementCards = level.selections
                            .filter(x => x.type === 'domainCard')
                            .map(x => x.itemUuid);
                        domainCards.push(...achievementCards, ...advancementCards);
                        experiences.push(...Object.keys(level.achievements.experiences));
                        features.push(...level.selections.flatMap(x => x.features));

                        const subclass = level.selections.find(x => x.type === 'subclass');
                        if (subclass) {
                            const path = subclass.secondaryData.isMulticlass === 'true' ? 'multiclass' : 'class';
                            const subclassState = Number(subclass.secondaryData.featureState) - 1;
                            subclassFeatureState[path] = subclassFeatureState[path]
                                ? Math.min(subclassState, subclassFeatureState[path])
                                : subclassState;
                        }

                        multiclass = level.selections.find(x => x.type === 'multiclass');
                    });

                for (let feature of features) {
                    if (feature.onPartner && !this.system.partner) continue;

                    const document = feature.onPartner ? this.system.partner : this;
                    document.items.get(feature.id)?.delete();
                }

                if (experiences.length > 0) {
                    const getUpdate = () => ({
                        'system.experiences': experiences.reduce((acc, key) => {
                            acc[`-=${key}`] = null;
                            return acc;
                        }, {})
                    });
                    this.update(getUpdate());
                }

                if (subclassFeatureState.class) {
                    this.system.class.subclass.update({ 'system.featureState': subclassFeatureState.class });
                }

                if (subclassFeatureState.multiclass) {
                    this.system.multiclass.subclass.update({ 'system.featureState': subclassFeatureState.multiclass });
                }

                if (multiclass) {
                    const multiclassItem = this.items.find(x => x.uuid === multiclass.itemUuid);
                    const multiclassFeatures = this.items.filter(
                        x => x.system.originItemType === 'class' && x.system.multiclassOrigin
                    );
                    const subclassFeatures = this.items.filter(
                        x => x.system.originItemType === 'subclass' && x.system.multiclassOrigin
                    );

                    this.deleteEmbeddedDocuments(
                        'Item',
                        [multiclassItem, ...multiclassFeatures, ...subclassFeatures].map(x => x.id)
                    );

                    this.update({
                        'system.multiclass': {
                            value: null,
                            subclass: null
                        }
                    });
                }

                for (let domainCard of domainCards) {
                    const itemCard = this.items.find(x => x.uuid === domainCard);
                    itemCard.delete();
                }
            }

            await this.update({
                system: {
                    levelData: {
                        level: {
                            current: usedLevel,
                            changed: usedLevel
                        },
                        levelups: updatedLevelups
                    }
                }
            });
            this.sheet.render();
        }
    }

    async levelUp(levelupData) {
        const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;

        const levelups = {};
        for (var levelKey of Object.keys(levelupData)) {
            const level = levelupData[levelKey];

            if (levelupAuto) {
                for (var experienceKey in level.achievements.experiences) {
                    const experience = level.achievements.experiences[experienceKey];
                    await this.update({
                        [`system.experiences.${experienceKey}`]: {
                            name: experience.name,
                            value: experience.modifier,
                            core: true
                        }
                    });
                }
            }

            let multiclass = null;
            const featureAdditions = [];
            const domainCards = [];
            const subclassFeatureState = { class: null, multiclass: null };
            const selections = [];
            for (var optionKey of Object.keys(level.choices)) {
                const selection = level.choices[optionKey];
                for (var checkboxNr of Object.keys(selection)) {
                    const checkbox = selection[checkboxNr];

                    const tierOption = LevelOptionType[checkbox.type];
                    if (tierOption.features?.length > 0) {
                        featureAdditions.push({
                            checkbox: {
                                ...checkbox,
                                level: Number(levelKey),
                                optionKey: optionKey,
                                checkboxNr: Number(checkboxNr)
                            },
                            features: tierOption.features
                        });
                    } else if (checkbox.type === 'multiclass') {
                        multiclass = {
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        };
                    } else if (checkbox.type === 'domainCard') {
                        domainCards.push({
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        });
                    } else {
                        if (checkbox.type === 'subclass') {
                            const path = checkbox.secondaryData.isMulticlass === 'true' ? 'multiclass' : 'class';
                            subclassFeatureState[path] = Math.max(
                                Number(checkbox.secondaryData.featureState),
                                subclassFeatureState[path]
                            );
                        }

                        selections.push({
                            ...checkbox,
                            level: Number(levelKey),
                            optionKey: optionKey,
                            checkboxNr: Number(checkboxNr)
                        });
                    }
                }
            }

            for (var addition of featureAdditions) {
                if (levelupAuto) {
                    for (var featureData of addition.features) {
                        const feature = new DHFeature({
                            ...featureData,
                            description: game.i18n.localize(featureData.description)
                        });

                        const document = featureData.toPartner && this.system.partner ? this.system.partner : this;
                        const embeddedItem = await document.createEmbeddedDocuments('Item', [
                            {
                                ...featureData,
                                name: game.i18n.localize(featureData.name),
                                type: 'feature',
                                system: feature
                            }
                        ]);
                        const newFeature = {
                            onPartner: Boolean(featureData.toPartner && this.system.partner),
                            id: embeddedItem[0].id
                        };
                        addition.checkbox.features = !addition.checkbox.features
                            ? [newFeature]
                            : [...addition.checkbox.features, newFeature];
                    }
                }

                selections.push(addition.checkbox);
            }

            if (multiclass) {
                if (levelupAuto) {
                    const subclassItem = await foundry.utils.fromUuid(multiclass.secondaryData.subclass);
                    const subclassData = subclassItem.toObject();
                    const multiclassItem = await foundry.utils.fromUuid(multiclass.data[0]);
                    const multiclassData = multiclassItem.toObject();

                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...multiclassData,
                            system: {
                                ...multiclassData.system,
                                features: multiclassData.system.features.filter(x => x.type !== 'hope'),
                                domains: [multiclass.secondaryData.domain],
                                isMulticlass: true
                            }
                        }
                    ]);

                    await this.createEmbeddedDocuments('Item', [
                        {
                            ...subclassData,
                            system: {
                                ...subclassData.system,
                                isMulticlass: true
                            }
                        }
                    ]);
                    selections.push({ ...multiclass, itemUuid: embeddedItem[0].uuid });
                } else {
                    selections.push({ ...multiclass });
                }
            }

            for (var domainCard of domainCards) {
                if (levelupAuto) {
                    const itemData = (await foundry.utils.fromUuid(domainCard.data[0])).toObject();
                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...itemData,
                            system: {
                                ...itemData.system,
                                inVault: true
                            }
                        }
                    ]);
                    selections.push({ ...domainCard, itemUuid: embeddedItem[0].uuid });
                } else {
                    selections.push({ ...domainCard });
                }
            }

            const achievementDomainCards = [];
            if (levelupAuto) {
                for (var card of Object.values(level.achievements.domainCards)) {
                    const itemData = (await foundry.utils.fromUuid(card.uuid)).toObject();
                    const embeddedItem = await this.createEmbeddedDocuments('Item', [
                        {
                            ...itemData,
                            system: {
                                ...itemData.system,
                                inVault: true
                            }
                        }
                    ]);
                    card.itemUuid = embeddedItem[0].uuid;
                    achievementDomainCards.push(card);
                }
            }

            if (subclassFeatureState.class) {
                await this.system.class.subclass.update({ 'system.featureState': subclassFeatureState.class });
            }

            if (subclassFeatureState.multiclass) {
                await this.system.multiclass.subclass.update({
                    'system.featureState': subclassFeatureState.multiclass
                });
            }

            levelups[levelKey] = {
                achievements: {
                    ...level.achievements,
                    domainCards: achievementDomainCards
                },
                selections: selections
            };
        }

        const levelChange = this.system.levelData.level.changed - this.system.levelData.level.current;
        await this.update({
            system: {
                levelData: {
                    level: {
                        current: this.system.levelData.level.changed
                    },
                    levelups: levelups
                }
            }
        });
        this.sheet.render();

        if (this.system.companion && !this.system.companion.system.levelData.canLevelUp) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.companionLevelup.confirmTitle')
                },
                content: game.i18n.format('DAGGERHEART.ACTORS.Character.companionLevelup.confirmText', {
                    name: this.system.companion.name,
                    levelChange: levelChange
                })
            });

            if (!confirmed) return;

            await this.system.companion.updateLevel(this.system.companion.system.levelData.level.current + levelChange);
            new DhCompanionLevelUp(this.system.companion).render({ force: true });
        }
    }

    /**
     * @param {object} config
     * @param {Event} config.event
     * @param {string} config.title
     * @param {object} config.roll
     * @param {number} config.roll.modifier
     * @param {boolean} [config.roll.simple=false]
     * @param {string} [config.roll.type]
     * @param {number} [config.roll.difficulty]
     * @param {boolean} [config.hasDamage]
     * @param {boolean} [config.hasEffect]
     * @param {object} [config.chatMessage]
     * @param {string} config.chatMessage.template
     * @param {boolean} [config.chatMessage.mute]
     * @param {object} [config.targets]
     * @param {object} [config.costs]
     */
    async diceRoll(config) {
        config.source = { ...(config.source ?? {}), actor: this.uuid };
        config.data = this.getRollData();
        const rollClass = config.roll.lite ? CONFIG.Dice.daggerheart['DHRoll'] : this.rollClass;
        return await rollClass.build(config);
    }

    get rollClass() {
        return CONFIG.Dice.daggerheart[['character', 'companion'].includes(this.type) ? 'DualityRoll' : 'D20Roll'];
    }

    get baseSaveDifficulty() {
        return this.system.difficulty ?? 10;
    }

    /** @inheritDoc */
    async toggleStatusEffect(statusId, { active, overlay = false } = {}) {
        const status = CONFIG.statusEffects.find(e => e.id === statusId);
        if (!status) throw new Error(`Invalid status ID "${statusId}" provided to Actor#toggleStatusEffect`);
        const existing = [];

        // Find the effect with the static _id of the status effect
        if (status._id) {
            const effect = this.effects.get(status._id);
            if (effect) existing.push(effect.id);
        }

        // If no static _id, find all effects that have this status
        else {
            for (const effect of this.effects) {
                if (effect.statuses.has(status.id)) existing.push(effect.id);
            }
        }

        // Remove the existing effects unless the status effect is forced active
        if (existing.length) {
            if (active) return true;
            await this.deleteEmbeddedDocuments('ActiveEffect', existing);
            return false;
        }

        // Create a new effect unless the status effect is forced inactive
        if (!active && active !== undefined) return;

        const ActiveEffect = getDocumentClass('ActiveEffect');
        const effect = await ActiveEffect.fromStatusEffect(statusId);
        if (overlay) effect.updateSource({ 'flags.core.overlay': true });
        return ActiveEffect.implementation.create(effect, { parent: this, keepId: true });
    }

    /**@inheritdoc */
    getRollData() {
        const rollData = super.getRollData();
        rollData.system = this.system.getRollData();
        rollData.prof = this.system.proficiency ?? 1;
        rollData.cast = this.system.spellcastModifier ?? 1;
        return rollData;
    }

    #canReduceDamage(hpDamage, type) {
        const { stressDamageReduction, disabledArmor } = this.system.rules.damageReduction;
        if (disabledArmor) return false;

        const availableStress = this.system.resources.stress.max - this.system.resources.stress.value;

        const canUseArmor =
            this.system.armor &&
            this.system.armor.system.marks.value < this.system.armorScore &&
            type.every(t => this.system.armorApplicableDamageTypes[t] === true);
        const canUseStress = Object.keys(stressDamageReduction).reduce((acc, x) => {
            const rule = stressDamageReduction[x];
            if (damageKeyToNumber(x) <= hpDamage) return acc || (rule.enabled && availableStress >= rule.cost);
            return acc;
        }, false);

        return canUseArmor || canUseStress;
    }

    async takeDamage(damages) {
        if (Hooks.call(`${CONFIG.DH.id}.preTakeDamage`, this, damages) === false) return null;

        if (this.type === 'companion') {
            await this.modifyResource([{ value: 1, key: 'stress' }]);
            return;
        }

        const updates = [];

        Object.entries(damages).forEach(([key, damage]) => {
            damage.parts.forEach(part => {
                if (part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id)
                    part.total = this.calculateDamage(part.total, part.damageTypes);
                const update = updates.find(u => u.key === key);
                if (update) {
                    update.value += part.total;
                    update.damageTypes.add(...new Set(part.damageTypes));
                } else updates.push({ value: part.total, key, damageTypes: new Set(part.damageTypes) });
            });
        });

        if (Hooks.call(`${CONFIG.DH.id}.postCalculateDamage`, this, damages) === false) return null;

        if (!updates.length) return;

        const hpDamage = updates.find(u => u.key === CONFIG.DH.GENERAL.healingTypes.hitPoints.id);
        if (hpDamage) {
            hpDamage.value = this.convertDamageToThreshold(hpDamage.value);
            if (
                this.type === 'character' &&
                this.system.armor &&
                this.#canReduceDamage(hpDamage.value, hpDamage.damageTypes)
            ) {
                const armorSlotResult = await this.owner.query(
                    'armorSlot',
                    {
                        actorId: this.uuid,
                        damage: hpDamage.value,
                        type: [...hpDamage.damageTypes]
                    },
                    {
                        timeout: 30000
                    }
                );
                if (armorSlotResult) {
                    const { modifiedDamage, armorSpent, stressSpent } = armorSlotResult;
                    updates.find(u => u.key === 'hitPoints').value = modifiedDamage;
                    if (armorSpent) {
                        const armorUpdate = updates.find(u => u.key === 'armor');
                        if (armorUpdate) armorUpdate.value += armorSpent;
                        else updates.push({ value: armorSpent, key: 'armor' });
                    }
                    if (stressSpent) {
                        const stressUpdate = updates.find(u => u.key === 'stress');
                        if (stressUpdate) stressUpdate.value += stressSpent;
                        else updates.push({ value: stressSpent, key: 'stress' });
                    }
                }
            }
        }

        updates.forEach(
            u =>
                (u.value =
                    u.key === 'fear' || this.system?.resources?.[u.key]?.isReversed === false ? u.value * -1 : u.value)
        );

        await this.modifyResource(updates);

        if (Hooks.call(`${CONFIG.DH.id}.postTakeDamage`, this, updates) === false) return null;
    }

    calculateDamage(baseDamage, type) {
        if (this.canResist(type, 'immunity')) return 0;
        if (this.canResist(type, 'resistance')) baseDamage = Math.ceil(baseDamage / 2);

        const flatReduction = this.getDamageTypeReduction(type);
        const damage = Math.max(baseDamage - (flatReduction ?? 0), 0);

        return damage;
    }

    canResist(type, resistance) {
        if (!type?.length) return false;
        return type.every(t => this.system.resistance[t]?.[resistance] === true);
    }

    getDamageTypeReduction(type) {
        if (!type?.length) return 0;
        const reduction = Object.entries(this.system.resistance).reduce(
            (a, [index, value]) => (type.includes(index) ? Math.min(value.reduction, a) : a),
            Infinity
        );
        return reduction === Infinity ? 0 : reduction;
    }

    async takeHealing(healings) {
        if (Hooks.call(`${CONFIG.DH.id}.preTakeHealing`, this, healings) === false) return null;

        const updates = [];
        Object.entries(healings).forEach(([key, healing]) => {
            healing.parts.forEach(part => {
                const update = updates.find(u => u.key === key);
                if (update) update.value += part.total;
                else updates.push({ value: part.total, key });
            });
        });

        updates.forEach(
            u =>
                (u.value = !(u.key === 'fear' || this.system?.resources?.[u.key]?.isReversed === false)
                    ? u.value * -1
                    : u.value)
        );

        await this.modifyResource(updates);

        if (Hooks.call(`${CONFIG.DH.id}.postTakeHealing`, this, updates) === false) return null;
    }

    async modifyResource(resources) {
        if (!resources?.length) return;

        if (resources.find(r => r.key === 'stress')) this.convertStressDamageToHP(resources);
        let updates = {
            actor: { target: this, resources: {} },
            armor: { target: this.system.armor, resources: {} },
            items: {}
        };

        resources.forEach(r => {
            if (r.keyIsID) {
                updates.items[r.key] = {
                    target: r.target,
                    resources: {
                        'system.resource.value': r.target.system.resource.value + r.value
                    }
                };
            } else {
                switch (r.key) {
                    case 'fear':
                        ui.resources.updateFear(
                            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear) + r.value
                        );
                        break;
                    case 'armor':
                        if (this.system.armor?.system?.marks) {
                            updates.armor.resources['system.marks.value'] = Math.max(
                                Math.min(this.system.armor.system.marks.value + r.value, this.system.armorScore),
                                0
                            );
                        }
                        break;
                    default:
                        if (this.system.resources?.[r.key]) {
                            updates.actor.resources[`system.resources.${r.key}.value`] = Math.max(
                                Math.min(
                                    this.system.resources[r.key].value + r.value,
                                    this.system.resources[r.key].max
                                ),
                                0
                            );
                        }
                        break;
                }
            }
        });

        Object.keys(updates).forEach(async key => {
            const u = updates[key];
            if (key === 'items') {
                Object.values(u).forEach(async item => {
                    await emitAsGM(
                        GMUpdateEvent.UpdateDocument,
                        item.target.update.bind(item.target),
                        item.resources,
                        item.target.uuid
                    );
                });
            } else {
                if (Object.keys(u.resources).length > 0) {
                    await emitAsGM(
                        GMUpdateEvent.UpdateDocument,
                        u.target.update.bind(u.target),
                        u.resources,
                        u.target.uuid
                    );
                }
            }
        });
    }

    convertDamageToThreshold(damage) {
        return damage >= this.system.damageThresholds.severe ? 3 : damage >= this.system.damageThresholds.major ? 2 : 1;
    }

    convertStressDamageToHP(resources) {
        const stressDamage = resources.find(r => r.key === 'stress'),
            newValue = this.system.resources.stress.value + stressDamage.value;
        if (newValue <= this.system.resources.stress.max) return;
        const hpDamage = resources.find(r => r.key === 'hitPoints');
        if (hpDamage) hpDamage.value++;
        else
            resources.push({
                key: 'hitPoints',
                value: 1
            });
    }

    async toggleDefeated(defeatedState) {
        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).defeated;
        const { unconscious, defeated, dead } = CONFIG.DH.GENERAL.conditions;
        const defeatedConditions = new Set([unconscious.id, defeated.id, dead.id]);
        if (!defeatedState) {
            for (let defeatedId of defeatedConditions) {
                await this.toggleStatusEffect(defeatedId, { overlay: settings.overlay, active: defeatedState });
            }
        } else {
            const noDefeatedConditions = this.statuses.intersection(defeatedConditions).size === 0;
            if (noDefeatedConditions) {
                const condition = settings[`${this.type}Default`];
                await this.toggleStatusEffect(condition, { overlay: settings.overlay, active: defeatedState });
            }
        }
    }

    /** @inheritdoc */
    async importFromJSON(json) {
        if (!this.type === 'character') return await super.importFromJSON(json);

        if (!CONST.WORLD_DOCUMENT_TYPES.includes(this.documentName)) {
            throw new Error('Only world Documents may be imported');
        }

        const parsedJSON = JSON.parse(json);
        if (foundry.utils.isNewerVersion('1.1.0', parsedJSON._stats.systemVersion)) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.ACTORS.Character.InvalidOldCharacterImportTitle')
                },
                content: game.i18n.localize('DAGGERHEART.ACTORS.Character.InvalidOldCharacterImportText')
            });
            if (!confirmed) return;
        }

        return await super.importFromJSON(json);
    }
}

const fields$d = foundry.data.fields;

/*
    !!! I'm currently refactoring the whole Action thing, it's a WIP !!!
*/

/*
    ToDo
    - Target Check / Target Picker
    - Range Check
    - Area of effect and measurement placement
    - Summon Action create method
*/

class DHBaseAction extends ActionMixin(foundry.abstract.DataModel) {
    static extraSchemas = ['cost', 'uses', 'range'];

    static defineSchema() {
        const schemaFields = {
            _id: new fields$d.DocumentIdField({ initial: () => foundry.utils.randomID() }),
            systemPath: new fields$d.StringField({ required: true, initial: 'actions' }),
            type: new fields$d.StringField({ initial: undefined, readonly: true, required: true }),
            name: new fields$d.StringField({ initial: undefined }),
            description: new fields$d.HTMLField(),
            img: new fields$d.FilePathField({ initial: undefined, categories: ['IMAGE'], base64: false }),
            chatDisplay: new fields$d.BooleanField({ initial: true, label: 'DAGGERHEART.ACTIONS.Config.displayInChat' }),
            actionType: new fields$d.StringField({
                choices: CONFIG.DH.ITEM.actionTypes,
                initial: 'action',
                nullable: true
            })
        };

        this.extraSchemas.forEach(s => {
            let clsField;
            if ((clsField = this.getActionField(s))) schemaFields[s] = new clsField();
        });

        return schemaFields;
    }

    static getActionField(name) {
        const field = game.system.api.fields.ActionFields[`${name.capitalize()}Field`];
        return fields$d.DataField.isPrototypeOf(field) && field;
    }

    prepareData() {
        this.name = this.name || game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[this.type].name);
        this.img = this.img ?? this.parent?.parent?.img;
    }

    get id() {
        return this._id;
    }

    get item() {
        return this.parent.parent;
    }

    get actor() {
        return this.item instanceof DhpActor
            ? this.item
            : this.item?.parent instanceof DhpActor
              ? this.item.parent
              : this.item?.actor;
    }

    static getRollType(parent) {
        return 'trait';
    }

    static getSourceConfig(parent) {
        const updateSource = {};
        if (parent?.parent?.type === 'weapon' && this === game.system.api.models.actions.actionsTypes.attack) {
            updateSource['damage'] = { includeBase: true };
            updateSource['range'] = parent?.attack?.range;
            updateSource['roll'] = {
                useDefault: true
            };
        } else {
            if (parent?.trait) {
                updateSource['roll'] = {
                    type: this.getRollType(parent),
                    trait: parent.trait
                };
            }
            if (parent?.range) {
                updateSource['range'] = parent?.range;
            }
        }
        return updateSource;
    }

    getRollData(data = {}) {
        if (!this.actor) return null;
        const actorData = this.actor.getRollData(false);

        // Add Roll results to RollDatas
        actorData.result = data.roll?.total ?? 1;

        actorData.scale = data.costs?.length // Right now only return the first scalable cost.
            ? (data.costs.find(c => c.scalable)?.total ?? 1)
            : 1;
        actorData.roll = {};

        return actorData;
    }

    async use(event, options = {}) {
        if (!this.actor) throw new Error("An Action can't be used outside of an Actor context.");

        if (this.chatDisplay) await this.toChat();
        let { byPassRoll } = options,
            config = this.prepareConfig(event, byPassRoll);
        for (let i = 0; i < this.constructor.extraSchemas.length; i++) {
            let clsField = this.constructor.getActionField(this.constructor.extraSchemas[i]);
            if (clsField?.prepareConfig) {
                const keep = clsField.prepareConfig.call(this, config);
                if (config.isFastForward && !keep) return;
            }
        }

        if (Hooks.call(`${CONFIG.DH.id}.preUseAction`, this, config) === false) return;

        // Display configuration window if necessary
        if (this.requireConfigurationDialog(config)) {
            config = await D20RollDialog.configure(null, config);
            if (!config) return;
        }

        if (config.hasRoll) {
            const rollConfig = this.prepareRoll(config);
            config.roll = rollConfig;
            config = await this.actor.diceRoll(config);
            if (!config) return;
        }

        if (this.doFollowUp(config)) {
            if (this.rollDamage && this.damage.parts.length) await this.rollDamage(event, config);
            else if (this.trigger) await this.trigger(event, config);
            else if (this.hasSave || this.hasEffect) {
                const roll = new CONFIG.Dice.daggerheart.DHRoll('');
                roll._evaluated = true;
                await CONFIG.Dice.daggerheart.DHRoll.toMessage(roll, config);
            }
        }

        // Consume resources
        await this.consume(config);

        if (Hooks.call(`${CONFIG.DH.id}.postUseAction`, this, config) === false) return;

        return config;
    }

    /* */
    prepareConfig(event, byPass = false) {
        const hasRoll = this.getUseHasRoll(byPass);
        return {
            event,
            title: `${this.item.name}: ${game.i18n.localize(this.name)}`,
            source: {
                item: this.item._id,
                action: this._id,
                actor: this.actor.uuid
            },
            dialog: {
                configure: hasRoll
            },
            type: this.roll?.type ?? this.type,
            hasRoll: hasRoll,
            hasDamage: this.damage?.parts?.length && this.type !== 'healing',
            hasHealing: this.damage?.parts?.length && this.type === 'healing',
            hasEffect: !!this.effects?.length,
            hasSave: this.hasSave,
            selectedRollMode: game.settings.get('core', 'rollMode'),
            isFastForward: event.shiftKey,
            data: this.getRollData(),
            evaluate: hasRoll
        };
    }

    requireConfigurationDialog(config) {
        return !config.event.shiftKey && !config.hasRoll && (config.costs?.length || config.uses);
    }

    prepareRoll() {
        const roll = {
            baseModifiers: this.roll.getModifier(),
            label: 'Attack',
            type: this.actionType,
            difficulty: this.roll?.difficulty,
            formula: this.roll.getFormula(),
            advantage: CONFIG.DH.ACTIONS.advantageState[this.roll.advState].value
        };
        if (this.roll?.type === 'diceSet' || !this.hasRoll) roll.lite = true;

        return roll;
    }

    doFollowUp(config) {
        return !config.hasRoll;
    }

    async consume(config, successCost = false) {
        const actor = this.actor.system.partner ?? this.actor,
            usefulResources = {
                ...foundry.utils.deepClone(actor.system.resources),
                fear: {
                    value: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear),
                    max: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear,
                    reversed: false
                }
            };

        for (var cost of config.costs) {
            if (cost.keyIsID) {
                usefulResources[cost.key] = {
                    value: cost.value,
                    target: this.parent.parent,
                    keyIsID: true
                };
            }
        }

        const resources = game.system.api.fields.ActionFields.CostField.getRealCosts(config.costs)
            .filter(
                c =>
                    (!successCost && (!c.consumeOnSuccess || config.roll?.success)) ||
                    (successCost && c.consumeOnSuccess)
            )
            .reduce((a, c) => {
                const resource = usefulResources[c.key];
                if (resource) {
                    a.push({
                        key: c.key,
                        value: (c.total ?? c.value) * (resource.isReversed ? 1 : -1),
                        target: resource.target,
                        keyIsID: resource.keyIsID
                    });
                    return a;
                }
            }, []);

        await actor.modifyResource(resources);
        if (
            config.uses?.enabled &&
            ((!successCost && (!config.uses?.consumeOnSuccess || config.roll?.success)) ||
                (successCost && config.uses?.consumeOnSuccess))
        )
            this.update({ 'uses.value': this.uses.value + 1 });

        if (config.roll?.success || successCost) {
            setTimeout(() => {
                (config.message ?? config.parent).update({ 'system.successConsumed': true });
            }, 50);
        }
    }
    /* */

    /* ROLL */
    getUseHasRoll(byPass = false) {
        return this.hasRoll && !byPass;
    }

    get hasRoll() {
        return !!this.roll?.type;
    }

    get modifiers() {
        if (!this.actor) return [];
        const modifiers = [];
        /** Placeholder for specific bonuses **/
        return modifiers;
    }
    /* ROLL */

    /* SAVE */
    get hasSave() {
        return !!this.save?.trait;
    }
    /* SAVE */

    /* EFFECTS */
    get hasEffect() {
        return this.effects?.length > 0;
    }

    async applyEffects(event, data, targets) {
        targets ??= data.system.targets;
        if (!this.effects?.length || !targets.length) return;
        let effects = this.effects;
        targets.forEach(async token => {
            if (!token.hit && false) ;
            if (this.hasSave && token.saved.success === true) {
                effects = this.effects.filter(e => e.onSave === true);
            }
            if (!effects.length) return;
            effects.forEach(async e => {
                const actor = canvas.tokens.get(token.id)?.actor,
                    effect = this.item.effects.get(e._id);
                if (!actor || !effect) return;
                await this.applyEffect(effect, actor);
            });
        });
    }

    async applyEffect(effect, actor) {
        const existingEffect = actor.effects.find(e => e.origin === effect.uuid);
        if (existingEffect) {
            return effect.update(
                foundry.utils.mergeObject({
                    ...effect.constructor.getInitialDuration(),
                    disabled: false
                })
            );
        }

        // Otherwise, create a new effect on the target
        const effectData = foundry.utils.mergeObject({
            ...effect.toObject(),
            disabled: false,
            transfer: false,
            origin: effect.uuid
        });
        await ActiveEffect.implementation.create(effectData, { parent: actor });
    }
    /* EFFECTS */

    /* SAVE */
    async rollSave(actor, event, message) {
        if (!actor) return;
        const title = actor.isNPC
            ? game.i18n.localize('DAGGERHEART.GENERAL.reactionRoll')
            : game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                  ability: game.i18n.localize(abilities[this.save.trait]?.label)
              });
        return actor.diceRoll({
            event,
            title,
            roll: {
                trait: this.save.trait,
                difficulty: this.save.difficulty ?? this.actor?.baseSaveDifficulty,
                type: 'reaction'
            },
            type: 'trait',
            hasRoll: true,
            data: actor.getRollData()
        });
    }

    updateSaveMessage(result, message, targetId) {
        if (!result) return;
        const updateMsg = this.updateChatMessage.bind(this, message, targetId, {
            result: result.roll.total,
            success: result.roll.success
        });
        if (game.modules.get('dice-so-nice')?.active)
            game.dice3d.waitFor3DAnimationByMessageID(result.message.id ?? result.message._id).then(() => updateMsg());
        else updateMsg();
    }

    static rollSaveQuery({ actionId, actorId, event, message }) {
        return new Promise(async (resolve, reject) => {
            const actor = await fromUuid(actorId),
                action = await fromUuid(actionId);
            if (!actor || !actor?.isOwner) reject();
            action.rollSave(actor, event, message).then(result => resolve(result));
        });
    }
    /* SAVE */

    async updateChatMessage(message, targetId, changes, chain = true) {
        setTimeout(async () => {
            const chatMessage = ui.chat.collection.get(message._id);

            await chatMessage.update({
                flags: {
                    [game.system.id]: {
                        reactionRolls: {
                            [targetId]: changes
                        }
                    }
                }
            });
        }, 100);
        if (chain) {
            if (message.system.source.message)
                this.updateChatMessage(ui.chat.collection.get(message.system.source.message), targetId, changes, false);
            const relatedChatMessages = ui.chat.collection.filter(c => c.system.source?.message === message._id);
            relatedChatMessages.forEach(c => {
                this.updateChatMessage(c, targetId, changes, false);
            });
        }
    }

    /**
     * Generates a list of localized tags for this action.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            game.i18n.localize(`DAGGERHEART.ACTIONS.TYPES.${this.type}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.ActionType.${this.actionType}`)
        ];

        return tags;
    }
}

class DHDamageAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'damage', 'target', 'effects'];

    getFormulaValue(part, data) {
        let formulaValue = part.value;
        
        if (data.hasRoll && part.resultBased && data.roll.result.duality === -1) return part.valueAlt;

        const isAdversary = this.actor.type === 'adversary';
        if (isAdversary && this.actor.system.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
            const hasHordeDamage = this.actor.effects.find(x => x.type === 'horde');
            if (hasHordeDamage && !hasHordeDamage.disabled) return part.valueAlt;
        }

        return formulaValue;
    }

    formatFormulas(formulas, systemData) {
        const formattedFormulas = [];
        formulas.forEach(formula => {
            if (isNaN(formula.formula))
                formula.formula = Roll.replaceFormulaData(formula.formula, this.getRollData(systemData));
            const same = formattedFormulas.find(
                f => setsEqual(f.damageTypes, formula.damageTypes) && f.applyTo === formula.applyTo
            );
            if (same) same.formula += ` + ${formula.formula}`;
            else formattedFormulas.push(formula);
        });
        return formattedFormulas;
    }

    async rollDamage(event, data) {
        const systemData = data.system ?? data;

        let formulas = this.damage.parts.map(p => ({
            formula: this.getFormulaValue(p, systemData).getFormula(this.actor),
            damageTypes: p.applyTo === 'hitPoints' && !p.type.size ? new Set(['physical']) : p.type,
            applyTo: p.applyTo
        }));

        if (!formulas.length) return;

        formulas = this.formatFormulas(formulas, systemData);

        delete systemData.evaluate;
        const config = {
            ...systemData,
            roll: formulas,
            dialog: {},
            data: this.getRollData()
        };
        if (this.hasSave) config.onSave = this.save.damageMod;
        if (data.system) {
            config.source.message = data._id;
            config.directDamage = false;
        } else {
            config.directDamage = true;
        }

        return CONFIG.Dice.daggerheart.DamageRoll.build(config);
    }
}

class DHAttackAction extends DHDamageAction {
    static extraSchemas = [...super.extraSchemas, 'roll', 'save'];

    static getRollType(parent) {
        return parent.parent.type === 'weapon' ? 'attack' : 'spellcast';
    }

    prepareData() {
        super.prepareData();
        if (!!this.item?.system?.attack) {
            if (this.damage.includeBase) {
                const baseDamage = this.getParentDamage();
                this.damage.parts.unshift(new DHDamageData(baseDamage));
            }
            if (this.roll.useDefault) {
                this.roll.trait = this.item.system.attack.roll.trait;
                this.roll.type = 'attack';
            }
        }
    }

    getParentDamage() {
        return {
            value: {
                multiplier: 'prof',
                dice: this.item?.system?.attack.damage.parts[0].value.dice,
                bonus: this.item?.system?.attack.damage.parts[0].value.bonus ?? 0
            },
            type: this.item?.system?.attack.damage.parts[0].type,
            base: true
        };
    }

    async use(event, options) {
        const result = await super.use(event, options);

        const { updateCountdowns } = game.system.api.applications.ui.DhCountdowns;
        await updateCountdowns(CONFIG.DH.GENERAL.countdownTypes.characterAttack.id);

        return result;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        const { roll, range, damage } = this;

        if (roll.trait) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${roll.trait}.short`));
        if (range) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.short`));

        const useAltDamage = this.actor?.effects?.find(x => x.type === 'horde')?.active;
        for (const { value, valueAlt, type } of damage.parts) {
            const usedValue = useAltDamage ? valueAlt : value;
            const str = Roll.replaceFormulaData(usedValue.getFormula(), this.actor?.getRollData() ?? {});

            const icons = Array.from(type)
                .map(t => CONFIG.DH.GENERAL.damageTypes[t]?.icon)
                .filter(Boolean);

            if (icons.length === 0) {
                labels.push(str);
            } else {
                labels.push({ value: str, icons });
            }
        }

        return labels;
    }
}

class DhBeastformAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'beastform'];

    async use(event, options) {
        const beastformConfig = this.prepareBeastformConfig();

        const abort = await this.handleActiveTransformations();
        if (abort) return;

        const calcCosts = game.system.api.fields.ActionFields.CostField.calcCosts.call(this, this.cost);
        const hasCost = game.system.api.fields.ActionFields.CostField.hasCost.call(this, calcCosts);
        if (!hasCost) {
            ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.insufficientResources'));
            return;
        }

        const { selected, evolved, hybrid } = await BeastformDialog.configure(beastformConfig, this.item);
        if (!selected) return;

        const result = await super.use(event, options);
        if (!result) return;

        await this.transform(selected, evolved, hybrid);
    }

    prepareBeastformConfig(config) {
        const settingsTiers = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers;
        const actorLevel = this.actor.system.levelData.level.current;
        const actorTier =
            Object.values(settingsTiers).find(
                tier => actorLevel >= tier.levels.start && actorLevel <= tier.levels.end
            ) ?? 1;

        return {
            tierLimit: this.beastform.tierAccess.exact ?? actorTier
        };
    }

    async transform(selectedForm, evolvedData, hybridData) {
        const formData = evolvedData?.form ? evolvedData.form.toObject() : selectedForm.toObject();
        const beastformEffect = formData.effects.find(x => x.type === 'beastform');
        if (!beastformEffect) {
            ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
            return;
        }

        if (evolvedData?.form) {
            const evolvedForm = selectedForm.effects.find(x => x.type === 'beastform');
            if (!evolvedForm) {
                ui.notifications.error('DAGGERHEART.UI.Notifications.beastformMissingEffect');
                return;
            }

            beastformEffect.changes = [...beastformEffect.changes, ...evolvedForm.changes];
            formData.system.features = [...formData.system.features, ...selectedForm.system.features.map(x => x.uuid)];
        }

        if (selectedForm.system.beastformType === CONFIG.DH.ITEM.beastformTypes.hybrid.id) {
            formData.system.advantageOn = Object.values(hybridData.advantages).reduce((advantages, formCategory) => {
                Object.keys(formCategory).forEach(advantageKey => {
                    advantages[advantageKey] = formCategory[advantageKey];
                });
                return advantages;
            }, {});
            formData.system.features = [
                ...formData.system.features,
                ...Object.values(hybridData.features).flatMap(x => Object.keys(x))
            ];
        }

        this.actor.createEmbeddedDocuments('Item', [formData]);
    }

    async handleActiveTransformations() {
        const beastformEffects = this.actor.effects.filter(x => x.type === 'beastform');
        const existingEffects = beastformEffects.length > 0;
        await this.actor.deleteEmbeddedDocuments(
            'ActiveEffect',
            beastformEffects.map(x => x.id)
        );
        return existingEffects;
    }
}

class DHEffectAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'effects', 'target'];
}

class DHHealingAction extends DHDamageAction {
    static extraSchemas = [...super.extraSchemas, 'roll'];

    static getRollType(parent) {
        return 'spellcast';
    }
}

class DHMacroAction extends DHBaseAction {
    static extraSchemas = [...super.extraSchemas, 'macro'];

    async trigger(event, ...args) {
        const fixUUID = !this.macro.includes('Macro.') ? `Macro.${this.macro}` : this.macro,
            macro = await fromUuid(fixUUID);
        try {
            if (!macro) throw new Error(`No macro found for the UUID: ${this.macro}.`);
            macro.execute();
        } catch (error) {
            ui.notifications.error(error);
        }
    }
}

class DHSummonAction extends DHBaseAction {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            documentUUID: new fields.DocumentUUIDField({ type: 'Actor' })
        };
    }

    async trigger(event, ...args) {
        if (!this.canSummon || !canvas.scene) return;
    }

    get canSummon() {
        return game.user.can('TOKEN_CREATE');
    }
}

const actionsTypes = {
    base: DHBaseAction,
    attack: DHAttackAction,
    damage: DHDamageAction,
    healing: DHHealingAction,
    summon: DHSummonAction,
    effect: DHEffectAction,
    macro: DHMacroAction,
    beastform: DhBeastformAction
};

var _module$7 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    actionsTypes: actionsTypes
});

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$2, ApplicationV2: ApplicationV2$2 } = foundry.applications.api;

class DowntimeConfig extends HandlebarsApplicationMixin$2(ApplicationV2$2) {
    constructor(move, movePath, settings, options) {
        super(options);

        this.move = move;

        this.movePath = movePath;
        this.actionsPath = `${movePath}.actions`;
        this.settings = settings;
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.SETTINGS.Homebrew.downtimeMoves');
    }

    static DEFAULT_OPTIONS = {
        tag: 'form',
        classes: ['daggerheart', 'setting', 'dh-style'],
        position: { width: 440, height: 'auto' },
        window: {
            icon: 'fa-solid fa-gears'
        },
        actions: {
            editImage: this.onEditImage,
            addItem: this.addItem,
            editItem: this.editItem,
            removeItem: this.removeItem,
            resetMoves: this.resetMoves,
            saveForm: this.saveForm
        },
        form: { handler: this.updateData, submitOnChange: true, closeOnSubmit: false }
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/settings/downtime-config/header.hbs' },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        main: { template: 'systems/daggerheart/templates/settings/downtime-config/main.hbs' },
        actions: { template: 'systems/daggerheart/templates/settings/downtime-config/actions.hbs' },
        footer: { template: 'systems/daggerheart/templates/settings/downtime-config/footer.hbs' }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'main' }, { id: 'actions' }],
            initial: 'main',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        context.move = this.move;
        context.move.enrichedDescription = await foundry.applications.ux.TextEditor.enrichHTML(
            context.move.description
        );

        return context;
    }

    static async updateData(event, element, formData) {
        const data = foundry.utils.expandObject(formData.object);
        foundry.utils.mergeObject(this.move, data);

        this.render();
    }

    static async saveForm() {
        this.close({ submitted: true });
    }

    static onEditImage() {
        const fp = new foundry.applications.apps.FilePicker.implementation({
            current: this.img,
            type: 'image',
            callback: async path => {
                this.move.img = path;
                this.render();
            },
            top: this.position.top + 40,
            left: this.position.left + 10
        });
        return fp.browse();
    }

    async selectActionType() {
        return (
            (await foundry.applications.api.DialogV2.input({
                window: { title: game.i18n.localize('DAGGERHEART.CONFIG.SelectAction.selectType') },
                content: await foundry.applications.handlebars.renderTemplate(
                    'systems/daggerheart/templates/actionTypes/actionType.hbs',
                    { types: CONFIG.DH.ACTIONS.actionTypes }
                ),
                ok: {
                    label: game.i18n.format('DOCUMENT.Create', {
                        type: game.i18n.localize('DAGGERHEART.GENERAL.Action.single')
                    })
                }
            })) ?? {}
        );
    }

    static async addItem() {
        const { type: actionType } = await this.selectActionType();
        if (!actionType) return;

        const cls = actionsTypes[actionType] ?? actionsTypes.attack,
            action = new cls(
                {
                    type: actionType,
                    name: game.i18n.localize(CONFIG.DH.ACTIONS.actionTypes[actionType].name),
                    img: 'icons/magic/life/cross-worn-green.webp',
                    actionType: 'action',
                    systemPath: this.actionsPath
                },
                {
                    parent: this.settings
                }
            );

        await this.settings.updateSource({ [`${this.actionsPath}.${action.id}`]: action });
        this.move = foundry.utils.getProperty(this.settings, this.movePath);

        this.render();
    }

    static async editItem(_, target) {
        const actionId = target.dataset.id;
        const action = this.move.actions.get(actionId);
        await new DHActionConfig(action, async updatedMove => {
            await this.settings.updateSource({ [`${this.actionsPath}.${actionId}`]: updatedMove });
            this.move = foundry.utils.getProperty(this.settings, this.movePath);
            this.render();
        }).render(true);
    }

    static async removeItem(_, target) {
        await this.settings.updateSource({ [`${this.actionsPath}.-=${target.dataset.id}`]: null });
        this.move = foundry.utils.getProperty(this.settings, this.movePath);
        this.render();
    }

    static resetMoves() {}

    /** @override */
    _onClose(options = {}) {
        if (!options.submitted) this.move = null;
    }

    static async configure(move, movePath, settings, options = {}) {
        return new Promise(resolve => {
            const app = new this(move, movePath, settings, options);
            app.addEventListener('close', () => resolve(app.move), { once: true });
            app.render({ force: true });
        });
    }
}

/**@typedef {import('@client/applications/_types.mjs').ApplicationClickAction} ApplicationClickAction */

class DHEnvironmentSettings extends DHBaseActorSettings {
    /**@inheritdoc */
    static DEFAULT_OPTIONS = {
        classes: ['environment-settings'],
        actions: {
            addCategory: DHEnvironmentSettings.#addCategory,
            removeCategory: DHEnvironmentSettings.#removeCategory,
            deleteAdversary: DHEnvironmentSettings.#deleteAdversary
        },
        dragDrop: [
            { dragSelector: null, dropSelector: '.category-container' },
            { dragSelector: null, dropSelector: '.tab.features' },
            { dragSelector: '.feature-item', dropSelector: null }
        ]
    };

    /**@override */
    static PARTS = {
        header: {
            id: 'header',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/header.hbs'
        },
        tabs: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs' },
        details: {
            id: 'details',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/details.hbs'
        },
        features: {
            id: 'features',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/features.hbs'
        },
        adversaries: {
            id: 'adversaries',
            template: 'systems/daggerheart/templates/sheets-settings/environment-settings/adversaries.hbs'
        }
    };

    /** @inheritdoc */
    static TABS = {
        primary: {
            tabs: [{ id: 'details' }, { id: 'features' }, { id: 'adversaries' }],
            initial: 'details',
            labelPrefix: 'DAGGERHEART.GENERAL.Tabs'
        }
    };

    /**
     *  Adds a new category entry to the actor.
     * @type {ApplicationClickAction}
     */
    static async #addCategory() {
        await this.actor.update({
            [`system.potentialAdversaries.${foundry.utils.randomID()}.label`]: game.i18n.localize(
                'DAGGERHEART.ACTORS.Environment.newAdversary'
            )
        });
    }

    /**
     * Removes an category entry from the actor.
     * @type {ApplicationClickAction}
     */
    static async #removeCategory(_, target) {
        await this.actor.update({ [`system.potentialAdversaries.-=${target.dataset.categoryId}`]: null });
    }

    /**
     *
     * @type {ApplicationClickAction}
     * @returns
     */
    static async #deleteAdversary(_event, target) {
        const doc = await getDocFromElement(target);
        const { category } = target.dataset;
        const path = `system.potentialAdversaries.${category}.adversaries`;

        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.title', {
                    type: game.i18n.localize('TYPES.Actor.adversary'),
                    name: doc.name
                })
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.DeleteConfirmation.text', { name: doc.name })
        });

        if (!confirmed) return;

        const adversaries = foundry.utils.getProperty(this.actor, path);
        const newAdversaries = adversaries.filter(a => a.uuid !== doc.uuid);
        await this.actor.update({ [path]: newAdversaries.map(x => x.uuid) });
    }

    async _onDragStart(event) {
        const featureItem = event.currentTarget.closest('.feature-item');

        if (featureItem) {
            const feature = this.actor.items.get(featureItem.id);
            const featureData = { type: 'Item', uuid: feature.uuid, fromInternal: true };
            event.dataTransfer.setData('text/plain', JSON.stringify(featureData));
            event.dataTransfer.setDragImage(featureItem.querySelector('img'), 60, 0);
        }
    }

    async _onDrop(event) {
        const data = foundry.applications.ux.TextEditor.implementation.getDragEventData(event);
        if (data.fromInternal) return;

        const item = await fromUuid(data.uuid);
        if (item.type === 'adversary' && event.target.closest('.category-container')) {
            const target = event.target.closest('.category-container');
            const path = `system.potentialAdversaries.${target.dataset.potentialAdversary}.adversaries`;
            const current = foundry.utils.getProperty(this.actor, path).map(x => x.uuid);
            await this.actor.update({
                [path]: [...current, item.uuid]
            });
            this.render();
        } else if (item.type === 'feature' && event.target.closest('.tab.features')) {
            await this.actor.createEmbeddedDocuments('Item', [item]);
            this.render();
        }
    }
}

/**
 * Copyright (c) 2016 Denis Taran
 *
 * Homepage: https://smartscheduling.com/en/documentation/autocomplete
 * Source: https://github.com/denis-taran/autocomplete
 *
 * MIT License
 */
function autocomplete(settings) {
    // just an alias to minimize JS file size
    var doc = document;
    var container = settings.container || doc.createElement('div');
    var preventSubmit = settings.preventSubmit || 0 /* Never */;
    container.id = container.id || 'autocomplete-' + uid();
    var containerStyle = container.style;
    var debounceWaitMs = settings.debounceWaitMs || 0;
    var disableAutoSelect = settings.disableAutoSelect || false;
    var customContainerParent = container.parentElement;
    var items = [];
    var inputValue = '';
    var minLen = 2;
    var showOnFocus = settings.showOnFocus;
    var selected;
    var fetchCounter = 0;
    var debounceTimer;
    var destroyed = false;
    // Fixes #104: autocomplete selection is broken on Firefox for Android
    var suppressAutocomplete = false;
    if (settings.minLength !== undefined) {
        minLen = settings.minLength;
    }
    if (!settings.input) {
        throw new Error('input undefined');
    }
    var input = settings.input;
    container.className = [container.className, 'autocomplete', settings.className || ''].join(' ').trim();
    container.setAttribute('role', 'listbox');
    input.setAttribute('role', 'combobox');
    input.setAttribute('aria-expanded', 'false');
    input.setAttribute('aria-autocomplete', 'list');
    input.setAttribute('aria-controls', container.id);
    input.setAttribute('aria-owns', container.id);
    input.setAttribute('aria-activedescendant', '');
    input.setAttribute('aria-haspopup', 'listbox');
    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning
    containerStyle.position = 'absolute';
    /**
     * Generate a very complex textual ID that greatly reduces the chance of a collision with another ID or text.
     */
    function uid() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
    }
    /**
     * Detach the container from DOM
     */
    function detach() {
        var parent = container.parentNode;
        if (parent) {
            parent.removeChild(container);
        }
    }
    /**
     * Clear debouncing timer if assigned
     */
    function clearDebounceTimer() {
        if (debounceTimer) {
            window.clearTimeout(debounceTimer);
        }
    }
    /**
     * Attach the container to DOM
     */
    function attach() {
        if (!container.parentNode) {
            (customContainerParent || doc.body).appendChild(container);
        }
    }
    /**
     * Check if container for autocomplete is displayed
     */
    function containerDisplayed() {
        return !!container.parentNode;
    }
    /**
     * Clear autocomplete state and hide container
     */
    function clear() {
        // prevent the update call if there are pending AJAX requests
        fetchCounter++;
        items = [];
        inputValue = '';
        selected = undefined;
        input.setAttribute('aria-activedescendant', '');
        input.setAttribute('aria-expanded', 'false');
        detach();
    }
    /**
     * Update autocomplete position
     */
    function updatePosition() {
        if (!containerDisplayed()) {
            return;
        }
        input.setAttribute('aria-expanded', 'true');
        containerStyle.height = 'auto';
        containerStyle.width = input.offsetWidth + 'px';
        var maxHeight = 0;
        var inputRect;
        function calc() {
            var docEl = doc.documentElement;
            var clientTop = docEl.clientTop || doc.body.clientTop || 0;
            var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
            var scrollTop = window.pageYOffset || docEl.scrollTop;
            var scrollLeft = window.pageXOffset || docEl.scrollLeft;
            inputRect = input.getBoundingClientRect();
            var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
            var left = inputRect.left + scrollLeft - clientLeft;
            containerStyle.top = top + 'px';
            containerStyle.left = left + 'px';
            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
            if (maxHeight < 0) {
                maxHeight = 0;
            }
            containerStyle.top = top + 'px';
            containerStyle.bottom = '';
            containerStyle.left = left + 'px';
            containerStyle.maxHeight = maxHeight + 'px';
        }
        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)
        calc();
        calc();
        if (settings.customize && inputRect) {
            settings.customize(input, inputRect, container, maxHeight);
        }
    }
    /**
     * Redraw the autocomplete div element with suggestions
     */
    function update() {
        container.textContent = '';
        input.setAttribute('aria-activedescendant', '');
        // function for rendering autocomplete suggestions
        var render = function (item, _, __) {
            var itemElement = doc.createElement('div');
            itemElement.textContent = item.label || '';
            return itemElement;
        };
        if (settings.render) {
            render = settings.render;
        }
        // function to render autocomplete groups
        var renderGroup = function (groupName, _) {
            var groupDiv = doc.createElement('div');
            groupDiv.textContent = groupName;
            return groupDiv;
        };
        if (settings.renderGroup) {
            renderGroup = settings.renderGroup;
        }
        var fragment = doc.createDocumentFragment();
        var prevGroup = uid();
        items.forEach(function (item, index) {
            if (item.group && item.group !== prevGroup) {
                prevGroup = item.group;
                var groupDiv = renderGroup(item.group, inputValue);
                if (groupDiv) {
                    groupDiv.className += ' group';
                    fragment.appendChild(groupDiv);
                }
            }
            var div = render(item, inputValue, index);
            if (div) {
                div.id = container.id + "_" + index;
                div.setAttribute('role', 'option');
                div.addEventListener('click', function (ev) {
                    suppressAutocomplete = true;
                    try {
                        settings.onSelect(item, input);
                    }
                    finally {
                        suppressAutocomplete = false;
                    }
                    clear();
                    ev.preventDefault();
                    ev.stopPropagation();
                });
                if (item === selected) {
                    div.className += ' selected';
                    div.setAttribute('aria-selected', 'true');
                    input.setAttribute('aria-activedescendant', div.id);
                }
                fragment.appendChild(div);
            }
        });
        container.appendChild(fragment);
        if (items.length < 1) {
            if (settings.emptyMsg) {
                var empty = doc.createElement('div');
                empty.id = container.id + "_" + uid();
                empty.className = 'empty';
                empty.textContent = settings.emptyMsg;
                container.appendChild(empty);
                input.setAttribute('aria-activedescendant', empty.id);
            }
            else {
                clear();
                return;
            }
        }
        attach();
        updatePosition();
        updateScroll();
    }
    function updateIfDisplayed() {
        if (containerDisplayed()) {
            update();
        }
    }
    function resizeEventHandler() {
        updateIfDisplayed();
    }
    function scrollEventHandler(e) {
        if (e.target !== container) {
            updateIfDisplayed();
        }
        else {
            e.preventDefault();
        }
    }
    function inputEventHandler() {
        if (!suppressAutocomplete) {
            fetch(0 /* Keyboard */);
        }
    }
    /**
     * Automatically move scroll bar if selected item is not visible
     */
    function updateScroll() {
        var elements = container.getElementsByClassName('selected');
        if (elements.length > 0) {
            var element = elements[0];
            // make group visible
            var previous = element.previousElementSibling;
            if (previous && previous.className.indexOf('group') !== -1 && !previous.previousElementSibling) {
                element = previous;
            }
            if (element.offsetTop < container.scrollTop) {
                container.scrollTop = element.offsetTop;
            }
            else {
                var selectBottom = element.offsetTop + element.offsetHeight;
                var containerBottom = container.scrollTop + container.offsetHeight;
                if (selectBottom > containerBottom) {
                    container.scrollTop += selectBottom - containerBottom;
                }
            }
        }
    }
    function selectPreviousSuggestion() {
        var index = items.indexOf(selected);
        selected = index === -1
            ? undefined
            : items[(index + items.length - 1) % items.length];
        updateSelectedSuggestion(index);
    }
    function selectNextSuggestion() {
        var index = items.indexOf(selected);
        selected = items.length < 1
            ? undefined
            : index === -1
                ? items[0]
                : items[(index + 1) % items.length];
        updateSelectedSuggestion(index);
    }
    function updateSelectedSuggestion(index) {
        if (items.length > 0) {
            unselectSuggestion(index);
            selectSuggestion(items.indexOf(selected));
            updateScroll();
        }
    }
    function selectSuggestion(index) {
        var element = doc.getElementById(container.id + "_" + index);
        if (element) {
            element.classList.add('selected');
            element.setAttribute('aria-selected', 'true');
            input.setAttribute('aria-activedescendant', element.id);
        }
    }
    function unselectSuggestion(index) {
        var element = doc.getElementById(container.id + "_" + index);
        if (element) {
            element.classList.remove('selected');
            element.removeAttribute('aria-selected');
            input.removeAttribute('aria-activedescendant');
        }
    }
    function handleArrowAndEscapeKeys(ev, key) {
        var containerIsDisplayed = containerDisplayed();
        if (key === 'Escape') {
            clear();
        }
        else {
            if (!containerIsDisplayed || items.length < 1) {
                return;
            }
            key === 'ArrowUp'
                ? selectPreviousSuggestion()
                : selectNextSuggestion();
        }
        ev.preventDefault();
        if (containerIsDisplayed) {
            ev.stopPropagation();
        }
    }
    function handleEnterKey(ev) {
        if (selected) {
            if (preventSubmit === 2 /* OnSelect */) {
                ev.preventDefault();
            }
            suppressAutocomplete = true;
            try {
                settings.onSelect(selected, input);
            }
            finally {
                suppressAutocomplete = false;
            }
            clear();
        }
        if (preventSubmit === 1 /* Always */) {
            ev.preventDefault();
        }
    }
    function keydownEventHandler(ev) {
        var key = ev.key;
        switch (key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'Escape':
                handleArrowAndEscapeKeys(ev, key);
                break;
            case 'Enter':
                handleEnterKey(ev);
                break;
        }
    }
    function focusEventHandler() {
        if (showOnFocus) {
            fetch(1 /* Focus */);
        }
    }
    function fetch(trigger) {
        if (input.value.length >= minLen || trigger === 1 /* Focus */) {
            clearDebounceTimer();
            debounceTimer = window.setTimeout(function () { return startFetch(input.value, trigger, input.selectionStart || 0); }, trigger === 0 /* Keyboard */ || trigger === 2 /* Mouse */ ? debounceWaitMs : 0);
        }
        else {
            clear();
        }
    }
    function startFetch(inputText, trigger, cursorPos) {
        if (destroyed)
            return;
        var savedFetchCounter = ++fetchCounter;
        settings.fetch(inputText, function (elements) {
            if (fetchCounter === savedFetchCounter && elements) {
                items = elements;
                inputValue = inputText;
                selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];
                update();
            }
        }, trigger, cursorPos);
    }
    function keyupEventHandler(e) {
        if (settings.keyup) {
            settings.keyup({
                event: e,
                fetch: function () { return fetch(0 /* Keyboard */); }
            });
            return;
        }
        if (!containerDisplayed() && e.key === 'ArrowDown') {
            fetch(0 /* Keyboard */);
        }
    }
    function clickEventHandler(e) {
        settings.click && settings.click({
            event: e,
            fetch: function () { return fetch(2 /* Mouse */); }
        });
    }
    function blurEventHandler() {
        // when an item is selected by mouse click, the blur event will be initiated before the click event and remove DOM elements,
        // so that the click event will never be triggered. In order to avoid this issue, DOM removal should be delayed.
        setTimeout(function () {
            if (doc.activeElement !== input) {
                clear();
            }
        }, 200);
    }
    function manualFetch() {
        startFetch(input.value, 3 /* Manual */, input.selectionStart || 0);
    }
    /**
     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
     */
    container.addEventListener('mousedown', function (evt) {
        evt.stopPropagation();
        evt.preventDefault();
    });
    /**
     * Fixes #30: autocomplete closes when scrollbar is clicked in IE
     * See: https://stackoverflow.com/a/9210267/13172349
     */
    container.addEventListener('focus', function () { return input.focus(); });
    // If the custom autocomplete container is already appended to the DOM during widget initialization, detach it.
    detach();
    /**
     * This function will remove DOM elements and clear event handlers
     */
    function destroy() {
        input.removeEventListener('focus', focusEventHandler);
        input.removeEventListener('keyup', keyupEventHandler);
        input.removeEventListener('click', clickEventHandler);
        input.removeEventListener('keydown', keydownEventHandler);
        input.removeEventListener('input', inputEventHandler);
        input.removeEventListener('blur', blurEventHandler);
        window.removeEventListener('resize', resizeEventHandler);
        doc.removeEventListener('scroll', scrollEventHandler, true);
        input.removeAttribute('role');
        input.removeAttribute('aria-expanded');
        input.removeAttribute('aria-autocomplete');
        input.removeAttribute('aria-controls');
        input.removeAttribute('aria-activedescendant');
        input.removeAttribute('aria-owns');
        input.removeAttribute('aria-haspopup');
        clearDebounceTimer();
        clear();
        destroyed = true;
    }
    // setup event handlers
    input.addEventListener('keyup', keyupEventHandler);
    input.addEventListener('click', clickEventHandler);
    input.addEventListener('keydown', keydownEventHandler);
    input.addEventListener('input', inputEventHandler);
    input.addEventListener('blur', blurEventHandler);
    input.addEventListener('focus', focusEventHandler);
    window.addEventListener('resize', resizeEventHandler);
    doc.addEventListener('scroll', scrollEventHandler, true);
    return {
        destroy: destroy,
        fetch: manualFetch
    };
}

class DhActiveEffectConfig extends foundry.applications.sheets.ActiveEffectConfig {
    constructor(options) {
        super(options);

        const ignoredActorKeys = ['config', 'DhEnvironment'];
        this.changeChoices = Object.keys(game.system.api.models.actors).reduce((acc, key) => {
            if (!ignoredActorKeys.includes(key)) {
                const model = game.system.api.models.actors[key];
                const attributes = CONFIG.Token.documentClass.getTrackedAttributes(model);
                const group = game.i18n.localize(model.metadata.label);
                const choices = CONFIG.Token.documentClass
                    .getTrackedAttributeChoices(attributes, model)
                    .map(x => ({ ...x, group: group }));
                acc.push(...choices);
            }
            return acc;
        }, []);
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'sheet', 'dh-style']
    };

    static PARTS = {
        header: { template: 'systems/daggerheart/templates/sheets/activeEffect/header.hbs' },
        tabs: { template: 'templates/generic/tab-navigation.hbs' },
        details: { template: 'systems/daggerheart/templates/sheets/activeEffect/details.hbs', scrollable: [''] },
        settings: { template: 'systems/daggerheart/templates/sheets/activeEffect/settings.hbs' },
        changes: {
            template: 'systems/daggerheart/templates/sheets/activeEffect/changes.hbs',
            scrollable: ['ol[data-changes]']
        },
        footer: { template: 'systems/daggerheart/templates/sheets/global/tabs/tab-form-footer.hbs' }
    };

    static TABS = {
        sheet: {
            tabs: [
                { id: 'details', icon: 'fa-solid fa-book' },
                { id: 'settings', icon: 'fa-solid fa-bars', label: 'DAGGERHEART.GENERAL.Tabs.settings' },
                { id: 'changes', icon: 'fa-solid fa-gears' }
            ],
            initial: 'details',
            labelPrefix: 'EFFECT.TABS'
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        const changeChoices = this.changeChoices;

        htmlElement.querySelectorAll('.effect-change-input').forEach(element => {
            autocomplete({
                input: element,
                fetch: function (text, update) {
                    if (!text) {
                        update(changeChoices);
                    } else {
                        text = text.toLowerCase();
                        var suggestions = changeChoices.filter(n => n.label.toLowerCase().includes(text));
                        update(suggestions);
                    }
                },
                render: function (item, search) {
                    const label = game.i18n.localize(item.label);
                    const matchIndex = label.toLowerCase().indexOf(search);

                    const beforeText = label.slice(0, matchIndex);
                    const matchText = label.slice(matchIndex, matchIndex + search.length);
                    const after = label.slice(matchIndex + search.length, label.length);

                    const element = document.createElement('li');
                    element.innerHTML = `${beforeText}${matchText ? `<strong>${matchText}</strong>` : ''}${after}`;
                    if (item.hint) {
                        element.dataset.tooltip = game.i18n.localize(item.hint);
                    }

                    return element;
                },
                renderGroup: function (label) {
                    const itemElement = document.createElement('div');
                    itemElement.textContent = game.i18n.localize(label);
                    return itemElement;
                },
                onSelect: function (item) {
                    element.value = `system.${item.value}`;
                },
                click: e => e.fetch(),
                customize: function (_input, _inputRect, container) {
                    container.style.zIndex = foundry.applications.api.ApplicationV2._maxZ;
                },
                minLength: 0
            });
        });
    }

    async _preparePartContext(partId, context) {
        const partContext = await super._preparePartContext(partId, context);
        switch (partId) {
            case 'details':
                const useGeneric = game.settings.get(
                    CONFIG.DH.id,
                    CONFIG.DH.SETTINGS.gameSettings.appearance
                ).showGenericStatusEffects;
                if (!useGeneric) {
                    partContext.statuses = Object.values(CONFIG.DH.GENERAL.conditions).map(status => ({
                        value: status.id,
                        label: game.i18n.localize(status.name)
                    }));
                }
                break;
        }

        return partContext;
    }
}

class DhTokenConfig extends foundry.applications.sheets.TokenConfig {
    /** @inheritDoc */
    async _prepareResourcesTab() {
        const token = this.token;
        const usesTrackableAttributes = !foundry.utils.isEmpty(CONFIG.Actor.trackableAttributes);
        const attributeSource =
            this.actor?.system instanceof foundry.abstract.DataModel && usesTrackableAttributes
                ? this.actor?.type
                : this.actor?.system;
        const TokenDocument = foundry.utils.getDocumentClass('Token');
        const attributes = TokenDocument.getTrackedAttributes(attributeSource);
        return {
            barAttributes: TokenDocument.getTrackedAttributeChoices(attributes, attributeSource),
            bar1: token.getBarAttribute?.('bar1'),
            bar2: token.getBarAttribute?.('bar2'),
            turnMarkerModes: DhTokenConfig.TURN_MARKER_MODES,
            turnMarkerAnimations: CONFIG.Combat.settings.turnMarkerAnimations
        };
    }
}

class DhPrototypeTokenConfig extends foundry.applications.sheets.PrototypeTokenConfig {
    /** @inheritDoc */
    async _prepareResourcesTab() {
        const token = this.token;
        const usesTrackableAttributes = !foundry.utils.isEmpty(CONFIG.Actor.trackableAttributes);
        const attributeSource =
            this.actor?.system instanceof foundry.abstract.DataModel && usesTrackableAttributes
                ? this.actor?.type
                : this.actor?.system;
        const TokenDocument = foundry.utils.getDocumentClass('Token');
        const attributes = TokenDocument.getTrackedAttributes(attributeSource);
        return {
            barAttributes: TokenDocument.getTrackedAttributeChoices(attributes, attributeSource),
            bar1: token.getBarAttribute?.('bar1'),
            bar2: token.getBarAttribute?.('bar2'),
            turnMarkerModes: DhPrototypeTokenConfig.TURN_MARKER_MODES,
            turnMarkerAnimations: CONFIG.Combat.settings.turnMarkerAnimations
        };
    }
}

var _module$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionConfig: DHActionConfig,
    ActiveEffectConfig: DhActiveEffectConfig,
    AdversarySettings: DHAdversarySettings,
    CharacterSettings: DHCharacterSettings,
    CompanionSettings: DHCompanionSettings,
    DhPrototypeTokenConfig: DhPrototypeTokenConfig,
    DhTokenConfig: DhTokenConfig,
    DowntimeConfig: DowntimeConfig,
    EnvironmentSettings: DHEnvironmentSettings
});

class DhpChatLog extends foundry.applications.sidebar.tabs.ChatLog {
    constructor(options) {
        super(options);

        this.targetTemplate = {
            activeLayer: undefined,
            document: undefined,
            object: undefined,
            minimizedSheets: [],
            config: undefined,
            targets: undefined
        };
        this.setupHooks();
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        classes: ['daggerheart']
    };

    _getEntryContextOptions() {
        return [
            ...super._getEntryContextOptions(),
            // {
            //     name: 'Reroll',
            //     icon: '<i class="fa-solid fa-dice"></i>',
            //     condition: li => {
            //         const message = game.messages.get(li.dataset.messageId);

            //         return (game.user.isGM || message.isAuthor) && message.rolls.length > 0;
            //     },
            //     callback: li => {
            //         const message = game.messages.get(li.dataset.messageId);
            //         new game.system.api.applications.dialogs.RerollDialog(message).render({ force: true });
            //     }
            // },
            {
                name: 'Reroll Damage',
                icon: '<i class="fa-solid fa-dice"></i>',
                condition: li => {
                    const message = game.messages.get(li.dataset.messageId);
                    const hasRolledDamage = message.system.hasDamage
                        ? Object.keys(message.system.damage).length > 0
                        : false;
                    return (game.user.isGM || message.isAuthor) && hasRolledDamage;
                },
                callback: li => {
                    const message = game.messages.get(li.dataset.messageId);
                    new game.system.api.applications.dialogs.RerollDamageDialog(message).render({ force: true });
                }
            }
        ];
    }

    addChatListeners = async (app, html, data) => {
        html.querySelectorAll('.duality-action-damage').forEach(element =>
            element.addEventListener('click', event => this.onRollDamage(event, data.message))
        );
        html.querySelectorAll('.target-save').forEach(element =>
            element.addEventListener('click', event => this.onRollSave(event, data.message))
        );
        html.querySelectorAll('.roll-all-save-button').forEach(element =>
            element.addEventListener('click', event => this.onRollAllSave(event, data.message))
        );
        html.querySelectorAll('.simple-roll-button').forEach(element =>
            element.addEventListener('click', event => this.onRollSimple(event, data.message))
        );
        html.querySelectorAll('.healing-button').forEach(element =>
            element.addEventListener('click', event => this.onHealing(event, data.message))
        );
        html.querySelectorAll('.ability-use-button').forEach(element =>
            element.addEventListener('click', event => this.abilityUseButton(event, data.message))
        );
        html.querySelectorAll('.action-use-button').forEach(element =>
            element.addEventListener('click', event => this.actionUseButton(event, data.message))
        );
        html.querySelectorAll('.reroll-button').forEach(element =>
            element.addEventListener('click', event => this.rerollEvent(event, data.message))
        );
    };

    setupHooks() {
        Hooks.on('renderChatMessageHTML', this.addChatListeners.bind());
    }

    close(options) {
        Hooks.off('renderChatMessageHTML', this.addChatListeners);
        super.close(options);
    }

    async getActor(uuid) {
        return await foundry.utils.fromUuid(uuid);
    }

    getAction(actor, itemId, actionId) {
        const item = actor.items.get(itemId),
            action =
                actor.system.attack?._id === actionId
                    ? actor.system.attack
                    : item.system.attack?._id === actionId
                      ? item.system.attack
                      : item?.system?.actions?.get(actionId);
        return action;
    }

    async onRollDamage(event, message) {
        event.stopPropagation();
        const actor = await this.getActor(message.system.source.actor);
        if(!actor.isOwner) return true;
        if (message.system.source.item && message.system.source.action) {
            const action = this.getAction(actor, message.system.source.item, message.system.source.action);
            if (!action || !action?.rollDamage) return;
            await action.rollDamage(event, message);
        }
    }

    async onRollSave(event, message) {
        event.stopPropagation();
        const actor = await this.getActor(message.system.source.actor),
            tokenId = event.target.closest('[data-token]')?.dataset.token,
            token = game.canvas.tokens.get(tokenId);
        if (!token?.actor || !token.isOwner) return true;
        if (message.system.source.item && message.system.source.action) {
            const action = this.getAction(actor, message.system.source.item, message.system.source.action);
            if (!action || !action?.hasSave) return;
            action.rollSave(token.actor, event, message).then(result =>
                emitAsGM(
                    GMUpdateEvent.UpdateSaveMessage,
                    action.updateSaveMessage.bind(action, result, message, token.id),
                    {
                        action: action.uuid,
                        message: message._id,
                        token: token.id,
                        result
                    }
                )
            );
        }
    }

    async onRollAllSave(event, message) {
        event.stopPropagation();
        if (!game.user.isGM) return;
        const targets = event.target.parentElement.querySelectorAll('[data-token] .target-save');
        const actor = await this.getActor(message.system.source.actor),
            action = this.getAction(actor, message.system.source.item, message.system.source.action);
        targets.forEach(async el => {
            const tokenId = el.closest('[data-token]')?.dataset.token,
                token = game.canvas.tokens.get(tokenId);
            if (!token.actor) return;
            if (game.user === token.actor.owner) el.dispatchEvent(new PointerEvent('click', { shiftKey: true }));
            else {
                token.actor.owner
                    .query('reactionRoll', {
                        actionId: action.uuid,
                        actorId: token.actor.uuid,
                        event,
                        message
                    })
                    .then(result => action.updateSaveMessage(result, message, token.id));
            }
        });
    }

    async onRollSimple(event, message) {
        const buttonType = event.target.dataset.type ?? 'damage',
            total = message.rolls.reduce((a, c) => a + Roll.fromJSON(c).total, 0),
            damages = {
                hitPoints: {
                    parts: [
                        {
                            applyTo: 'hitPoints',
                            damageTypes: [],
                            total
                        }
                    ]
                }
            },
            targets = Array.from(game.user.targets);

        if (targets.length === 0)
            return ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelected'));

        targets.forEach(target => {
            if (buttonType === 'healing') target.actor.takeHealing(damages);
            else target.actor.takeDamage(damages);
        });
    }

    async abilityUseButton(event, message) {
        event.stopPropagation();

        const item = await foundry.utils.fromUuid(message.system.origin);
        const action =
            item.system.attack?.id === event.currentTarget.id
                ? item.system.attack
                : item.system.actions.get(event.currentTarget.id);
        if (event.currentTarget.dataset.directDamage) action.use(event, { byPassRoll: true });
        else action.use(event);
    }

    async actionUseButton(event, message) {
        const { moveIndex, actionIndex } = event.currentTarget.dataset;
        const parent = await foundry.utils.fromUuid(message.system.actor);
        const actionType = message.system.moves[moveIndex].actions[actionIndex];
        const cls = game.system.api.models.actions.actionsTypes[actionType.type];
        const action = new cls(
            { ...actionType, _id: foundry.utils.randomID(), name: game.i18n.localize(actionType.name) },
            { parent: parent.system }
        );

        action.use(event);
    }

    async rerollEvent(event, message) {
        event.stopPropagation();
        if (!event.shiftKey) {
            const confirmed = await foundry.applications.api.DialogV2.confirm({
                window: {
                    title: game.i18n.localize('DAGGERHEART.UI.Chat.reroll.confirmTitle')
                },
                content: game.i18n.localize('DAGGERHEART.UI.Chat.reroll.confirmText')
            });
            if (!confirmed) return;
        }

        const target = event.target.closest('[data-die-index]');

        if (target.dataset.type === 'damage') {
            game.system.api.dice.DamageRoll.reroll(target, message);
        } else {
            let originalRoll_parsed = message.rolls.map(roll => JSON.parse(roll))[0];
            const rollClass =
                game.system.api.dice[
                    message.type === 'dualityRoll'
                        ? 'DualityRoll'
                        : target.dataset.type === 'damage'
                          ? 'DHRoll'
                          : 'D20Roll'
                ];

            if (!game.modules.get('dice-so-nice')?.active) foundry.audio.AudioHelper.play({ src: CONFIG.sounds.dice });

            const { newRoll, parsedRoll } = await rollClass.reroll(originalRoll_parsed, target, message);

            await game.messages.get(message._id).update({
                'system.roll': newRoll,
                'rolls': [parsedRoll]
            });
        }
    }
}

const { HandlebarsApplicationMixin: HandlebarsApplicationMixin$1, ApplicationV2: ApplicationV2$1 } = foundry.applications.api;

class Countdowns extends HandlebarsApplicationMixin$1(ApplicationV2$1) {
    constructor(basePath) {
        super({});

        this.basePath = basePath;
    }

    get title() {
        return game.i18n.format('DAGGERHEART.APPLICATIONS.Countdown.title', {
            type: game.i18n.localize(`DAGGERHEART.APPLICATIONS.Countdown.types.${this.basePath}`)
        });
    }

    static DEFAULT_OPTIONS = {
        classes: ['daggerheart', 'dh-style', 'countdown'],
        tag: 'form',
        position: { width: 740, height: 700 },
        window: {
            frame: true,
            title: 'Countdowns',
            resizable: true,
            minimizable: false
        },
        actions: {
            addCountdown: this.addCountdown,
            removeCountdown: this.removeCountdown,
            editImage: this.onEditImage,
            openOwnership: this.openOwnership,
            openCountdownOwnership: this.openCountdownOwnership,
            toggleSimpleView: this.toggleSimpleView
        },
        form: { handler: this.updateData, submitOnChange: true }
    };

    static PARTS = {
        countdowns: {
            template: 'systems/daggerheart/templates/ui/countdowns.hbs',
            scrollable: ['.expanded-view']
        }
    };

    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);

        htmlElement.querySelectorAll('.mini-countdown-container').forEach(element => {
            element.addEventListener('click', event => this.updateCountdownValue.bind(this)(event, false));
            element.addEventListener('contextmenu', event => this.updateCountdownValue.bind(this)(event, true));
        });
    }

    async _preFirstRender(context, options) {
        options.position =
            game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS[`${this.basePath}Countdown`].position) ??
            Countdowns.DEFAULT_OPTIONS.position;

        const viewSetting =
            game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS[`${this.basePath}Countdown`].simple) ?? !game.user.isGM;
        this.simpleView =
            game.user.isGM || !this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) ? viewSetting : true;
        context.simple = this.simpleView;
    }

    _onPosition(position) {
        game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS[`${this.basePath}Countdown`].position, position);
    }

    async _renderFrame(options) {
        const frame = await super._renderFrame(options);

        if (this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER)) {
            const button = constructHTMLButton({
                label: '',
                classes: ['header-control', 'icon', 'fa-solid', 'fa-wrench'],
                dataset: { action: 'toggleSimpleView', tooltip: 'DAGGERHEART.APPLICATIONS.Countdown.toggleSimple' }
            });
            this.window.controls.after(button);
        }

        return frame;
    }

    testUserPermission(level, exact, altSettings) {
        if (game.user.isGM) return true;

        const settings =
            altSettings ?? game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[this.basePath];
        const defaultAllowed = exact ? settings.ownership.default === level : settings.ownership.default >= level;
        const userAllowed = exact
            ? settings.playerOwnership[game.user.id]?.value === level
            : settings.playerOwnership[game.user.id]?.value >= level;
        return defaultAllowed || userAllowed;
    }

    async _prepareContext(_options) {
        const context = await super._prepareContext(_options);
        const countdownData = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[
            this.basePath
        ];

        context.isGM = game.user.isGM;
        context.base = this.basePath;

        context.canCreate = this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER, true);
        context.source = {
            ...countdownData,
            countdowns: Object.keys(countdownData.countdowns).reduce((acc, key) => {
                const countdown = countdownData.countdowns[key];

                if (this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED, false, countdown)) {
                    acc[key] = {
                        ...countdown,
                        canEdit: this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER, true, countdown)
                    };
                }

                return acc;
            }, {})
        };
        context.systemFields = countdownData.schema.fields;
        context.countdownFields = context.systemFields.countdowns.element.fields;
        context.simple = this.simpleView;

        return context;
    }

    static async updateData(event, _, formData) {
        const data = foundry.utils.expandObject(formData.object);
        const newSetting = foundry.utils.mergeObject(
            game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns).toObject(),
            data
        );

        if (game.user.isGM) {
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, newSetting);
            this.render();
        } else {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateSetting,
                    uuid: CONFIG.DH.SETTINGS.gameSettings.Countdowns,
                    update: newSetting
                }
            });
        }
    }

    async updateSetting(update) {
        if (game.user.isGM) {
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, update);
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.Refresh,
                data: {
                    refreshType: RefreshType.Countdown,
                    application: `${this.basePath}-countdowns`
                }
            });

            this.render();
        } else {
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateSetting,
                    uuid: CONFIG.DH.SETTINGS.gameSettings.Countdowns,
                    update: update,
                    refresh: { refreshType: RefreshType.Countdown, application: `${this.basePath}-countdowns` }
                }
            });
        }
    }

    static onEditImage(_, target) {
        const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[this.basePath];
        const current = setting.countdowns[target.dataset.countdown].img;
        const fp = new foundry.applications.apps.FilePicker.implementation({
            current,
            type: 'image',
            callback: async path => this.updateImage.bind(this)(path, target.dataset.countdown),
            top: this.position.top + 40,
            left: this.position.left + 10
        });
        return fp.browse();
    }

    async updateImage(path, countdown) {
        const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        await setting.updateSource({
            [`${this.basePath}.countdowns.${countdown}.img`]: path
        });

        await this.updateSetting(setting);
    }

    static openOwnership(_, target) {
        new Promise((resolve, reject) => {
            const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[this.basePath];
            const ownership = { default: setting.ownership.default, players: setting.playerOwnership };
            new OwnershipSelection(resolve, reject, this.title, ownership).render(true);
        }).then(async ownership => {
            const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
            await setting.updateSource({
                [`${this.basePath}.ownership`]: ownership
            });

            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, setting.toObject());
            this.render();
        });
    }

    static openCountdownOwnership(_, target) {
        const countdownId = target.dataset.countdown;
        new Promise((resolve, reject) => {
            const countdown = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[this.basePath]
                .countdowns[countdownId];
            const ownership = { default: countdown.ownership.default, players: countdown.playerOwnership };
            new OwnershipSelection(resolve, reject, countdown.name, ownership).render(true);
        }).then(async ownership => {
            const setting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
            await setting.updateSource({
                [`${this.basePath}.countdowns.${countdownId}.ownership`]: ownership
            });

            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, setting);
            this.render();
        });
    }

    static async toggleSimpleView() {
        this.simpleView = !this.simpleView;
        await game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS[`${this.basePath}Countdown`].simple, this.simpleView);
        this.render();
    }

    async updateCountdownValue(event, increase) {
        const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const countdown = countdownSetting[this.basePath].countdowns[event.currentTarget.dataset.countdown];

        if (!this.testUserPermission(CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER)) {
            return;
        }

        const currentValue = countdown.progress.current;

        if (increase && currentValue === countdown.progress.max) return;
        if (!increase && currentValue === 0) return;

        await countdownSetting.updateSource({
            [`${this.basePath}.countdowns.${event.currentTarget.dataset.countdown}.progress.current`]: increase
                ? currentValue + 1
                : currentValue - 1
        });

        await this.updateSetting(countdownSetting.toObject());
    }

    static async addCountdown() {
        const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        await countdownSetting.updateSource({
            [`${this.basePath}.countdowns.${foundry.utils.randomID()}`]: {
                name: game.i18n.localize('DAGGERHEART.APPLICATIONS.Countdown.newCountdown'),
                ownership: game.user.isGM
                    ? {}
                    : {
                          players: {
                              [game.user.id]: { type: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER }
                          }
                      }
            }
        });

        await this.updateSetting(countdownSetting.toObject());
    }

    static async removeCountdown(_, target) {
        const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
        const countdownName = countdownSetting[this.basePath].countdowns[target.dataset.countdown].name;

        const confirmed = await foundry.applications.api.DialogV2.confirm({
            window: {
                title: game.i18n.localize('DAGGERHEART.APPLICATIONS.Countdown.removeCountdownTitle')
            },
            content: game.i18n.format('DAGGERHEART.APPLICATIONS.Countdown.removeCountdownText', { name: countdownName })
        });
        if (!confirmed) return;

        await countdownSetting.updateSource({ [`${this.basePath}.countdowns.-=${target.dataset.countdown}`]: null });

        await this.updateSetting(countdownSetting.toObject());
    }

    async open() {
        await this.render(true);
        if (
            Object.keys(
                game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns)[this.basePath].countdowns
            ).length > 0
        ) {
            this.minimize();
        }
    }
}

class NarrativeCountdowns extends Countdowns {
    constructor() {
        super('narrative');
    }

    static DEFAULT_OPTIONS = {
        id: 'narrative-countdowns'
    };
}

class EncounterCountdowns extends Countdowns {
    constructor() {
        super('encounter');
    }

    static DEFAULT_OPTIONS = {
        id: 'encounter-countdowns'
    };
}

async function updateCountdowns(progressType) {
    const countdownSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns);
    const update = Object.keys(countdownSetting).reduce((update, typeKey) => {
        return foundry.utils.mergeObject(
            update,
            Object.keys(countdownSetting[typeKey].countdowns).reduce((acc, countdownKey) => {
                const countdown = countdownSetting[typeKey].countdowns[countdownKey];
                if (countdown.progress.current > 0 && countdown.progress.type.value === progressType) {
                    acc[`${typeKey}.countdowns.${countdownKey}.progress.current`] = countdown.progress.current - 1;
                }

                return acc;
            }, {})
        );
    }, {});

    await countdownSetting.updateSource(update);
    await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, countdownSetting);

    const data = { refreshType: RefreshType.Countdown };
    await game.socket.emit(`system.${CONFIG.DH.id}`, {
        action: socketEvent.Refresh,
        data
    });
    Hooks.callAll(socketEvent.Refresh, data);
}

var countdowns = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EncounterCountdowns: EncounterCountdowns,
    NarrativeCountdowns: NarrativeCountdowns,
    updateCountdowns: updateCountdowns
});

class DhCombatTracker extends foundry.applications.sidebar.tabs.CombatTracker {
    static DEFAULT_OPTIONS = {
        actions: {
            requestSpotlight: this.requestSpotlight,
            toggleSpotlight: this.toggleSpotlight,
            setActionTokens: this.setActionTokens,
            openCountdowns: this.openCountdowns
        }
    };

    static PARTS = {
        header: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTrackerHeader.hbs'
        },
        tracker: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTracker.hbs'
        },
        footer: {
            template: 'systems/daggerheart/templates/ui/combatTracker/combatTrackerFooter.hbs'
        }
    };

    async _prepareCombatContext(context, options) {
        await super._prepareCombatContext(context, options);

        Object.assign(context, {
            fear: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear)
        });
    }

    async _prepareTrackerContext(context, options) {
        await super._prepareTrackerContext(context, options);

        const adversaries = context.turns?.filter(x => x.isNPC) ?? [];
        const characters = context.turns?.filter(x => !x.isNPC) ?? [];

        Object.assign(context, {
            actionTokens: game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).actionTokens,
            adversaries,
            characters
        });
    }

    _getCombatContextOptions() {
        return [
            {
                name: 'COMBAT.ClearMovementHistories',
                icon: '<i class="fa-solid fa-shoe-prints"></i>',
                condition: () => game.user.isGM && this.viewed?.combatants.size > 0,
                callback: () => this.viewed.clearMovementHistories()
            },
            {
                name: 'COMBAT.Delete',
                icon: '<i class="fa-solid fa-trash"></i>',
                condition: () => game.user.isGM && !!this.viewed,
                callback: () => this.viewed.endCombat()
            }
        ];
    }

    getDefeatedId(combatant) {
        if (!combatant.actor) return CONFIG.specialStatusEffects.DEFEATED;

        const settings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).defeated;
        return settings[`${combatant.actor.type}Default`];
    }

    /** @inheritdoc */
    async _onToggleDefeatedStatus(combatant) {
        const isDefeated = !combatant.isDefeated;
        await combatant.update({ defeated: isDefeated });
        await combatant.actor?.toggleStatusEffect(this.getDefeatedId(combatant), { overlay: true, active: isDefeated });
    }

    /** @inheritdoc */
    async _prepareTurnContext(combat, combatant, index) {
        const { id, name, isOwner, isDefeated, hidden, initiative, permission } = combatant;
        const resource = permission >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER ? combatant.resource : null;
        const hasDecimals = Number.isFinite(initiative) && !Number.isInteger(initiative);
        const turn = {
            hasDecimals,
            hidden,
            id,
            isDefeated,
            initiative,
            isOwner,
            name,
            resource,
            active: index === combat.turn,
            canPing: combatant.sceneId === canvas.scene?.id && game.user.hasPermission('PING_CANVAS'),
            img: await this._getCombatantThumbnail(combatant)
        };

        turn.css = [turn.active ? 'active' : null, hidden ? 'hide' : null, isDefeated ? 'defeated' : null].filterJoin(
            ' '
        );

        const defeatedId = this.getDefeatedId(combatant);
        const effects = [];
        for (const effect of combatant.actor?.temporaryEffects ?? []) {
            if (effect.statuses.has(defeatedId)) turn.isDefeated = true;
            else if (effect.img) effects.push({ img: effect.img, name: effect.name });
        }
        turn.effects = {
            icons: effects,
            tooltip: this._formatEffectsTooltip(effects)
        };

        return { ...turn, isNPC: combatant.isNPC, system: combatant.system.toObject() };
    }

    async setCombatantSpotlight(combatantId) {
        const update = {
            system: {
                'spotlight.requesting': false
            }
        };
        const combatant = this.viewed.combatants.get(combatantId);

        const toggleTurn = this.viewed.combatants.contents
            .sort(this.viewed._sortCombatants)
            .map(x => x.id)
            .indexOf(combatantId);

        if (this.viewed.turn !== toggleTurn) {
            const { updateCountdowns } = game.system.api.applications.ui.DhCountdowns;
            await updateCountdowns(CONFIG.DH.GENERAL.countdownTypes.spotlight.id);

            const autoPoints = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).actionPoints;
            if (autoPoints) {
                update.system.actionTokens = Math.max(combatant.system.actionTokens - 1, 0);
            }
        }

        await this.viewed.update({
            turn: this.viewed.turn === toggleTurn ? null : toggleTurn,
            round: this.viewed.round + 1
        });
        await combatant.update(update);
    }

    static async requestSpotlight(_, target) {
        const { combatantId } = target.closest('[data-combatant-id]')?.dataset ?? {};
        const combatant = this.viewed.combatants.get(combatantId);
        await combatant.update({
            'system.spotlight': {
                requesting: !combatant.system.spotlight.requesting
            }
        });

        this.render();
    }

    static async toggleSpotlight(_, target) {
        const { combatantId } = target.closest('[data-combatant-id]')?.dataset ?? {};
        await this.setCombatantSpotlight(combatantId);
    }

    static async setActionTokens(_, target) {
        const { combatantId, tokenIndex } = target.closest('[data-combatant-id]')?.dataset ?? {};

        const combatant = this.viewed.combatants.get(combatantId);
        const changeIndex = Number(tokenIndex);
        const newIndex = combatant.system.actionTokens > changeIndex ? changeIndex : changeIndex + 1;

        await combatant.update({ 'system.actionTokens': newIndex });
        this.render();
    }

    static openCountdowns() {
        new EncounterCountdowns().open();
    }
}

const { HandlebarsApplicationMixin, ApplicationV2 } = foundry.applications.api;

/**
 * A UI element which displays the Users defined for this world.
 * Currently active users are always displayed, while inactive users can be displayed on toggle.
 *
 * @extends ApplicationV2
 * @mixes HandlebarsApplication
 */

class FearTracker extends HandlebarsApplicationMixin(ApplicationV2) {
    constructor(options = {}) {
        super(options);
    }

    /** @inheritDoc */
    static DEFAULT_OPTIONS = {
        id: 'resources',
        classes: [],
        tag: 'div',
        window: {
            frame: true,
            title: 'Fear',
            positioned: true,
            resizable: true,
            minimizable: false
        },
        actions: {
            setFear: FearTracker.setFear,
            increaseFear: FearTracker.increaseFear
        },
        position: {
            width: 222,
            height: 222
            // top: "200px",
            // left: "120px"
        }
    };

    /** @override */
    static PARTS = {
        resources: {
            root: true,
            template: 'systems/daggerheart/templates/ui/fearTracker.hbs'
        }
    };

    get currentFear() {
        return game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear);
    }

    get maxFear() {
        return game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxFear;
    }

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /** @override */
    async _prepareContext(_options) {
        const display = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance).displayFear,
            current = this.currentFear,
            max = this.maxFear,
            percent = (current / max) * 100,
            isGM = game.user.isGM;
        // Return the data for rendering
        return { display, current, max, percent, isGM };
    }

    /** @override */
    async _preFirstRender(context, options) {
        options.position =
            game.user.getFlag(CONFIG.DH.id, 'app.resources.position') ?? FearTracker.DEFAULT_OPTIONS.position;
    }

    /** @override */
    async _preRender(context, options) {
        if (this.currentFear > this.maxFear)
            await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, this.maxFear);
    }

    _onPosition(position) {
        game.user.setFlag(CONFIG.DH.id, 'app.resources.position', position);
    }

    async close(options = {}) {
        if (!options.allowed) return;
        else super.close(options);
    }

    static async setFear(event, target) {
        if (!game.user.isGM) return;
        const fearCount = Number(target.dataset.index ?? 0);
        await this.updateFear(this.currentFear === fearCount + 1 ? fearCount : fearCount + 1);
    }

    static async increaseFear(event, target) {
        if (!game.user.isGM) return;
        let value = target.dataset.increment ?? 0,
            operator = value.split('')[0] ?? null;
        value = Number(value);
        await this.updateFear(operator ? this.currentFear + value : value);
    }

    async updateFear(value) {
        return emitAsGM(GMUpdateEvent.UpdateFear, game.settings.set.bind(game.settings, CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear), value);
        /* if(!game.user.isGM)
            await game.socket.emit(`system.${CONFIG.DH.id}`, {
                action: socketEvent.GMUpdate,
                data: {
                    action: GMUpdateEvent.UpdateFear,
                    update: value
                }
            });
        else 
            game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, value); */
        /* if (!game.user.isGM) return;
        value = Math.max(0, Math.min(this.maxFear, value));
        await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, value); */
    }
}

class DhHotbar extends foundry.applications.ui.Hotbar {
    constructor(options) {
        super(options);

        this.setupHooks();
    }

    static async useItem(uuid) {
        const item = await fromUuid(uuid);
        if (!item) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: uuid
                }
            });
        }

        await item.use({});
    }

    static async useAction(itemUuid, actionId) {
        const item = await foundry.utils.fromUuid(itemUuid);
        if (!item) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: itemUuid
                }
            });
        }

        const action = item.system.actions.get(actionId);
        if (!action) {
            return ui.notifications.warn('DAGGERHEART.UI.Notifications.actionIsMissing');
        }

        await action.use({});
    }

    static async useAttack(actorUuid) {
        const actor = await foundry.utils.fromUuid(actorUuid);
        if (!actor) {
            return ui.notifications.warn('WARNING.ObjectDoesNotExist', {
                format: {
                    name: game.i18n.localize('Document'),
                    identifier: actorUuid
                }
            });
        }

        const attack = actor.system.attack;
        if (!attack) {
            return ui.notifications.warn('DAGGERHEART.UI.Notifications.attackIsMissing');
        }

        await attack.use({});
    }

    setupHooks() {
        Hooks.on('hotbarDrop', (bar, data, slot) => {
            if (data.type === 'Item') {
                const item = foundry.utils.fromUuidSync(data.uuid);
                if (item.uuid.startsWith('Compendium') || !item.isOwned || !item.isOwner) return true;

                switch (item.type) {
                    case 'ancestry':
                    case 'community':
                    case 'class':
                    case 'subclass':
                        return true;
                    default:
                        this.createItemMacro(item, slot);
                        return false;
                }
            } else if (data.type === 'Action') {
                const item = foundry.utils.fromUuidSync(data.data.itemUuid);
                if (item.uuid.startsWith('Compendium')) return true;
                if (!item.isOwned || !item.isOwner) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.unownedActionMacro'));
                    return false;
                }

                this.createActionMacro(data, slot);
                return false;
            } else if (data.type === 'Attack') {
                const actor = foundry.utils.fromUuidSync(data.actorUuid);
                if (actor.uuid.startsWith('Compendium')) return true;
                if (!actor.isOwner) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.unownedAttackMacro'));
                    return false;
                }

                this.createAttackMacro(data, slot);
                return false;
            }
        });
    }

    async createItemMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useItem("${data.uuid}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }

    async createActionMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useAction("${data.data.itemUuid}", "${data.data.id}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }

    async createAttackMacro(data, slot) {
        const macro = await Macro.implementation.create({
            name: data.name,
            type: CONST.MACRO_TYPES.SCRIPT,
            img: data.img,
            command: `await game.system.api.applications.ui.DhHotbar.useAttack("${data.actorUuid}");`
        });
        await game.user.assignHotbarMacro(macro, slot);
    }
}

var _module$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhChatLog: DhpChatLog,
    DhCombatTracker: DhCombatTracker,
    DhCountdowns: countdowns,
    DhFearTracker: FearTracker,
    DhHotbar: DhHotbar
});

/**
 * @typedef ContextMenuEntry
 * @property {string} name                              The context menu label. Can be localized.
 * @property {string} [icon]                            A string containing an HTML icon element for the menu item.
 * @property {string} [classes]                         Additional CSS classes to apply to this menu item.
 * @property {string} [group]                           An identifier for a group this entry belongs to.
 * @property {ContextMenuJQueryCallback} callback       The function to call when the menu item is clicked.
 * @property {ContextMenuCondition|boolean} [condition] A function to call or boolean value to determine if this entry
 *                                                      appears in the menu.
 */

/**
 * @callback ContextMenuCondition
 * @param {jQuery|HTMLElement} html                     The element of the context menu entry.
 * @returns {boolean}                                   Whether the entry should be rendered in the context menu.
 */

/**
 * @callback ContextMenuCallback
 * @param {HTMLElement} target                          The element that the context menu has been triggered for.
 * @returns {unknown}
 */

/**
 * @callback ContextMenuJQueryCallback
 * @param {HTMLElement|jQuery} target                   The element that the context menu has been triggered for. Will
 *                                                      either be a jQuery object or an HTMLElement instance, depending
 *                                                      on how the ContextMenu was configured.
 * @returns {unknown}
 */

/**
 * @typedef ContextMenuOptions
 * @property {string} [eventName="contextmenu"] Optionally override the triggering event which can spawn the menu. If
 *                                              the menu is using fixed positioning, this event must be a MouseEvent.
 * @property {ContextMenuCallback} [onOpen]     A function to call when the context menu is opened.
 * @property {ContextMenuCallback} [onClose]    A function to call when the context menu is closed.
 * @property {boolean} [fixed=false]            If true, the context menu is given a fixed position rather than being
 *                                              injected into the target.
 * @property {boolean} [jQuery=true]            If true, callbacks will be passed jQuery objects instead of HTMLElement
 *                                              instances.
 */

/**
 * @typedef ContextMenuRenderOptions
 * @property {Event} [event]           The event that triggered the context menu opening.
 * @property {boolean} [animate=true]  Animate the context menu opening.
 */

/**
 * A subclass of ContextMenu.
 * @extends {foundry.applications.ux.ContextMenu}
 */
class DHContextMenu extends foundry.applications.ux.ContextMenu {
    /**
     * @param {HTMLElement|jQuery} container - The HTML element that contains the context menu targets.
     * @param {string} selector - A CSS selector which activates the context menu.
     * @param {ContextMenuEntry[]} menuItems - An Array of entries to display in the menu
     * @param {ContextMenuOptions} [options] - Additional options to configure the context menu.
     */
    constructor(container, selector, menuItems, options) {
        super(container, selector, menuItems, options);

        /** @deprecated since v13 until v15 */
        this.#jQuery = options.jQuery;
    }

    /**
     * Whether to pass jQuery objects or HTMLElement instances to callback.
     * @type {boolean}
     */
    #jQuery;

    /**@inheritdoc */
    activateListeners(menu) {
        menu.addEventListener('click', this.#onClickItem.bind(this));
    }

    /**
     * Handle click events on context menu items.
     * @param {PointerEvent} event      The click event
     */
    #onClickItem(event) {
        event.preventDefault();
        event.stopPropagation();
        const element = event.target.closest('.context-item');
        if (!element) return;
        const item = this.menuItems.find(i => i.element === element);
        item?.callback(this.#jQuery ? $(this.target) : this.target, event);
        this.close();
    }

    /* -------------------------------------------- */

    /**
     * Trigger a context menu event in response to a normal click on a additional options button.
     * @param {PointerEvent} event
     */
    static triggerContextMenu(event) {
        event.preventDefault();
        event.stopPropagation();
        const { clientX, clientY } = event;
        const selector = '[data-item-uuid]';
        const target = event.target.closest(selector) ?? event.currentTarget.closest(selector);
        target?.dispatchEvent(
            new PointerEvent('contextmenu', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX,
                clientY
            })
        );
    }
}

var _module$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHContextMenu: DHContextMenu,
    FilterMenu: FilterMenu
});

var applications = /*#__PURE__*/Object.freeze({
    __proto__: null,
    characterCreation: _module$f,
    dialogs: _module$e,
    hud: _module$d,
    levelup: _module$c,
    settings: _module$b,
    sheetConfigs: _module$6,
    sheets: _module$8,
    ui: _module$5,
    ux: _module$4
});

class DhCombat extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        foundry.data.fields;
        return {};
    }
}

class DhCombatant extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            spotlight: new fields.SchemaField({
                requesting: new fields.BooleanField({ required: true, initial: false })
            }),
            actionTokens: new fields.NumberField({ required: true, integer: true, initial: 3 })
        };
    }

    get isDefeated() {
        const { unconscious, defeated, dead } = CONFIG.DH.GENERAL.conditions;
        const defeatedConditions = new Set([unconscious.id, defeated.id, dead.id]);
        return this.defeated || this.actor?.statuses.intersection(defeatedConditions)?.size;
    }
}

class BaseEffect extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            rangeDependence: new fields.SchemaField({
                enabled: new fields.BooleanField({
                    required: true,
                    initial: false,
                    label: 'DAGGERHEART.GENERAL.enabled'
                }),
                type: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.rangeInclusion,
                    initial: CONFIG.DH.GENERAL.rangeInclusion.withinRange.id,
                    label: 'DAGGERHEART.GENERAL.type'
                }),
                target: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.otherTargetTypes,
                    initial: CONFIG.DH.GENERAL.otherTargetTypes.hostile.id,
                    label: 'DAGGERHEART.GENERAL.Target.single'
                }),
                range: new fields.StringField({
                    required: true,
                    choices: CONFIG.DH.GENERAL.range,
                    initial: CONFIG.DH.GENERAL.range.melee.id,
                    label: 'DAGGERHEART.GENERAL.range'
                })
            })
        };
    }
}

class BeastformEffect extends BaseEffect {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            characterTokenData: new fields.SchemaField({
                tokenImg: new fields.FilePathField({
                    categories: ['IMAGE'],
                    base64: false,
                    nullable: true
                }),
                tokenRingImg: new fields.FilePathField({
                    initial: 'icons/svg/mystery-man.svg',
                    categories: ['IMAGE'],
                    base64: false
                }),
                tokenSize: new fields.SchemaField({
                    height: new fields.NumberField({ integer: true, nullable: true }),
                    width: new fields.NumberField({ integer: true, nullable: true })
                })
            }),
            advantageOn: new fields.ArrayField(new fields.StringField()),
            featureIds: new fields.ArrayField(new fields.StringField()),
            effectIds: new fields.ArrayField(new fields.StringField())
        };
    }

    async _onCreate(_data, _options, userId) {
        if (userId !== game.user.id) return;

        if (this.parent.parent?.type === 'character') {
            this.parent.parent.system.primaryWeapon?.update?.({ 'system.equipped': false });
            this.parent.parent.system.secondaryWeapon?.update?.({ 'system.equipped': false });
        }
    }

    async _preDelete() {
        if (this.parent.parent.type === 'character') {
            const update = {
                height: this.characterTokenData.tokenSize.height,
                width: this.characterTokenData.tokenSize.width,
                texture: {
                    src: this.characterTokenData.tokenImg
                },
                ring: {
                    subject: {
                        texture: this.characterTokenData.tokenRingImg
                    }
                }
            };

            await updateActorTokens(this.parent.parent, update);

            await this.parent.parent.deleteEmbeddedDocuments('Item', this.featureIds);
            await this.parent.parent.deleteEmbeddedDocuments('ActiveEffect', this.effectIds);
        }
    }
}

class HordeEffect extends BaseEffect {}

const config$3 = {
    base: BaseEffect,
    beastform: BeastformEffect,
    horde: HordeEffect
};

var _module$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseEffect: BaseEffect,
    BeastformEffect: BeastformEffect,
    HordeEffect: HordeEffect,
    config: config$3
});

/**
 * A subclass of {@link foundry.data.fields.DocumentUUIDField} to allow selecting a foreign document reference
 * that resolves to either the document, the index(for items in compenidums) or the UUID string.
 */
class ForeignDocumentUUIDField extends foundry.data.fields.DocumentUUIDField {
    /**
     * @param {foundry.data.types.DocumentUUIDFieldOptions} [options] Options which configure the behavior of the field
     * @param {foundry.data.types.DataFieldContext} [context]    Additional context which describes the field
     */
    constructor(options, context) {
        super(options, context);
    }

    /** @inheritdoc */
    static get _defaults() {
        return foundry.utils.mergeObject(super._defaults, {
            nullable: true,
            readonly: false,
            idOnly: false
        });
    }

    /**@override */
    initialize(value, _model, _options = {}) {
        if (this.idOnly) return value;
        return () => {
            try {
                const doc = fromUuidSync(value);
                return doc;
            } catch (error) {
                console.error(error);
                return value ?? null;
            }
        };
    }

    /**@override */
    toObject(value) {
        return value?.uuid ?? value;
    }
}

class DhLevelData extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            level: new fields.SchemaField({
                current: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                changed: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                bonuses: new fields.TypedObjectField(new fields.NumberField({ integer: true, nullable: false }))
            }),
            levelups: new fields.TypedObjectField(
                new fields.SchemaField({
                    achievements: new fields.SchemaField(
                        {
                            experiences: new fields.TypedObjectField(
                                new fields.SchemaField({
                                    name: new fields.StringField({ required: true }),
                                    modifier: new fields.NumberField({ required: true, integer: true })
                                })
                            ),
                            domainCards: new fields.ArrayField(
                                new fields.SchemaField({
                                    uuid: new fields.StringField({ required: true }),
                                    itemUuid: new fields.StringField({ required: true })
                                })
                            ),
                            proficiency: new fields.NumberField({ integer: true })
                        },
                        { nullable: true, initial: null }
                    ),
                    selections: new fields.ArrayField(
                        new fields.SchemaField({
                            tier: new fields.NumberField({ required: true, integer: true }),
                            level: new fields.NumberField({ required: true, integer: true }),
                            optionKey: new fields.StringField({ required: true }),
                            type: new fields.StringField({ required: true, choices: LevelOptionType }),
                            checkboxNr: new fields.NumberField({ required: true, integer: true }),
                            value: new fields.NumberField({ integer: true }),
                            minCost: new fields.NumberField({ integer: true }),
                            amount: new fields.NumberField({ integer: true }),
                            data: new fields.ArrayField(new fields.StringField({ required: true })),
                            secondaryData: new fields.TypedObjectField(new fields.StringField({ required: true })),
                            itemUuid: new fields.DocumentUUIDField({ required: true }),
                            features: new fields.ArrayField(
                                new fields.SchemaField({
                                    onPartner: new fields.BooleanField(),
                                    id: new fields.StringField()
                                })
                            )
                        })
                    )
                })
            )
        };
    }

    get canLevelUp() {
        return this.level.current < this.level.changed;
    }
}

const resistanceField = (resistanceLabel, immunityLabel, reductionLabel) =>
    new foundry.data.fields.SchemaField({
        resistance: new foundry.data.fields.BooleanField({
            initial: false,
            label: `${resistanceLabel}.label`,
            hint: `${resistanceLabel}.hint`,
            isAttributeChoice: true
        }),
        immunity: new foundry.data.fields.BooleanField({
            initial: false,
            label: `${immunityLabel}.label`,
            hint: `${immunityLabel}.hint`,
            isAttributeChoice: true
        }),
        reduction: new foundry.data.fields.NumberField({
            integer: true,
            initial: 0,
            label: `${reductionLabel}.label`,
            hint: `${reductionLabel}.hint`
        })
    });

/**
 * Describes metadata about the actor data model type
 * @typedef {Object} ActorDataModelMetadata
 * @property {string} label - A localizable label used on application.
 * @property {string} type - The system type that this data model represents.
 * @property {Boolean} isNPC - This data model represents a NPC?
 * @property {typeof DHBaseActorSettings} settingSheet - The sheet class used to render the settings UI for this actor type.
 */
class BaseDataActor extends foundry.abstract.TypeDataModel {
    /** @returns {ActorDataModelMetadata}*/
    static get metadata() {
        return {
            label: 'Base Actor',
            type: 'base',
            isNPC: true,
            settingSheet: null,
            hasResistances: true
        };
    }

    /**@returns {ActorDataModelMetadata}*/
    get metadata() {
        return this.constructor.metadata;
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        const schema = {};

        if (this.metadata.isNPC) schema.description = new fields.HTMLField({ required: true, nullable: true });
        if (this.metadata.hasResistances)
            schema.resistance = new fields.SchemaField({
                physical: resistanceField(
                    'DAGGERHEART.GENERAL.DamageResistance.physicalResistance',
                    'DAGGERHEART.GENERAL.DamageResistance.physicalImmunity',
                    'DAGGERHEART.GENERAL.DamageResistance.physicalReduction'
                ),
                magical: resistanceField(
                    'DAGGERHEART.GENERAL.DamageResistance.magicalResistance',
                    'DAGGERHEART.GENERAL.DamageResistance.magicalImmunity',
                    'DAGGERHEART.GENERAL.DamageResistance.magicalReduction'
                )
            });
        return schema;
    }

    /* -------------------------------------------- */

    /**
     * The default icon used for newly created Actors documents
     * @type {string}
     */
    static DEFAULT_ICON = null;

    /* -------------------------------------------- */

    /**
     * Obtain a data object used to evaluate any dice rolls associated with this Item Type
     * @param {object} [options] - Options which modify the getRollData method.
     * @returns {object}
     */
    getRollData() {
        const data = { ...this };
        return data;
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        const autoSettings = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation);
        if (changes.system?.resources && autoSettings.resourceScrollTexts) {
            const textData = Object.keys(changes.system.resources).reduce((acc, key) => {
                const resource = changes.system.resources[key];
                if (resource.value !== undefined && resource.value !== this.resources[key].value) {
                    acc.push(getScrollTextData(this.resources, resource, key));
                }

                return acc;
            }, []);
            options.scrollingTextData = textData;
        }

        if (changes.system?.resources) {
            const defeatedSettings = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Automation
            ).defeated;
            const typeForDefeated = ['character', 'adversary', 'companion'].find(x => x === this.parent.type);
            if (defeatedSettings.enabled && typeForDefeated) {
                const resource = typeForDefeated === 'companion' ? 'stress' : 'hitPoints';
                const resourceValue = changes.system.resources[resource];
                if (
                    resourceValue &&
                    this.resources[resource].max &&
                    resourceValue.value !== this.resources[resource].value
                ) {
                    const becameMax = resourceValue.value === this.resources[resource].max;
                    const wasMax =
                        this.resources[resource].value === this.resources[resource].max &&
                        this.resources[resource].value !== resourceValue.value;
                    if (becameMax) {
                        this.parent.toggleDefeated(true);
                    } else if (wasMax) {
                        this.parent.toggleDefeated(false);
                    }
                }
            }
        }
    }

    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);

        createScrollText(this.parent, options.scrollingTextData);
    }
}

const fields$c = foundry.data.fields;

const attributeField = label =>
    new fields$c.SchemaField({
        value: new fields$c.NumberField({ initial: 0, integer: true, label }),
        tierMarked: new fields$c.BooleanField({ initial: false })
    });

const resourceField = (max = 0, initial = 0, label, reverse = false, maxLabel) =>
    new fields$c.SchemaField({
        value: new fields$c.NumberField({ initial: initial, min: 0, integer: true, label }),
        max: new fields$c.NumberField({
            initial: max,
            integer: true,
            label:
                maxLabel ?? game.i18n.format('DAGGERHEART.GENERAL.maxWithThing', { thing: game.i18n.localize(label) })
        }),
        isReversed: new fields$c.BooleanField({ initial: reverse })
    });

const stressDamageReductionRule = localizationPath =>
    new fields$c.SchemaField({
        cost: new fields$c.NumberField({
            integer: true,
            label: `${localizationPath}.label`,
            hint: `${localizationPath}.hint`
        })
    });

const bonusField = label =>
    new fields$c.SchemaField({
        bonus: new fields$c.NumberField({ integer: true, initial: 0, label: `${game.i18n.localize(label)} Value` }),
        dice: new fields$c.ArrayField(new fields$c.StringField(), { label: `${game.i18n.localize(label)} Dice` })
    });

class DhCharacter extends BaseDataActor {
    /**@override */
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Character'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.character',
            type: 'character',
            settingSheet: DHCharacterSettings,
            isNPC: false
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            ...super.defineSchema(),
            resources: new fields.SchemaField({
                hitPoints: resourceField(
                    0,
                    0,
                    'DAGGERHEART.GENERAL.HitPoints.plural',
                    true,
                    'DAGGERHEART.ACTORS.Character.maxHPBonus'
                ),
                stress: resourceField(6, 0, 'DAGGERHEART.GENERAL.stress', true),
                hope: resourceField(6, 2, 'DAGGERHEART.GENERAL.hope')
            }),
            traits: new fields.SchemaField({
                agility: attributeField('DAGGERHEART.CONFIG.Traits.agility.name'),
                strength: attributeField('DAGGERHEART.CONFIG.Traits.strength.name'),
                finesse: attributeField('DAGGERHEART.CONFIG.Traits.finesse.name'),
                instinct: attributeField('DAGGERHEART.CONFIG.Traits.instinct.name'),
                presence: attributeField('DAGGERHEART.CONFIG.Traits.presence.name'),
                knowledge: attributeField('DAGGERHEART.CONFIG.Traits.knowledge.name')
            }),
            proficiency: new fields.NumberField({
                initial: 1,
                integer: true,
                label: 'DAGGERHEART.GENERAL.proficiency'
            }),
            evasion: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.evasion' }),
            armorScore: new fields.NumberField({ integer: true, initial: 0, label: 'DAGGERHEART.GENERAL.armorScore' }),
            damageThresholds: new fields.SchemaField({
                severe: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.severeThreshold'
                }),
                major: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.majorThreshold'
                })
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField(),
                    value: new fields.NumberField({ integer: true, initial: 0 }),
                    description: new fields.StringField(),
                    core: new fields.BooleanField({ initial: false })
                })
            ),
            gold: new fields.SchemaField({
                coins: new fields.NumberField({ initial: 0, integer: true }),
                handfuls: new fields.NumberField({ initial: 1, integer: true }),
                bags: new fields.NumberField({ initial: 0, integer: true }),
                chests: new fields.NumberField({ initial: 0, integer: true })
            }),
            scars: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({}),
                    description: new fields.StringField()
                })
            ),
            biography: new fields.SchemaField({
                background: new fields.HTMLField(),
                connections: new fields.HTMLField(),
                characteristics: new fields.SchemaField({
                    pronouns: new fields.StringField({}),
                    age: new fields.StringField({}),
                    faith: new fields.StringField({})
                })
            }),
            attack: new ActionField({
                initial: {
                    name: 'DAGGERHEART.GENERAL.unarmedAttack',
                    img: 'icons/skills/melee/unarmed-punch-fist-yellow-red.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack',
                        trait: 'strength'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    custom: {
                                        enabled: true,
                                        formula: '@profd4'
                                    }
                                }
                            }
                        ]
                    }
                }
            }),
            advantageSources: new fields.ArrayField(new fields.StringField(), {
                label: 'DAGGERHEART.ACTORS.Character.advantageSources.label',
                hint: 'DAGGERHEART.ACTORS.Character.advantageSources.hint'
            }),
            disadvantageSources: new fields.ArrayField(new fields.StringField(), {
                label: 'DAGGERHEART.ACTORS.Character.disadvantageSources.label',
                hint: 'DAGGERHEART.ACTORS.Character.disadvantageSources.hint'
            }),
            levelData: new fields.EmbeddedDataField(DhLevelData),
            bonuses: new fields.SchemaField({
                roll: new fields.SchemaField({
                    attack: bonusField('DAGGERHEART.GENERAL.Roll.attack'),
                    spellcast: bonusField('DAGGERHEART.GENERAL.Roll.spellcast'),
                    trait: bonusField('DAGGERHEART.GENERAL.Roll.trait'),
                    action: bonusField('DAGGERHEART.GENERAL.Roll.action'),
                    reaction: bonusField('DAGGERHEART.GENERAL.Roll.reaction'),
                    primaryWeapon: bonusField('DAGGERHEART.GENERAL.Roll.primaryWeaponAttack'),
                    secondaryWeapon: bonusField('DAGGERHEART.GENERAL.Roll.secondaryWeaponAttack')
                }),
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage'),
                    primaryWeapon: bonusField('DAGGERHEART.GENERAL.Damage.primaryWeapon'),
                    secondaryWeapon: bonusField('DAGGERHEART.GENERAL.Damage.secondaryWeapon')
                }),
                healing: bonusField('DAGGERHEART.GENERAL.Healing.healingAmount'),
                range: new fields.SchemaField({
                    weapon: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.weapon'
                    }),
                    spell: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.spell'
                    }),
                    other: new fields.NumberField({
                        integer: true,
                        initial: 0,
                        label: 'DAGGERHEART.GENERAL.Range.other'
                    })
                }),
                rally: new fields.ArrayField(new fields.StringField(), {
                    label: 'DAGGERHEART.CLASS.Feature.rallyDice'
                }),
                rest: new fields.SchemaField({
                    shortRest: new fields.SchemaField({
                        shortMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.shortRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.shortRestMoves.hint'
                        }),
                        longMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.longRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.shortRest.longRestMoves.hint'
                        })
                    }),
                    longRest: new fields.SchemaField({
                        shortMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.shortRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.shortRestMoves.hint'
                        }),
                        longMoves: new fields.NumberField({
                            required: true,
                            integer: true,
                            min: 0,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.longRestMoves.label',
                            hint: 'DAGGERHEART.GENERAL.Bonuses.rest.longRest.longRestMoves.hint'
                        })
                    })
                }),
                maxLoadout: new fields.NumberField({
                    integer: true,
                    initial: 0,
                    label: 'DAGGERHEART.GENERAL.Bonuses.maxLoadout.label'
                })
            }),
            companion: new ForeignDocumentUUIDField({ type: 'Actor', nullable: true, initial: null }),
            rules: new fields.SchemaField({
                damageReduction: new fields.SchemaField({
                    maxArmorMarked: new fields.SchemaField({
                        value: new fields.NumberField({
                            required: true,
                            integer: true,
                            initial: 1,
                            label: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedBonus'
                        }),
                        stressExtra: new fields.NumberField({
                            required: true,
                            integer: true,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedStress.label',
                            hint: 'DAGGERHEART.GENERAL.Rules.damageReduction.maxArmorMarkedStress.hint'
                        })
                    }),
                    stressDamageReduction: new fields.SchemaField({
                        severe: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.severe'),
                        major: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.major'),
                        minor: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.minor'),
                        any: stressDamageReductionRule('DAGGERHEART.GENERAL.Rules.damageReduction.stress.any')
                    }),
                    increasePerArmorMark: new fields.NumberField({
                        integer: true,
                        initial: 1,
                        label: 'DAGGERHEART.GENERAL.Rules.damageReduction.increasePerArmorMark.label',
                        hint: 'DAGGERHEART.GENERAL.Rules.damageReduction.increasePerArmorMark.hint'
                    }),
                    magical: new fields.BooleanField({ initial: false }),
                    physical: new fields.BooleanField({ initial: false }),
                    thresholdImmunities: new fields.SchemaField({
                        minor: new fields.BooleanField({ initial: false })
                    }),
                    disabledArmor: new fields.BooleanField({ intial: false })
                }),
                attack: new fields.SchemaField({
                    damage: new fields.SchemaField({
                        diceIndex: new fields.NumberField({
                            integer: true,
                            min: 0,
                            max: 5,
                            initial: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.damage.dice.label',
                            hint: 'DAGGERHEART.GENERAL.Rules.attack.damage.dice.hint'
                        }),
                        bonus: new fields.NumberField({
                            required: true,
                            initial: 0,
                            min: 0,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.damage.bonus.label'
                        })
                    }),
                    roll: new fields.SchemaField({
                        trait: new fields.StringField({
                            required: true,
                            choices: CONFIG.DH.ACTOR.abilities,
                            nullable: true,
                            initial: null,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.roll.trait.label'
                        })
                    })
                }),
                runeWard: new fields.BooleanField({ initial: false }),
                burden: new fields.SchemaField({
                    ignore: new fields.BooleanField()
                })
            })
        };
    }

    /* -------------------------------------------- */

    get tier() {
        const currentLevel = this.levelData.level.current;
        return currentLevel === 1
            ? 1
            : Object.values(game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers).find(
                  tier => currentLevel >= tier.levels.start && currentLevel <= tier.levels.end
              ).tier;
    }

    get ancestry() {
        return this.parent.items.find(x => x.type === 'ancestry') ?? null;
    }

    get community() {
        return this.parent.items.find(x => x.type === 'community') ?? null;
    }

    get class() {
        const value = this.parent.items.find(x => x.type === 'class' && !x.system.isMulticlass);
        const subclass = this.parent.items.find(x => x.type === 'subclass' && !x.system.isMulticlass);

        return {
            value,
            subclass
        };
    }

    get multiclass() {
        const value = this.parent.items.find(x => x.type === 'class' && x.system.isMulticlass);
        const subclass = this.parent.items.find(x => x.type === 'subclass' && x.system.isMulticlass);

        return {
            value,
            subclass
        };
    }

    get features() {
        return this.parent.items.filter(x => x.type === 'feature') ?? [];
    }

    get companionFeatures() {
        return this.companion ? this.companion.items.filter(x => x.type === 'feature') : [];
    }

    get needsCharacterSetup() {
        const { value: classValue, subclass } = this.class;
        return !(classValue || subclass || this.ancestry || this.community);
    }

    get spellcastModifierTrait() {
        const subClasses = this.parent.items.filter(x => x.type === 'subclass') ?? [];
        const modifiers = subClasses
            ?.map(sc => ({ ...this.traits[sc.system.spellcastingTrait], key: sc.system.spellcastingTrait }))
            .filter(x => x);
        return modifiers.sort((a, b) => a.value - b.value)[0];
    }

    get spellcastModifier() {
        return this.spellcastModifierTrait?.value ?? 0;
    }

    get spellcastingModifiers() {
        return {
            main: this.class.subclass?.system?.spellcastingTrait,
            multiclass: this.multiclass.subclass?.system?.spellcastingTrait
        };
    }

    get domains() {
        const classDomains = this.class.value ? this.class.value.system.domains : [];
        const multiclass = this.multiclass.value;
        const multiclassDomains = multiclass ? multiclass.system.domains : [];
        return [...classDomains, ...multiclassDomains];
    }

    get domainData() {
        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        return this.domains.map(key => {
            const domain = allDomainData[key];
            return {
                ...domain,
                label: game.i18n.localize(domain.label)
            };
        });
    }

    get domainCards() {
        const domainCards = this.parent.items.filter(x => x.type === 'domainCard');
        const loadout = domainCards.filter(x => !x.system.inVault);
        const vault = domainCards.filter(x => x.system.inVault);

        return {
            loadout: loadout,
            vault: vault,
            total: [...loadout, ...vault]
        };
    }

    get loadoutSlot() {
        const loadoutCount = this.domainCards.loadout?.length ?? 0,
            worldSetting = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxLoadout,
            max = !worldSetting ? null : worldSetting + this.bonuses.maxLoadout;

        return {
            current: loadoutCount,
            available: !max ? true : Math.max(max - loadoutCount, 0),
            max
        };
    }

    get armor() {
        return this.parent.items.find(x => x.type === 'armor' && x.system.equipped);
    }

    get activeBeastform() {
        return this.parent.effects.find(x => x.type === 'beastform');
    }

    /**
     * Gets the unarmed attackwhen no primary or secondary weapon is equipped.
     * Returns `null` if either weapon is equipped.
     * If the actor is in beastform, overrides the attack's name and image.
     *
     * @returns {DHAttackAction|null}
     */
    get usedUnarmed() {
        if (this.primaryWeapon?.system?.equipped || this.secondaryWeapon?.system?.equipped) return null;

        const attack = foundry.utils.deepClone(this.attack);
        if (this.activeBeastform) {
            attack.name = 'DAGGERHEART.ITEMS.Beastform.attackName';
            attack.img = 'icons/creatures/claws/claw-straight-brown.webp';
        }
        return attack;
    }

    get sheetLists() {
        const ancestryFeatures = [],
            communityFeatures = [],
            classFeatures = [],
            subclassFeatures = [],
            companionFeatures = [],
            features = [];

        for (let item of this.parent.items) {
            if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.ancestry.id) {
                ancestryFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.community.id) {
                communityFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.class.id) {
                classFeatures.push(item);
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.subclass.id) {
                if (this.class.subclass) {
                    const prop = item.system.multiclassOrigin ? 'multiclass' : 'class';
                    const subclassState = this[prop].subclass?.system?.featureState;
                    if (!subclassState) continue;

                    if (
                        item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.foundation ||
                        (item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.specialization &&
                            subclassState >= 2) ||
                        (item.system.identifier === CONFIG.DH.ITEM.featureSubTypes.mastery && subclassState >= 3)
                    ) {
                        subclassFeatures.push(item);
                    }
                }
            } else if (item.system.originItemType === CONFIG.DH.ITEM.featureTypes.companion.id) {
                companionFeatures.push(item);
            } else if (item.type === 'feature' && !item.system.type) {
                features.push(item);
            }
        }

        return {
            ancestryFeatures: {
                title: `${game.i18n.localize('TYPES.Item.ancestry')} - ${this.ancestry?.name}`,
                type: 'ancestry',
                values: ancestryFeatures
            },
            communityFeatures: {
                title: `${game.i18n.localize('TYPES.Item.community')} - ${this.community?.name}`,
                type: 'community',
                values: communityFeatures
            },
            classFeatures: {
                title: `${game.i18n.localize('TYPES.Item.class')} - ${this.class.value?.name}`,
                type: 'class',
                values: classFeatures
            },
            subclassFeatures: {
                title: `${game.i18n.localize('TYPES.Item.subclass')} - ${this.class.subclass?.name}`,
                type: 'subclass',
                values: subclassFeatures
            },
            companionFeatures: {
                title: game.i18n.localize('DAGGERHEART.ACTORS.Character.companionFeatures'),
                type: 'companion',
                values: companionFeatures
            },
            features: { title: game.i18n.localize('DAGGERHEART.GENERAL.features'), type: 'feature', values: features }
        };
    }

    get primaryWeapon() {
        return this.parent.items.find(x => x.type === 'weapon' && x.system.equipped && !x.system.secondary);
    }

    get secondaryWeapon() {
        return this.parent.items.find(x => x.type === 'weapon' && x.system.equipped && x.system.secondary);
    }

    get getWeaponBurden() {
        return this.primaryWeapon?.system?.burden === burden.twoHanded.value ||
            (this.primaryWeapon && this.secondaryWeapon)
            ? burden.twoHanded.value
            : this.primaryWeapon || this.secondaryWeapon
              ? burden.oneHanded.value
              : null;
    }

    get deathMoveViable() {
        return this.resources.hitPoints.max > 0 && this.resources.hitPoints.value >= this.resources.hitPoints.max;
    }

    get armorApplicableDamageTypes() {
        return {
            physical: !this.rules.damageReduction.magical,
            magical: !this.rules.damageReduction.physical
        };
    }

    get basicAttackDamageDice() {
        const diceTypes = Object.keys(CONFIG.DH.GENERAL.diceTypes);
        const attackDiceIndex = Math.max(Math.min(this.rules.attack.damage.diceIndex, 5), 0);
        return diceTypes[attackDiceIndex];
    }

    static async unequipBeforeEquip(itemToEquip) {
        const primary = this.primaryWeapon,
            secondary = this.secondaryWeapon;
        if (itemToEquip.system.secondary) {
            if (primary && primary.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                await primary.update({ 'system.equipped': false });
            }

            if (secondary) {
                await secondary.update({ 'system.equipped': false });
            }
        } else {
            if (secondary && itemToEquip.system.burden === CONFIG.DH.GENERAL.burden.twoHanded.value) {
                await secondary.update({ 'system.equipped': false });
            }

            if (primary) {
                await primary.update({ 'system.equipped': false });
            }
        }
    }

    prepareBaseData() {
        this.evasion += this.class.value?.system?.evasion ?? 0;

        const currentLevel = this.levelData.level.current;
        const currentTier =
            currentLevel === 1
                ? null
                : Object.values(game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers).tiers).find(
                      tier => currentLevel >= tier.levels.start && currentLevel <= tier.levels.end
                  ).tier;
        if (game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto) {
            for (let levelKey in this.levelData.levelups) {
                const level = this.levelData.levelups[levelKey];

                this.proficiency += level.achievements.proficiency;

                for (let selection of level.selections) {
                    switch (selection.type) {
                        case 'trait':
                            selection.data.forEach(data => {
                                this.traits[data].value += 1;
                                this.traits[data].tierMarked = selection.tier === currentTier;
                            });
                            break;
                        case 'hitPoint':
                            this.resources.hitPoints.max += selection.value;
                            break;
                        case 'stress':
                            this.resources.stress.max += selection.value;
                            break;
                        case 'evasion':
                            this.evasion += selection.value;
                            break;
                        case 'proficiency':
                            this.proficiency += selection.value;
                            break;
                        case 'experience':
                            selection.data.forEach(id => {
                                const experience = this.experiences[id];
                                if (experience) {
                                    experience.value += selection.value;
                                    experience.leveledUp = true;
                                }
                            });
                            break;
                    }
                }
            }
        }

        const armor = this.armor;
        this.armorScore = armor ? armor.system.baseScore : 0;
        this.damageThresholds = {
            major: armor
                ? armor.system.baseThresholds.major + this.levelData.level.current
                : this.levelData.level.current,
            severe: armor
                ? armor.system.baseThresholds.severe + this.levelData.level.current
                : this.levelData.level.current * 2
        };
        this.resources.hope.max -= Object.keys(this.scars).length;
        this.resources.hitPoints.max += this.class.value?.system?.hitPoints ?? 0;
    }

    prepareDerivedData() {
        let baseHope = this.resources.hope.value;
        if (this.companion) {
            for (let levelKey in this.companion.system.levelData.levelups) {
                const level = this.companion.system.levelData.levelups[levelKey];
                for (let selection of level.selections) {
                    switch (selection.type) {
                        case 'hope':
                            this.resources.hope.max += selection.value;
                            break;
                    }
                }
            }
        }

        this.resources.hope.value = Math.min(baseHope, this.resources.hope.max);
        this.attack.roll.trait = this.rules.attack.roll.trait ?? this.attack.roll.trait;

        this.resources.armor = {
            value: this.armor?.system?.marks?.value ?? 0,
            max: this.armorScore,
            isReversed: true
        };

        this.attack.damage.parts[0].value.custom.formula = `@prof${this.basicAttackDamageDice}${this.rules.attack.damage.bonus ? ` + ${this.rules.attack.damage.bonus}` : ''}`;
    }

    getRollData() {
        const data = super.getRollData();

        return {
            ...data,
            basicAttackDamageDice: this.basicAttackDamageDice,
            tier: this.tier,
            level: this.levelData.level.current
        };
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        /* The first two experiences are always marked as core */
        if (changes.system?.experiences && Object.keys(this.experiences).length < 2) {
            const experiences = new Set(Object.keys(this.experiences));
            const changeExperiences = new Set(Object.keys(changes.system.experiences));
            const newExperiences = Array.from(changeExperiences.difference(experiences));

            for (var i = 0; i < Math.min(newExperiences.length, 2 - experiences.size); i++) {
                const experience = newExperiences[i];
                changes.system.experiences[experience].core = true;
            }
        }
    }

    async _preDelete() {
        if (this.companion) {
            this.companion.updateLevel(1);
        }
    }
}

class DhCompanion extends BaseDataActor {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Companion'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.companion',
            type: 'companion',
            isNPC: false,
            settingSheet: DHCompanionSettings
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            ...super.defineSchema(),
            partner: new ForeignDocumentUUIDField({ type: 'Actor' }),
            resources: new fields.SchemaField({
                stress: resourceField(3, 0, 'DAGGERHEART.GENERAL.stress', true),
                hope: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.hope' })
            }),
            evasion: new fields.NumberField({
                required: true,
                min: 1,
                initial: 10,
                integer: true,
                label: 'DAGGERHEART.GENERAL.evasion'
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField({}),
                    value: new fields.NumberField({ integer: true, initial: 0 }),
                    description: new fields.StringField(),
                    core: new fields.BooleanField({ initial: false })
                }),
                {
                    initial: {
                        experience1: { value: 2, core: true },
                        experience2: { value: 2, core: true }
                    }
                }
            ),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/creatures/claws/claw-bear-paw-swipe-brown.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack',
                        bonus: 0
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    dice: 'd6',
                                    multiplier: 'prof'
                                }
                            }
                        ]
                    }
                }
            }),
            levelData: new fields.EmbeddedDataField(DhLevelData),
            bonuses: new fields.SchemaField({
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage')
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/capybara.svg';

    /* -------------------------------------------- */

    get proficiency() {
        return this.partner?.system?.proficiency ?? 1;
    }

    prepareBaseData() {
        this.attack.roll.bonus = this.partner?.system?.spellcastModifier ?? 0;

        for (let levelKey in this.levelData.levelups) {
            const level = this.levelData.levelups[levelKey];
            for (let selection of level.selections) {
                switch (selection.type) {
                    case 'hope':
                        this.resources.hope += selection.value;
                        break;
                    case 'vicious':
                        if (selection.data[0] === 'damage') {
                            this.attack.damage.parts[0].value.dice = adjustDice(this.attack.damage.parts[0].value.dice);
                        } else {
                            this.attack.range = adjustRange(this.attack.range);
                        }
                        break;
                    case 'stress':
                        this.resources.stress.max += selection.value;
                        break;
                    case 'evasion':
                        this.evasion += selection.value;
                        break;
                    case 'experience':
                        Object.keys(this.experiences).forEach(key => {
                            const experience = this.experiences[key];
                            experience.value += selection.value;
                        });
                        break;
                }
            }
        }
    }

    async _preUpdate(changes, options, userId) {
        const allowed = await super._preUpdate(changes, options, userId);
        if (allowed === false) return;

        /* The first two experiences are always marked as core */
        if (changes.system?.experiences && Object.keys(this.experiences).length < 2) {
            const experiences = new Set(Object.keys(this.experiences));
            const changeExperiences = new Set(Object.keys(changes.system.experiences));
            const newExperiences = Array.from(changeExperiences.difference(experiences));

            for (var i = 0; i < Math.min(newExperiences.length, 2 - experiences.size); i++) {
                const experience = newExperiences[i];
                changes.system.experiences[experience].core = true;
            }
        }
    }

    async _preDelete() {
        if (this.partner) {
            await this.partner.update({ 'system.companion': null });
        }
    }
}

class DhpAdversary extends BaseDataActor {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Adversary'];

    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.adversary',
            type: 'adversary',
            settingSheet: DHAdversarySettings
        });
    }

    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            type: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ACTOR.adversaryTypes,
                initial: CONFIG.DH.ACTOR.adversaryTypes.standard.id
            }),
            motivesAndTactics: new fields.StringField(),
            notes: new fields.HTMLField(),
            difficulty: new fields.NumberField({ required: true, initial: 1, integer: true }),
            hordeHp: new fields.NumberField({
                required: true,
                initial: 1,
                integer: true,
                label: 'DAGGERHEART.GENERAL.hordeHp'
            }),
            damageThresholds: new fields.SchemaField({
                major: new fields.NumberField({
                    required: true,
                    initial: 0,
                    integer: true,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.majorThreshold'
                }),
                severe: new fields.NumberField({
                    required: true,
                    initial: 0,
                    integer: true,
                    label: 'DAGGERHEART.GENERAL.DamageThresholds.severeThreshold'
                })
            }),
            resources: new fields.SchemaField({
                hitPoints: resourceField(0, 0, 'DAGGERHEART.GENERAL.HitPoints.plural', true),
                stress: resourceField(0, 0, 'DAGGERHEART.GENERAL.stress', true)
            }),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/skills/melee/blood-slash-foam-red.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    chatDisplay: false,
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        type: 'attack'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    multiplier: 'flat'
                                }
                            }
                        ]
                    }
                }
            }),
            experiences: new fields.TypedObjectField(
                new fields.SchemaField({
                    name: new fields.StringField(),
                    value: new fields.NumberField({ required: true, integer: true, initial: 1 }),
                    description: new fields.StringField()
                })
            ),
            bonuses: new fields.SchemaField({
                roll: new fields.SchemaField({
                    attack: bonusField('DAGGERHEART.GENERAL.Roll.attack'),
                    action: bonusField('DAGGERHEART.GENERAL.Roll.action'),
                    reaction: bonusField('DAGGERHEART.GENERAL.Roll.reaction')
                }),
                damage: new fields.SchemaField({
                    physical: bonusField('DAGGERHEART.GENERAL.Damage.physicalDamage'),
                    magical: bonusField('DAGGERHEART.GENERAL.Damage.magicalDamage')
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/dragon-head.svg';

    /* -------------------------------------------- */

    get attackBonus() {
        return this.attack.roll.bonus;
    }

    get features() {
        return this.parent.items.filter(x => x.type === 'feature');
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        if (this.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
            const autoHordeDamage = game.settings.get(
                CONFIG.DH.id,
                CONFIG.DH.SETTINGS.gameSettings.Automation
            ).hordeDamage;
            if (autoHordeDamage && changes.system?.resources?.hitPoints?.value !== undefined) {
                const hordeActiveEffect = this.parent.effects.find(x => x.type === 'horde');
                if (hordeActiveEffect) {
                    const halfHP = Math.ceil(this.resources.hitPoints.max / 2);
                    const newHitPoints = changes.system.resources.hitPoints.value;
                    const previouslyAboveHalf = this.resources.hitPoints.value < halfHP;
                    const loweredBelowHalf = previouslyAboveHalf && newHitPoints >= halfHP;
                    const raisedAboveHalf = !previouslyAboveHalf && newHitPoints < halfHP;
                    if (loweredBelowHalf) {
                        await hordeActiveEffect.update({ disabled: false });
                    } else if (raisedAboveHalf) {
                        await hordeActiveEffect.update({ disabled: true });
                    }
                }
            }
        }
    }

    _onUpdate(changes, options, userId) {
        super._onUpdate(changes, options, userId);

        if (game.user.id === userId) {
            if (changes.system?.type) {
                const existingHordeEffect = this.parent.effects.find(x => x.type === 'horde');
                if (changes.system.type === CONFIG.DH.ACTOR.adversaryTypes.horde.id) {
                    if (!existingHordeEffect)
                        this.parent.createEmbeddedDocuments('ActiveEffect', [
                            {
                                type: 'horde',
                                name: game.i18n.localize('DAGGERHEART.CONFIG.AdversaryType.horde.label'),
                                img: 'icons/magic/movement/chevrons-down-yellow.webp',
                                disabled: true
                            }
                        ]);
                } else {
                    existingHordeEffect?.delete();
                }
            }
        }
    }
}

/**
 * A subclass of {@link foundry.data.fields.ArrayField} that defines an array of foreign document UUID references.
 */
class ForeignDocumentUUIDArrayField extends foundry.data.fields.ArrayField {
    /**
     * @param {foundry.data.types.DocumentUUIDFieldOptions} [fieldOption] - Options to configure each individual ForeignDocumentUUIDField.
     * @param {foundry.data.types.ArrayFieldOptions} [options] - Options to configure the array behavior
     * @param {foundry.data.types.DataFieldContext} [context] -  Optional context for schema processing
     */
    constructor(fieldOption = {}, options = {}, context = {}) {
        super(new ForeignDocumentUUIDField(fieldOption), options, context);
    }

    /** @inheritdoc */
    initialize(value, model, options = {}) {
        const v = super.initialize(value, model, options);
        return () => v.map(entry => (typeof entry === 'function' ? entry() : entry));
    }
}

class DhEnvironment extends BaseDataActor {
    /**@override */
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ACTORS.Environment'];

    /**@inheritdoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Actor.environment',
            type: 'environment',
            settingSheet: DHEnvironmentSettings,
            hasResistances: false
        });
    }

    /**@inheritdoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            type: new fields.StringField({ choices: CONFIG.DH.ACTOR.environmentTypes }),
            impulses: new fields.StringField(),
            difficulty: new fields.NumberField({ required: true, initial: 11, integer: true }),
            potentialAdversaries: new fields.TypedObjectField(
                new fields.SchemaField({
                    label: new fields.StringField(),
                    adversaries: new ForeignDocumentUUIDArrayField({ type: 'Actor' })
                })
            ),
            notes: new fields.HTMLField()
        };
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/actors/forest.svg';

    /* -------------------------------------------- */

    get features() {
        return this.parent.items.filter(x => x.type === 'feature');
    }
}

const config$2 = {
    character: DhCharacter,
    companion: DhCompanion,
    adversary: DhpAdversary,
    environment: DhEnvironment
};

var _module$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhAdversary: DhpAdversary,
    DhCharacter: DhCharacter,
    DhCompanion: DhCompanion,
    DhEnvironment: DhEnvironment,
    config: config$2
});

class DHAbilityUse extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            origin: new fields.StringField({}),
            img: new fields.StringField({}),
            name: new fields.StringField({}),
            description: new fields.StringField({}),
            actions: new fields.ArrayField(
                new fields.ObjectField({
                    name: new fields.StringField({}),
                    damage: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.StringField({})
                    }),
                    healing: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.StringField({})
                    }),
                    cost: new fields.SchemaField({
                        type: new fields.StringField({}),
                        value: new fields.NumberField({})
                    }),
                    target: new fields.SchemaField({
                        type: new fields.StringField({ nullable: true })
                    })
                })
            )
        };
    }
}

const fields$b = foundry.data.fields;

const targetsField = () =>
    new fields$b.ArrayField(
        new fields$b.SchemaField({
            id: new fields$b.StringField({}),
            actorId: new fields$b.StringField({}),
            name: new fields$b.StringField({}),
            img: new fields$b.StringField({}),
            difficulty: new fields$b.NumberField({ integer: true, nullable: true }),
            evasion: new fields$b.NumberField({ integer: true }),
            hit: new fields$b.BooleanField({ initial: false }),
            saved: new fields$b.SchemaField({
                result: new fields$b.NumberField(),
                success: new fields$b.BooleanField({ nullable: true, initial: null })
            })
        })
    );

class DHActorRoll extends foundry.abstract.TypeDataModel {
    static defineSchema() {
        return {
            title: new fields$b.StringField(),
            roll: new fields$b.ObjectField(),
            targets: targetsField(),
            hasRoll: new fields$b.BooleanField({ initial: false }),
            hasDamage: new fields$b.BooleanField({ initial: false }),
            hasHealing: new fields$b.BooleanField({ initial: false }),
            hasEffect: new fields$b.BooleanField({ initial: false }),
            hasSave: new fields$b.BooleanField({ initial: false }),
            hasTarget: new fields$b.BooleanField({ initial: false }),
            isCritical: new fields$b.BooleanField({ initial: false }),
            onSave: new fields$b.StringField(),
            source: new fields$b.SchemaField({
                actor: new fields$b.StringField(),
                item: new fields$b.StringField(),
                action: new fields$b.StringField()
            }),
            damage: new fields$b.ObjectField(),
            costs: new fields$b.ArrayField(new fields$b.ObjectField()),
            successConsumed: new fields$b.BooleanField({ initial: false })
        };
    }

    get actionActor() {
        if (!this.source.actor) return null;
        return fromUuidSync(this.source.actor);
    }

    get actionItem() {
        const actionActor = this.actionActor;
        if (!actionActor || !this.source.item) return null;
        return actionActor.items.get(this.source.item);
    }

    get action() {
        const actionItem = this.actionItem;
        if (!actionItem || !this.source.action) return null;
        return actionItem.system.actionsList?.find(a => a.id === this.source.action);
    }

    get targetMode() {
        return this.parent.targetSelection;
    }

    set targetMode(mode) {
        if (!this.parent.isAuthor) return;
        this.parent.targetSelection = mode;
        this.registerTargetHook();
        this.updateTargets();
    }

    get hitTargets() {
        return this.currentTargets.filter(t => t.hit || !this.hasRoll || !this.targetMode);
    }

    async updateTargets() {
        if (!ui.chat.collection.get(this.parent.id)) return;
        let targets;
        if (this.targetMode) targets = this.targets;
        else
            targets = Array.from(game.user.targets).map(t =>
                game.system.api.fields.ActionFields.TargetField.formatTarget(t)
            );

        await this.parent.update({
            flags: {
                [game.system.id]: {
                    targets: targets,
                    targetMode: this.targetMode
                }
            }
        });
    }

    registerTargetHook() {
        if (!this.parent.isAuthor) return;
        if (this.targetMode && this.parent.targetHook !== null) {
            Hooks.off('targetToken', this.parent.targetHook);
            return (this.parent.targetHook = null);
        } else if (!this.targetMode && this.parent.targetHook === null) {
            return (this.parent.targetHook = Hooks.on(
                'targetToken',
                foundry.utils.debounce(this.updateTargets.bind(this), 50)
            ));
        }
    }

    prepareDerivedData() {
        if (this.hasTarget) {
            this.hasHitTarget = this.targets.filter(t => t.hit === true).length > 0;
            this.currentTargets = this.getTargetList();
            // this.registerTargetHook();

            if (this.hasRoll) {
                this.targetShort = this.targets.reduce(
                    (a, c) => {
                        if (c.hit) a.hit += 1;
                        else a.miss += 1;
                        return a;
                    },
                    { hit: 0, miss: 0 }
                );
            }
            if (this.hasSave) this.setPendingSaves();
        }

        this.canViewSecret = this.parent.speakerActor?.testUserPermission(game.user, 'OBSERVER');
        this.canButtonApply = game.user.isGM;   //temp
        this.isGM = game.user.isGM; //temp
    }

    getTargetList() {
        const targets =
                this.targetMode && this.parent.isAuthor
                    ? this.targets
                    : (this.parent.getFlag(game.system.id, 'targets') ?? this.targets),
            reactionRolls = this.parent.getFlag(game.system.id, 'reactionRolls');

        if (reactionRolls) {
            Object.entries(reactionRolls).forEach(([k, r]) => {
                const target = targets.find(t => t.id === k);
                if (target) target.saved = r;
            });
        }

        return targets;
    }

    setPendingSaves() {
        this.pendingSaves = this.targetMode
            ? this.targets.filter(target => target.hit && target.saved.success === null).length > 0
            : this.currentTargets.filter(target => target.saved.success === null).length > 0;
    }
}

const config$1 = {
  abilityUse: DHAbilityUse,
  adversaryRoll: DHActorRoll,
  damageRoll: DHActorRoll,
  dualityRoll: DHActorRoll
};

var _modules = /*#__PURE__*/Object.freeze({
    __proto__: null,
    config: config$1
});

const fields$a = foundry.data.fields;

class CostField extends fields$a.ArrayField {
    constructor(options = {}, context = {}) {
        const element = new fields$a.SchemaField({
            key: new fields$a.StringField({
                nullable: false,
                required: true,
                initial: 'hope'
            }),
            keyIsID: new fields$a.BooleanField(),
            value: new fields$a.NumberField({ nullable: true, initial: 1, min: 0 }),
            scalable: new fields$a.BooleanField({ initial: false }),
            step: new fields$a.NumberField({ nullable: true, initial: null }),
            consumeOnSuccess: new fields$a.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.consumeOnSuccess.label'
            })
        });
        super(element, options, context);
    }

    static prepareConfig(config) {
        const costs = this.cost?.length ? foundry.utils.deepClone(this.cost) : [];
        config.costs = CostField.calcCosts.call(this, costs);
        const hasCost = CostField.hasCost.call(this, config.costs);
        if (config.isFastForward && !hasCost)
            return ui.notifications.warn("You don't have the resources to use that action.");
        return hasCost;
    }

    static calcCosts(costs) {
        const resources = CostField.getResources.call(this, costs);
        return costs.map(c => {
            c.scale = c.scale ?? 0;
            c.step = c.step ?? 1;
            c.total = c.value + c.scale * c.step;
            c.enabled = c.hasOwnProperty('enabled') ? c.enabled : true;
            c.max =
                c.key === 'fear'
                    ? game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear)
                    : resources[c.key].isReversed
                      ? resources[c.key].max
                      : resources[c.key].value;
            if (c.scalable) c.maxStep = Math.floor((c.max - c.value) / c.step);
            return c;
        });
    }

    static hasCost(costs) {
        const realCosts = CostField.getRealCosts.call(this, costs),
            hasFearCost = realCosts.findIndex(c => c.key === 'fear');

        if (hasFearCost > -1) {
            const fearCost = realCosts.splice(hasFearCost, 1)[0];
            if (
                !game.user.isGM ||
                fearCost.total > game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear)
            )
                return false;
        }

        /* isReversed is a sign that the resource is inverted, IE it counts upwards instead of down */
        const resources = CostField.getResources.call(this, realCosts);
        return realCosts.reduce(
            (a, c) =>
                !resources[c.key]
                    ? a
                    : a && resources[c.key].isReversed
                      ? resources[c.key].value + (c.total ?? c.value) <= resources[c.key].max
                      : resources[c.key]?.value >= (c.total ?? c.value),
            true
        );
    }

    static getResources(costs) {
        const actorResources = foundry.utils.deepClone(this.actor.system.resources);
        if (this.actor.system.partner)
            actorResources.hope = foundry.utils.deepClone(this.actor.system.partner.system.resources.hope);
        const itemResources = {};
        for (let itemResource of costs) {
            if (itemResource.keyIsID) {
                itemResources[itemResource.key] = {
                    value: this.parent.resource.value ?? 0,
                    max: CostField.formatMax.call(this, this.parent?.resource?.max)
                };
            }
        }

        return {
            ...actorResources,
            ...itemResources
        };
    }

    static getRealCosts(costs) {
        const realCosts = costs?.length ? costs.filter(c => c.enabled) : [];
        let mergedCosts = [];
        realCosts.forEach(c => {
            const getCost = Object.values(mergedCosts).find(gc => gc.key === c.key);
            if (getCost) getCost.total += c.total;
            else mergedCosts.push(c);
        });
        return mergedCosts;
    }

    static formatMax(max) {
        max ??= 0;
        if (isNaN(max)) {
            const roll = Roll.replaceFormulaData(max, this.getRollData());
            max = roll.total;
        }
        return Number(max);
    }
}

const fields$9 = foundry.data.fields;

class UsesField extends fields$9.SchemaField {
    constructor(options = {}, context = {}) {
        const usesFields = {
            value: new fields$9.NumberField({ nullable: true, initial: null }),
            max: new FormulaField({ nullable: true, initial: null, deterministic: true }),
            recovery: new fields$9.StringField({
                choices: CONFIG.DH.GENERAL.refreshTypes,
                initial: null,
                nullable: true
            }),
            consumeOnSuccess: new fields$9.BooleanField({
                initial: false,
                label: 'DAGGERHEART.ACTIONS.Settings.consumeOnSuccess.label'
            })
        };
        super(usesFields, options, context);
    }

    static prepareConfig(config) {
        const uses = this.uses?.max ? foundry.utils.deepClone(this.uses) : null;
        if (uses && !uses.value) uses.value = 0;
        config.uses = uses;
        const hasUses = UsesField.hasUses.call(this, config.uses);
        if (config.isFastForward && !hasUses) return ui.notifications.warn("That action doesn't have remaining uses.");
        return hasUses;
    }

    static calcUses(uses) {
        if (!uses) return null;
        return {
            ...uses,
            remaining: this.remainingUses,
            enabled: uses.hasOwnProperty('enabled') ? uses.enabled : true
        };
    }

    static hasUses(uses) {
        if (!uses) return true;
        let max = uses.max ?? 0;
        if (isNaN(max)) {
            const roll = new Roll(Roll.replaceFormulaData(uses.max, this.getRollData())).evaluateSync();
            max = roll.total;
        }
        return (uses.hasOwnProperty('enabled') && !uses.enabled) || uses.value + 1 <= max;
    }
}

const fields$8 = foundry.data.fields;

class RangeField extends fields$8.StringField {
    constructor(context = {}) {
        const options = {
            choices: CONFIG.DH.GENERAL.range,
            required: false,
            blank: true,
            label: "DAGGERHEART.GENERAL.range"
        };
        super(options, context);
    }

    static prepareConfig(config) {
        return true;
    }
}

const fields$7 = foundry.data.fields;

class TargetField extends fields$7.SchemaField {
    constructor(options = {}, context = {}) {
        const targetFields = {
            type: new fields$7.StringField({
                choices: CONFIG.DH.GENERAL.targetTypes,
                initial: CONFIG.DH.GENERAL.targetTypes.any.id,
                nullable: true
            }),
            amount: new fields$7.NumberField({ nullable: true, initial: null, integer: true, min: 0 })
        };
        super(targetFields, options, context);
    }

    static prepareConfig(config) {
        if (!this.target?.type) return [];
        config.hasTarget = true;
        let targets;
        if (this.target?.type === CONFIG.DH.GENERAL.targetTypes.self.id)
            targets = [this.actor.token ?? this.actor.prototypeToken];
        else {
            targets = Array.from(game.user.targets);
            if (this.target.type !== CONFIG.DH.GENERAL.targetTypes.any.id) {
                targets = targets.filter(t => TargetField.isTargetFriendly.call(this, t));
                if (this.target.amount && targets.length > this.target.amount) targets = [];
            }
        }
        config.targets = targets.map(t => TargetField.formatTarget.call(this, t));
        const hasTargets = TargetField.checkTargets.call(this, this.target.amount, config.targets);
        if (config.isFastForward && !hasTargets)
            return ui.notifications.warn('Too many targets selected for that actions.');
        return hasTargets;
    }

    static checkTargets(amount, targets) {
        return true;
        // return !amount || (targets.length > amount);
    }

    static isTargetFriendly(target) {
        const actorDisposition = this.actor.token
                ? this.actor.token.disposition
                : this.actor.prototypeToken.disposition,
            targetDisposition = target.document.disposition;
        return (
            (this.target.type === CONFIG.DH.GENERAL.targetTypes.friendly.id &&
                actorDisposition === targetDisposition) ||
            (this.target.type === CONFIG.DH.GENERAL.targetTypes.hostile.id &&
                actorDisposition + targetDisposition === 0)
        );
    }

    static formatTarget(actor) {
        return {
            id: actor.id,
            actorId: actor.actor.uuid,
            name: actor.actor.name,
            img: actor.actor.img,
            difficulty: actor.actor.system.difficulty,
            evasion: actor.actor.system.evasion,
            saved: {
                value: null,
                success: null
            }
        };
    }
}

const fields$6 = foundry.data.fields;

class EffectsField extends fields$6.ArrayField {
    constructor(options = {}, context = {}) {
        const element = new fields$6.SchemaField({
            _id: new fields$6.DocumentIdField(),
            onSave: new fields$6.BooleanField({ initial: false })
        });
        super(element, options, context);
    }
}

const fields$5 = foundry.data.fields;

class SaveField extends fields$5.SchemaField {
    constructor(options = {}, context = {}) {
        const saveFields = {
            trait: new fields$5.StringField({
                nullable: true,
                initial: null,
                choices: CONFIG.DH.ACTOR.abilities
            }),
            difficulty: new fields$5.NumberField({ nullable: true, initial: null, integer: true, min: 0 }),
            damageMod: new fields$5.StringField({
                initial: CONFIG.DH.ACTIONS.damageOnSave.none.id,
                choices: CONFIG.DH.ACTIONS.damageOnSave
            })
        };
        super(saveFields, options, context);
    }
}

const fields$4 = foundry.data.fields;

class BeastformField extends fields$4.SchemaField {
    constructor(options = {}, context = {}) {
        const beastformFields = {
            tierAccess: new fields$4.SchemaField({
                exact: new fields$4.NumberField({
                    integer: true,
                    nullable: true,
                    initial: null,
                    choices: () => {
                        const settingsTiers = game.settings.get(
                            CONFIG.DH.id,
                            CONFIG.DH.SETTINGS.gameSettings.LevelTiers
                        ).tiers;
                        return Object.values(settingsTiers).reduce(
                            (acc, tier) => {
                                acc[tier.tier] = game.i18n.localize(tier.name);
                                return acc;
                            },
                            { 1: game.i18n.localize('DAGGERHEART.GENERAL.Tiers.1') }
                        );
                    },
                    hint: 'DAGGERHEART.ACTIONS.Config.beastform.exactHint'
                })
            })
        };
        super(beastformFields, options, context);
    }
}

const fields$3 = foundry.data.fields;

class HealingField extends fields$3.SchemaField {
    constructor(options, context = {}) {
        const healingFields = {
            parts: new fields$3.ArrayField(new fields$3.EmbeddedDataField(DHDamageData))
        };
        super(healingFields, options, context);
    }
}

const fields$2 = foundry.data.fields;

class DHActionRollData extends foundry.abstract.DataModel {
    /** @override */
    static defineSchema() {
        return {
            type: new fields$2.StringField({ nullable: true, initial: null, choices: CONFIG.DH.GENERAL.rollTypes }),
            trait: new fields$2.StringField({ nullable: true, initial: null, choices: CONFIG.DH.ACTOR.abilities, label: "DAGGERHEART.GENERAL.Trait.single" }),
            difficulty: new fields$2.NumberField({ nullable: true, initial: null, integer: true, min: 0 }),
            bonus: new fields$2.NumberField({ nullable: true, initial: null, integer: true }),
            advState: new fields$2.StringField({
                choices: CONFIG.DH.ACTIONS.advantageState,
                initial: 'neutral'
            }),
            diceRolling: new fields$2.SchemaField({
                multiplier: new fields$2.StringField({
                    choices: CONFIG.DH.GENERAL.diceSetNumbers,
                    initial: 'prof',
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.multiplier'
                }),
                flatMultiplier: new fields$2.NumberField({
                    nullable: true,
                    initial: 1,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.flatMultiplier'
                }),
                dice: new fields$2.StringField({
                    choices: CONFIG.DH.GENERAL.diceTypes,
                    initial: CONFIG.DH.GENERAL.diceTypes.d6,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.dice'
                }),
                compare: new fields$2.StringField({
                    choices: CONFIG.DH.ACTIONS.diceCompare,
                    nullable: true,
                    initial: null,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.compare'
                }),
                treshold: new fields$2.NumberField({
                    integer: true,
                    nullable: true,
                    initial: null,
                    label: 'DAGGERHEART.ACTIONS.RollField.diceRolling.threshold'
                })
            }),
            useDefault: new fields$2.BooleanField({ initial: false })
        };
    }

    getFormula() {
        if (!this.type) return;
        let formula = '';
        switch (this.type) {
            case 'diceSet':
                const multiplier =
                    this.diceRolling.multiplier === 'flat'
                        ? this.diceRolling.flatMultiplier
                        : `@${this.diceRolling.multiplier}`;
                if (this.diceRolling.compare && this.diceRolling.treshold) {
                    formula = `${multiplier}${this.diceRolling.dice}cs${CONFIG.DH.ACTIONS.diceCompare[this.diceRolling.compare].operator}${this.diceRolling.treshold}`;
                } else {
                    formula = `${multiplier}${this.diceRolling.dice}`;
                }
                break;
            default:
                formula = '';
                break;
        }
        return formula;
    }

    getModifier() {
        const modifiers = [];
        if (!this.parent?.actor) return modifiers;
        switch (this.parent.actor.type) {
            case 'character':
                const spellcastingTrait =
                    this.type === 'spellcast'
                        ? (this.parent.actor?.system?.spellcastModifierTrait?.key ?? 'agility')
                        : null;
                const trait =
                    this.useDefault || !this.trait
                        ? (spellcastingTrait ?? this.parent.item.system.attack?.roll?.trait ?? 'agility')
                        : this.trait;
                if (
                    this.type === CONFIG.DH.GENERAL.rollTypes.attack.id ||
                    this.type === CONFIG.DH.GENERAL.rollTypes.trait.id
                )
                    modifiers.push({
                        label: `DAGGERHEART.CONFIG.Traits.${trait}.name`,
                        value: this.parent.actor.system.traits[trait].value
                    });
                else if (this.type === CONFIG.DH.GENERAL.rollTypes.spellcast.id)
                    modifiers.push({
                        label: `DAGGERHEART.CONFIG.RollTypes.spellcast.name`,
                        value: this.parent.actor.system.spellcastModifier
                    });
                break;
            case 'companion':
            case 'adversary':
                if (this.type === CONFIG.DH.GENERAL.rollTypes.attack.id)
                    modifiers.push({
                        label: 'Bonus to Hit',
                        value: this.bonus ?? this.parent.actor.system.attack.roll.bonus
                    });
                break;
        }
        return modifiers;
    }
}

class RollField extends fields$2.EmbeddedDataField {
    constructor(options, context = {}) {
        super(DHActionRollData, options, context);
    }
}

const fields$1 = foundry.data.fields;

class MacroField extends fields$1.DocumentUUIDField {
    constructor(context = {}) {
        super({ type: "Macro" }, context);
    }
}

var _module$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BeastformField: BeastformField,
    CostField: CostField,
    DamageField: DamageField,
    EffectsField: EffectsField,
    HealingField: HealingField,
    MacroField: MacroField,
    RangeField: RangeField,
    RollField: RollField,
    SaveField: SaveField,
    TargetField: TargetField,
    UsesField: UsesField
});

var fields = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActionCollection: ActionCollection,
    ActionFields: _module$1,
    ForeignDocumentUUIDArrayField: ForeignDocumentUUIDArrayField,
    ForeignDocumentUUIDField: ForeignDocumentUUIDField,
    FormulaField: FormulaField,
    MappingField: MappingField
});

class ItemLinkFields extends foundry.data.fields.ArrayField {
    constructor(options, context) {
        super(new ItemLinkField(), options, context);
    }
}

class ItemLinkField extends foundry.data.fields.SchemaField {
    constructor(context) {
        super(
            {
                type: new foundry.data.fields.StringField({ choices: CONFIG.DH.ITEM.featureSubTypes, nullable: true }),
                item: new ForeignDocumentUUIDField({ type: 'Item' })
            },
            context
        );
    }
}

class DHAncestry extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.ancestry',
            type: 'ancestry',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            features: new ItemLinkFields()
        };
    }


    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/family-tree.svg';

    /* -------------------------------------------- */

    /**
     * Gets the primary feature.
     * @type {foundry.documents.Item|null} Returns the item of the first feature with type "primary" or null if none is found.
     */
    get primaryFeature() {
        return this.features.find(x => x.type === CONFIG.DH.ITEM.featureSubTypes.primary)?.item;
    }

    /**
     * Gets the secondary feature.
     * @type {foundry.documents.Item|null} Returns the item of the first feature with type "secondary" or null if none is found.
     */
    get secondaryFeature() {
        return this.features.find(x => x.type === CONFIG.DH.ITEM.featureSubTypes.secondary)?.item;
    }
}

class AttachableItem extends BaseDataItem {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            attached: new fields.ArrayField(new fields.DocumentUUIDField({ type: 'Item', nullable: true }))
        };
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        // Handle equipped status changes for attachment effects
        if (changes.system?.equipped !== undefined && changes.system.equipped !== this.equipped) {
            await this.#handleAttachmentEffectsOnEquipChange(changes.system.equipped);
        }
    }

    async #handleAttachmentEffectsOnEquipChange(newEquippedStatus) {
        const actor = this.parent.parent?.type === 'character' ? this.parent.parent : this.parent.parent?.parent;
        const parentType = this.parent.type;

        if (!actor || !this.attached?.length) {
            return;
        }

        if (newEquippedStatus) {
            // Item is being equipped - add attachment effects
            for (const attachedUuid of this.attached) {
                const attachedItem = await fromUuid(attachedUuid);
                if (attachedItem && attachedItem.effects.size > 0) {
                    await this.#copyAttachmentEffectsToActor({
                        attachedItem,
                        attachedUuid,
                        parentType
                    });
                }
            }
        } else {
            // Item is being unequipped - remove attachment effects
            await this.#removeAllAttachmentEffects(parentType);
        }
    }

    async #copyAttachmentEffectsToActor({ attachedItem, attachedUuid, parentType }) {
        const actor = this.parent.parent;
        if (!actor || !attachedItem.effects.size > 0 || !this.equipped) {
            return [];
        }

        const effectsToCreate = [];
        for (const effect of attachedItem.effects) {
            const effectData = effect.toObject();
            effectData.origin = `${this.parent.uuid}:${attachedUuid}`;

            const attachmentSource = {
                itemUuid: attachedUuid,
                originalEffectId: effect.id
            };
            attachmentSource[`${parentType}Uuid`] = this.parent.uuid;

            effectData.flags = {
                ...effectData.flags,
                [CONFIG.DH.id]: {
                    ...effectData.flags?.[CONFIG.DH.id],
                    [CONFIG.DH.FLAGS.itemAttachmentSource]: attachmentSource
                }
            };
            effectsToCreate.push(effectData);
        }

        if (effectsToCreate.length > 0) {
            return await actor.createEmbeddedDocuments('ActiveEffect', effectsToCreate);
        }

        return [];
    }

    async #removeAllAttachmentEffects(parentType) {
        const actor = this.parent.parent;
        if (!actor) return;

        const parentUuidProperty = `${parentType}Uuid`;
        const effectsToRemove = actor.effects.filter(effect => {
            const attachmentSource = effect.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.itemAttachmentSource);
            return attachmentSource && attachmentSource[parentUuidProperty] === this.parent.uuid;
        });

        if (effectsToRemove.length > 0) {
            await actor.deleteEmbeddedDocuments(
                'ActiveEffect',
                effectsToRemove.map(e => e.id)
            );
        }
    }

    /**
     * Public method for adding an attachment
     */
    async addAttachment(droppedItem) {
        const newUUID = droppedItem.uuid;

        if (this.attached.includes(newUUID)) {
            ui.notifications.warn(`${droppedItem.name} is already attached to this ${this.parent.type}.`);
            return;
        }

        const updatedAttached = [...this.attached, newUUID];
        await this.parent.update({
            'system.attached': updatedAttached
        });

        // Copy effects if equipped
        if (this.equipped && droppedItem.effects.size > 0) {
            await this.#copyAttachmentEffectsToActor({
                attachedItem: droppedItem,
                attachedUuid: newUUID,
                parentType: this.parent.type
            });
        }
    }

    /**
     * Public method for removing an attachment
     */
    async removeAttachment(attachedUuid) {
        await this.parent.update({
            'system.attached': this.attached.filter(uuid => uuid !== attachedUuid)
        });

        // Remove effects
        await this.#removeAttachmentEffects(attachedUuid);
    }

    async #removeAttachmentEffects(attachedUuid) {
        const actor = this.parent.parent;
        if (!actor) return;

        const parentType = this.parent.type;
        const parentUuidProperty = `${parentType}Uuid`;
        const effectsToRemove = actor.effects.filter(effect => {
            const attachmentSource = effect.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.itemAttachmentSource);
            return (
                attachmentSource &&
                attachmentSource[parentUuidProperty] === this.parent.uuid &&
                attachmentSource.itemUuid === attachedUuid
            );
        });

        if (effectsToRemove.length > 0) {
            await actor.deleteEmbeddedDocuments(
                'ActiveEffect',
                effectsToRemove.map(e => e.id)
            );
        }
    }
}

class DHArmor extends AttachableItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.armor',
            type: 'armor',
            hasDescription: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({ required: true, integer: true, initial: 1, min: 1 }),
            equipped: new fields.BooleanField({ initial: false }),
            baseScore: new fields.NumberField({ integer: true, initial: 0 }),
            armorFeatures: new fields.ArrayField(
                new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.armorFeatures,
                        blank: true
                    }),
                    effectIds: new fields.ArrayField(new fields.StringField({ required: true })),
                    actionIds: new fields.ArrayField(new fields.StringField({ required: true }))
                })
            ),
            marks: new fields.SchemaField({
                value: new fields.NumberField({ initial: 0, integer: true })
            }),
            baseThresholds: new fields.SchemaField({
                major: new fields.NumberField({ integer: true, initial: 0 }),
                severe: new fields.NumberField({ integer: true, initial: 0 })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/chest-armor.svg';

    /* -------------------------------------------- */

    get customActions() {
        return this.actions.filter(
            action => !this.armorFeatures.some(feature => feature.actionIds.includes(action.id))
        );
    }

    /**@inheritdoc */
    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        if (changes.system?.armorFeatures) {
            const removed = this.armorFeatures.filter(x => !changes.system.armorFeatures.includes(x));
            const added = changes.system.armorFeatures.filter(x => !this.armorFeatures.includes(x));

            const effectIds = [];
            const actionIds = [];
            for (var feature of removed) {
                effectIds.push(...feature.effectIds);
                actionIds.push(...feature.actionIds);
            }
            await this.parent.deleteEmbeddedDocuments('ActiveEffect', effectIds);
            changes.system.actions = actionIds.reduce((acc, id) => {
                acc[`-=${id}`] = null;
                return acc;
            }, {});

            for (const feature of added) {
                const featureData = armorFeatures[feature.value];
                if (featureData.effects?.length > 0) {
                    const embeddedItems = await this.parent.createEmbeddedDocuments(
                        'ActiveEffect',
                        featureData.effects.map(effect => ({
                            ...effect,
                            name: game.i18n.localize(effect.name),
                            description: game.i18n.localize(effect.description)
                        }))
                    );
                    feature.effectIds = embeddedItems.map(x => x.id);
                }

                const newActions = {};
                if (featureData.actions?.length > 0) {
                    for (let action of featureData.actions) {
                        const embeddedEffects = await this.parent.createEmbeddedDocuments(
                            'ActiveEffect',
                            (action.effects ?? []).map(effect => ({
                                ...effect,
                                transfer: false,
                                name: game.i18n.localize(effect.name),
                                description: game.i18n.localize(effect.description)
                            }))
                        );
                        feature.effectIds = [...(feature.effectIds ?? []), ...embeddedEffects.map(x => x.id)];

                        const cls = game.system.api.models.actions.actionsTypes[action.type];
                        const actionId = foundry.utils.randomID();
                        newActions[actionId] = new cls(
                            {
                                ...cls.getSourceConfig(this),
                                ...action,
                                _id: actionId,
                                name: game.i18n.localize(action.name),
                                description: game.i18n.localize(action.description),
                                effects: embeddedEffects.map(x => ({ _id: x.id }))
                            },
                            { parent: this }
                        );
                    }
                }

                changes.system.actions = newActions;
                feature.actionIds = Object.keys(newActions);
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            `${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseScore')}: ${this.baseScore}`,
            `${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseThresholds.base')}: ${this.baseThresholds.major} / ${this.baseThresholds.severe}`
        ];

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        if(this.baseScore) labels.push(`${game.i18n.localize('DAGGERHEART.ITEMS.Armor.baseScore')}: ${this.baseScore}`);
        return labels;
    }

    get itemFeatures() {
        return this.armorFeatures;
    }
}

class DHClass extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.class',
            type: 'class',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            domains: new fields.ArrayField(new fields.StringField()),
            classItems: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
            hitPoints: new fields.NumberField({
                required: true,
                integer: true,
                min: 1,
                initial: 5,
                label: 'DAGGERHEART.GENERAL.HitPoints.plural'
            }),
            evasion: new fields.NumberField({ initial: 0, integer: true, label: 'DAGGERHEART.GENERAL.evasion' }),
            features: new ItemLinkFields(),
            subclasses: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
            inventory: new fields.SchemaField({
                take: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
                choiceA: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false }),
                choiceB: new ForeignDocumentUUIDArrayField({ type: 'Item', required: false })
            }),
            characterGuide: new fields.SchemaField({
                suggestedTraits: new fields.SchemaField({
                    agility: new fields.NumberField({ initial: 0, integer: true }),
                    strength: new fields.NumberField({ initial: 0, integer: true }),
                    finesse: new fields.NumberField({ initial: 0, integer: true }),
                    instinct: new fields.NumberField({ initial: 0, integer: true }),
                    presence: new fields.NumberField({ initial: 0, integer: true }),
                    knowledge: new fields.NumberField({ initial: 0, integer: true })
                }),
                suggestedPrimaryWeapon: new ForeignDocumentUUIDField({ type: 'Item' }),
                suggestedSecondaryWeapon: new ForeignDocumentUUIDField({ type: 'Item' }),
                suggestedArmor: new ForeignDocumentUUIDField({ type: 'Item' })
            }),
            isMulticlass: new fields.BooleanField({ initial: false })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/laurel-crown.svg';

    /* -------------------------------------------- */

    get hopeFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.hope).map(x => x.item);
    }

    get classFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.class).map(x => x.item);
    }

    async _preCreate(data, options, user) {
        if (this.actor?.type === 'character') {
            const levelupAuto = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).levelupAuto;
            if (levelupAuto) {
                const path = data.system.isMulticlass ? 'system.multiclass.value' : 'system.class.value';
                if (foundry.utils.getProperty(this.actor, path)) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.classAlreadySelected'));
                    return false;
                }
            } else {
                if (this.actor.system.class.value) {
                    if (this.actor.system.multiclass.value) {
                        ui.notifications.warn(
                            game.i18n.localize('DAGGERHEART.UI.Notifications.multiclassAlreadyPresent')
                        );
                        return false;
                    } else {
                        const selectedDomain =
                            await game.system.api.applications.dialogs.MulticlassChoiceDialog.configure(
                                this.actor,
                                this
                            );
                        if (!selectedDomain) return false;

                        await this.updateSource({ isMulticlass: true, domains: [selectedDomain] });
                    }
                }
            }
        }

        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;
    }

    _onDelete(options, userId) {
        super._onDelete(options, userId);

        if (options.parent?.type === 'character') {
            const path = `system.${this.isMulticlass ? 'multiclass' : 'class'}`;
            foundry.utils.getProperty(options.parent, `${path}.subclass`)?.delete();
        }
    }

    async _preUpdate(changed, options, userId) {
        const allowed = await super._preUpdate(changed, options, userId);
        if (allowed === false) return false;

        if (changed.system?.domains) {
            const maxDomains = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).maxDomains;
            if (changed.system.domains.length > maxDomains) {
                ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.domainMaxReached'));
                return false;
            }
        }

        const paths = [
            'subclasses',
            'characterGuide.suggestedPrimaryWeapon',
            'characterGuide.suggestedSecondaryWeapon',
            'characterGuide.suggestedArmor',
            'inventory.take',
            'inventory.choiceA',
            'inventory.choiceB'
        ];

        for (let path of paths) {
            const currentItems = [].concat(foundry.utils.getProperty(this, path) ?? []);
            const changedItems = [].concat(foundry.utils.getProperty(changed, `system.${path}`) ?? []);
            if (!changedItems.length) continue;

            addLinkedItemsDiff(changedItems, currentItems, options);
        }
    }

    _onUpdate(changed, options, userId) {
        super._onUpdate(changed, options, userId);

        updateLinkedItemApps(options, this.parent.sheet);
    }
}

class DHCommunity extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.community',
            type: 'community',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema(),
            features: new ForeignDocumentUUIDArrayField({ type: 'Item' })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/village.svg';

}

class DHConsumable extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.consumable',
            type: 'consumable',
            hasDescription: true,
            isQuantifiable: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            consumeOnUse: new fields.BooleanField({ initial: false })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/round-potion.svg';

}

class DHDomainCard extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.domainCard',
            type: 'domainCard',
            hasDescription: true,
            hasResource: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            domain: new fields.StringField({
                choices: CONFIG.DH.DOMAIN.allDomains,
                required: true,
                initial: CONFIG.DH.DOMAIN.domains.arcana.id
            }),
            level: new fields.NumberField({ initial: 1, integer: true }),
            recallCost: new fields.NumberField({ initial: 0, integer: true }),
            type: new fields.StringField({
                choices: CONFIG.DH.DOMAIN.cardTypes,
                required: true,
                initial: CONFIG.DH.DOMAIN.cardTypes.ability.id
            }),
            inVault: new fields.BooleanField({ initial: false })
        };
    }

    get domainLabel() {
        const allDomainData = CONFIG.DH.DOMAIN.allDomains();
        return game.i18n.localize(allDomainData[this.domain].label);
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/card-play.svg';

    /* -------------------------------------------- */

    /**@inheritdoc */
    async _preCreate(data, options, user) {
        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;

        if (this.actor?.type === 'character') {
            const actorClasses = this.actor.items.filter(x => x.type === 'class');
            if (!actorClasses.length) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.noClassSelected'));
                return false;
            }

            if (!actorClasses.some(c => c.system.domains.find(x => x === this.domain))) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.lacksDomain'));
                return false;
            }

            if (this.actor.system.domainCards.total.find(x => x.name === this.parent.name)) {
                ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.duplicateDomainCard'));
                return false;
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            game.i18n.localize(`DAGGERHEART.CONFIG.DomainCardTypes.${this.type}`),
            this.domainLabel,
            `${game.i18n.localize('DAGGERHEART.GENERAL.levelShort')}: ${this.level}`,
            `${game.i18n.localize('DAGGERHEART.ITEMS.DomainCard.recallCost')}: ${this.recallCost}`
        ];

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];

        if (this.type) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.DomainCardTypes.${this.type}`));
        if (this.domainLabel) labels.push(this.domainLabel);
        if (this.recallCost) {
            labels.push({
                value: `${this.recallCost}`, //converts the number to a string
                icons: ['fa-bolt']
            });
        }
        return labels;
    }
}

class DHLoot extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.loot',
            type: 'loot',
            hasDescription: true,
            isQuantifiable: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        return {
            ...super.defineSchema()
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/open-treasure-chest.svg';

    /* -------------------------------------------- */
}

class DHSubclass extends BaseDataItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.subclass',
            type: 'subclass',
            hasDescription: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            spellcastingTrait: new fields.StringField({
                choices: CONFIG.DH.ACTOR.abilities,
                integer: false,
                nullable: true,
                initial: null,
                label: 'DAGGERHEART.ITEMS.Subclass.spellcastingTrait'
            }),
            features: new ItemLinkFields(),
            featureState: new fields.NumberField({ required: true, initial: 1, min: 1 }),
            isMulticlass: new fields.BooleanField({ initial: false }),
            linkedClass: new ForeignDocumentUUIDField({ type: 'Item', nullable: true, initial: null })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/laurels.svg';

    /* -------------------------------------------- */

    get foundationFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.foundation).map(x => x.item);
    }

    get specializationFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.specialization).map(x => x.item);
    }

    get masteryFeatures() {
        return this.features.filter(x => x.type === CONFIG.DH.ITEM.featureSubTypes.mastery).map(x => x.item);
    }

    async _preCreate(data, options, user) {
        if (this.actor?.type === 'character') {
            const dataUuid = data.uuid ?? data._stats.compendiumSource ?? `Item.${data._id}`;
            if (this.actor.system.class.subclass) {
                if (this.actor.system.multiclass.subclass) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassesAlreadyPresent'));
                    return false;
                } else {
                    const multiclass = this.actor.items.find(x => x.type === 'class' && x.system.isMulticlass);
                    if (!multiclass) {
                        ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.missingMulticlass'));
                        return false;
                    }

                    if (multiclass.system.subclasses.every(x => x.uuid !== dataUuid)) {
                        ui.notifications.error(
                            game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInMulticlass')
                        );
                        return false;
                    }

                    await this.updateSource({ isMulticlass: true });
                }
            } else {
                const actorClass = this.actor.items.find(x => x.type === 'class' && !x.system.isMulticlass);
                if (!actorClass) {
                    ui.notifications.warn(game.i18n.localize('DAGGERHEART.UI.Notifications.missingClass'));
                    return false;
                }
                if (actorClass.system.subclasses.every(x => x.uuid !== dataUuid)) {
                    ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.subclassNotInClass'));
                    return false;
                }
            }
        }

        const allowed = await super._preCreate(data, options, user);
        if (allowed === false) return;
    }
}

class DHWeapon extends AttachableItem {
    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.weapon',
            type: 'weapon',
            hasDescription: true,
            isInventoryItem: true,
            hasActions: true
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                initial: 1,
                min: 1,
                label: 'DAGGERHEART.GENERAL.Tiers.singular'
            }),
            equipped: new fields.BooleanField({ initial: false }),

            //SETTINGS
            secondary: new fields.BooleanField({ initial: false, label: 'DAGGERHEART.ITEMS.Weapon.secondaryWeapon' }),
            burden: new fields.StringField({
                required: true,
                choices: CONFIG.DH.GENERAL.burden,
                initial: 'oneHanded',
                label: 'DAGGERHEART.GENERAL.burden'
            }),
            weaponFeatures: new fields.ArrayField(
                new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.ITEM.weaponFeatures,
                        blank: true
                    }),
                    effectIds: new fields.ArrayField(new fields.StringField({ required: true })),
                    actionIds: new fields.ArrayField(new fields.StringField({ required: true }))
                })
            ),
            attack: new ActionField({
                initial: {
                    name: 'Attack',
                    img: 'icons/skills/melee/blood-slash-foam-red.webp',
                    _id: foundry.utils.randomID(),
                    systemPath: 'attack',
                    type: 'attack',
                    range: 'melee',
                    target: {
                        type: 'any',
                        amount: 1
                    },
                    roll: {
                        trait: 'agility',
                        type: 'attack'
                    },
                    damage: {
                        parts: [
                            {
                                type: ['physical'],
                                value: {
                                    multiplier: 'prof',
                                    dice: 'd8'
                                }
                            }
                        ]
                    }
                }
            }),
            rules: new fields.SchemaField({
                attack: new fields.SchemaField({
                    roll: new fields.SchemaField({
                        trait: new fields.StringField({
                            required: true,
                            choices: CONFIG.DH.ACTOR.abilities,
                            nullable: true,
                            initial: null,
                            label: 'DAGGERHEART.GENERAL.Rules.attack.roll.trait.label'
                        })
                    })
                })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/battered-axe.svg';

    /* -------------------------------------------- */

    get actionsList() {
        return [this.attack, ...this.actions];
    }

    get customActions() {
        return this.actions.filter(
            action => !this.weaponFeatures.some(feature => feature.actionIds.includes(action.id))
        );
    }

    prepareDerivedData() {
        this.attack.roll.trait = this.rules.attack.roll.trait ?? this.attack.roll.trait;
    }

    async _preUpdate(changes, options, user) {
        const allowed = await super._preUpdate(changes, options, user);
        if (allowed === false) return false;

        if (changes.system?.weaponFeatures) {
            const removed = this.weaponFeatures.filter(x => !changes.system.weaponFeatures.includes(x));
            const added = changes.system.weaponFeatures.filter(x => !this.weaponFeatures.includes(x));

            const removedEffectsUpdate = [];
            const removedActionsUpdate = [];
            for (let weaponFeature of removed) {
                removedEffectsUpdate.push(...weaponFeature.effectIds);
                removedActionsUpdate.push(...weaponFeature.actionIds);
            }

            await this.parent.deleteEmbeddedDocuments('ActiveEffect', removedEffectsUpdate);
            changes.system.actions = removedActionsUpdate.reduce((acc, id) => {
                acc[`-=${id}`] = null;
                return acc;
            }, {});

            for (let weaponFeature of added) {
                const featureData = CONFIG.DH.ITEM.weaponFeatures[weaponFeature.value];
                if (featureData.effects?.length > 0) {
                    const embeddedItems = await this.parent.createEmbeddedDocuments(
                        'ActiveEffect',
                        featureData.effects.map(effect => ({
                            ...effect,
                            name: game.i18n.localize(effect.name),
                            description: game.i18n.localize(effect.description)
                        }))
                    );
                    weaponFeature.effectIds = embeddedItems.map(x => x.id);
                }

                const newActions = {};
                if (featureData.actions?.length > 0) {
                    for (let action of featureData.actions) {
                        const embeddedEffects = await this.parent.createEmbeddedDocuments(
                            'ActiveEffect',
                            (action.effects ?? []).map(effect => ({
                                ...effect,
                                transfer: false,
                                name: game.i18n.localize(effect.name),
                                description: game.i18n.localize(effect.description)
                            }))
                        );
                        weaponFeature.effectIds = [
                            ...(weaponFeature.effectIds ?? []),
                            ...embeddedEffects.map(x => x.id)
                        ];

                        const cls = game.system.api.models.actions.actionsTypes[action.type];
                        const actionId = foundry.utils.randomID();
                        newActions[actionId] = new cls(
                            {
                                ...cls.getSourceConfig(this),
                                ...action,
                                _id: actionId,
                                name: game.i18n.localize(action.name),
                                description: game.i18n.localize(action.description),
                                effects: embeddedEffects.map(x => ({ _id: x.id }))
                            },
                            { parent: this }
                        );
                    }
                }

                changes.system.actions = newActions;
                weaponFeature.actionIds = Object.keys(newActions);
            }
        }
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const { attack, burden } = this;
        const tags = [
            game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${attack.roll.trait}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.Range.${attack.range}.name`),
            game.i18n.localize(`DAGGERHEART.CONFIG.Burden.${burden}`)
        ];

        for (const { value, type } of attack.damage.parts) {
            const parts = [value.dice];
            if (value.bonus) parts.push(value.bonus.signedString());

            if (type.size > 0) {
                const typeTags = Array.from(type)
                    .map(t => game.i18n.localize(`DAGGERHEART.CONFIG.DamageType.${t}.abbreviation`))
                    .join(' | ');
                parts.push(` (${typeTags})`); // Add a space in front and put it inside a ().
            }

            tags.push(parts.join(''));
        }

        return tags;
    }

    /**
     * Generate a localized label array for this item subtype.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        const { roll, range, damage } = this.attack;

        if (roll.trait) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Traits.${roll.trait}.short`));
        if (range) labels.push(game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.short`));

        for (const { value, type } of damage.parts) {
            const str = Roll.replaceFormulaData(value.getFormula(), this.actor?.getRollData() ?? {});

            const icons = Array.from(type)
                .map(t => CONFIG.DH.GENERAL.damageTypes[t]?.icon)
                .filter(Boolean);

            if (icons.length === 0) {
                labels.push(str);
            } else {
                labels.push({ value: str, icons });
            }
        }

        return labels;
    }

    get itemFeatures() {
        return this.weaponFeatures;
    }
}

class DHBeastform extends BaseDataItem {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.ITEMS.Beastform'];

    /** @inheritDoc */
    static get metadata() {
        return foundry.utils.mergeObject(super.metadata, {
            label: 'TYPES.Item.beastform',
            type: 'beastform',
            hasDescription: false
        });
    }

    /** @inheritDoc */
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            ...super.defineSchema(),
            beastformType: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ITEM.beastformTypes,
                initial: CONFIG.DH.ITEM.beastformTypes.normal.id
            }),
            tier: new fields.NumberField({
                required: true,
                integer: true,
                choices: CONFIG.DH.GENERAL.tiers,
                initial: CONFIG.DH.GENERAL.tiers[1].id
            }),
            tokenImg: new fields.FilePathField({
                initial: 'icons/svg/mystery-man.svg',
                categories: ['IMAGE'],
                base64: false
            }),
            tokenRingImg: new fields.FilePathField({
                initial: 'icons/svg/mystery-man.svg',
                categories: ['IMAGE'],
                base64: false
            }),
            tokenSize: new fields.SchemaField({
                height: new fields.NumberField({ integer: true, min: 1, initial: null, nullable: true }),
                width: new fields.NumberField({ integer: true, min: 1, initial: null, nullable: true })
            }),
            mainTrait: new fields.StringField({
                required: true,
                choices: CONFIG.DH.ACTOR.abilities,
                initial: CONFIG.DH.ACTOR.abilities.agility.id
            }),
            examples: new fields.StringField(),
            advantageOn: new fields.TypedObjectField(
                new fields.SchemaField({
                    value: new fields.StringField()
                })
            ),
            features: new ForeignDocumentUUIDArrayField({ type: 'Item' }),
            evolved: new fields.SchemaField({
                maximumTier: new fields.NumberField({
                    integer: true,
                    choices: CONFIG.DH.GENERAL.tiers
                }),
                mainTraitBonus: new fields.NumberField({
                    required: true,
                    integer: true,
                    min: 0,
                    initial: 0
                })
            }),
            hybrid: new fields.SchemaField({
                maximumTier: new fields.NumberField({
                    integer: true,
                    choices: CONFIG.DH.GENERAL.tiers,
                    label: 'DAGGERHEART.ITEMS.Beastform.FIELDS.evolved.maximumTier.label'
                }),
                beastformOptions: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 }),
                advantages: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 }),
                features: new fields.NumberField({ required: true, integer: true, initial: 2, min: 2 })
            })
        };
    }

    /* -------------------------------------------- */

    /**@override */
    static DEFAULT_ICON = 'systems/daggerheart/assets/icons/documents/items/wolf-head.svg';

    /* -------------------------------------------- */

    get beastformAttackData() {
        const effect = this.parent.effects.find(x => x.type === 'beastform');
        if (!effect) return null;

        const traitBonus = effect.changes.find(x => x.key === `system.traits.${this.mainTrait}.value`)?.value ?? 0;
        const evasionBonus = effect.changes.find(x => x.key === 'system.evasion')?.value ?? 0;

        const damageDiceIndex = effect.changes.find(x => x.key === 'system.rules.attack.damage.diceIndex');
        const damageDice = damageDiceIndex ? Object.keys(CONFIG.DH.GENERAL.diceTypes)[damageDiceIndex.value] : null;
        const damageBonus = effect.changes.find(x => x.key === 'system.rules.attack.damage.bonus')?.value ?? 0;

        return {
            trait: game.i18n.localize(CONFIG.DH.ACTOR.abilities[this.mainTrait].label),
            traitBonus: traitBonus ? Number(traitBonus).signedString() : '',
            evasionBonus: evasionBonus ? Number(evasionBonus).signedString() : '',
            damageDice: damageDice,
            damageBonus: damageBonus ? `${Number(damageBonus).signedString()}` : ''
        };
    }

    async _preCreate() {
        if (!this.actor) return;

        if (this.actor.type !== 'character') {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformInapplicable'));
            return false;
        }

        if (this.actor.items.find(x => x.type === 'beastform')) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.beastformAlreadyApplied'));
            return false;
        }

        const beastformFeatures = [];
        for (let featureData of this.features) {
            const feature = await foundry.utils.fromUuid(featureData.uuid);
            beastformFeatures.push(feature.toObject());
        }

        const features = await this.parent.parent.createEmbeddedDocuments('Item', beastformFeatures);

        const extraEffects = await this.parent.parent.createEmbeddedDocuments(
            'ActiveEffect',
            this.parent.effects.filter(x => x.type !== 'beastform').map(x => x.toObject())
        );

        const tokenImages = await this.parent.parent.getTokenImages();
        const beastformEffect = this.parent.effects.find(x => x.type === 'beastform');
        await beastformEffect.updateSource({
            changes: [
                ...beastformEffect.changes,
                {
                    key: 'system.advantageSources',
                    mode: 2,
                    value: Object.values(this.advantageOn)
                        .map(x => x.value)
                        .join(', ')
                }
            ],
            system: {
                characterTokenData: {
                    tokenImg: tokenImages[0],
                    tokenRingImg: this.parent.parent.prototypeToken.ring.subject.texture,
                    tokenSize: {
                        height: this.parent.parent.prototypeToken.height,
                        width: this.parent.parent.prototypeToken.width
                    }
                },
                advantageOn: this.advantageOn,
                featureIds: features.map(x => x.id),
                effectIds: extraEffects.map(x => x.id)
            }
        });

        await this.parent.parent.createEmbeddedDocuments('ActiveEffect', [beastformEffect.toObject()]);

        await updateActorTokens(this.parent.parent, {
            height: this.tokenSize.height,
            width: this.tokenSize.width,
            texture: {
                src: this.tokenImg
            },
            ring: {
                subject: {
                    texture: this.tokenRingImg
                }
            }
        });

        return false;
    }

    _onCreate(_data, _options, userId) {
        if (userId !== game.user.id) return;

        if (!this.parent.effects.find(x => x.type === 'beastform')) {
            this.parent.createEmbeddedDocuments('ActiveEffect', [
                {
                    type: 'beastform',
                    name: game.i18n.localize('DAGGERHEART.ITEMS.Beastform.beastformEffect'),
                    img: 'icons/creatures/abilities/paw-print-pair-purple.webp'
                }
            ]);
        }
    }
}

const config = {
    ancestry: DHAncestry,
    armor: DHArmor,
    attachableItem: AttachableItem,
    class: DHClass,
    community: DHCommunity,
    consumable: DHConsumable,
    domainCard: DHDomainCard,
    feature: DHFeature,
    loot: DHLoot,
    subclass: DHSubclass,
    weapon: DHWeapon,
    beastform: DHBeastform
};

var _module = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHAncestry: DHAncestry,
    DHArmor: DHArmor,
    DHAttachableItem: AttachableItem,
    DHBeastform: DHBeastform,
    DHClass: DHClass,
    DHCommunity: DHCommunity,
    DHConsumable: DHConsumable,
    DHDomainCard: DHDomainCard,
    DHFeature: DHFeature,
    DHLoot: DHLoot,
    DHSubclass: DHSubclass,
    DHWeapon: DHWeapon,
    config: config
});

var models = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DhCombat: DhCombat,
    DhCombatant: DhCombatant,
    actions: _module$7,
    activeEffects: _module$3,
    actors: _module$2,
    chatMessages: _modules,
    fields: fields,
    items: _module
});

/**
 * Override and extend the basic Item implementation.
 * @extends {foundry.documents.Item}
 */
class DHItem extends foundry.documents.Item {
    /** @inheritDoc */
    prepareEmbeddedDocuments() {
        super.prepareEmbeddedDocuments();
        for (const action of this.system.actions ?? []) action.prepareData();
    }

    /** @inheritDoc */
    getEmbeddedDocument(embeddedName, id, options) {
        let doc;
        switch (embeddedName) {
            case 'Action':
                doc = this.system.actions?.get(id);
                if (!doc && this.system.attack?.id === id) doc = this.system.attack;
                break;
            default:
                return super.getEmbeddedDocument(embeddedName, id, options);
        }
        if (options?.strict && !doc) {
            throw new Error(`The key ${id} does not exist in the ${embeddedName} Collection`);
        }
        return doc;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    static migrateData(source) {
        if(source.system?.attack && !source.system.attack.type) source.system.attack.type = "attack";
        return super.migrateData(source);
    }

    /**
     * @inheritdoc
     * @param {object} options - Options which modify the getRollData method.
     * @returns
     */
    getRollData(options = {}) {
        let data;
        if (this.system.getRollData) data = this.system.getRollData(options);
        else {
            const actorRollData = this.actor?.getRollData(options) ?? {};
            data = { ...actorRollData, item: { ...this.system } };
        }

        if (data?.item) {
            data.item.flags = { ...this.flags };
            data.item.name = this.name;
        }
        return data;
    }

    /**
     * Determine if this item is classified as an inventory item based on its metadata.
     * @returns {boolean} Returns `true` if the item is an inventory item.
     */
    get isInventoryItem() {
        return this.system.metadata.isInventoryItem ?? false;
    }

    /** @inheritdoc */
    static async createDialog(data = {}, createOptions = {}, options = {}) {
        const { folders, types, template, context = {}, ...dialogOptions } = options;

        if (types?.length === 0) {
            throw new Error('The array of sub-types to restrict to must not be empty.');
        }

        const documentTypes = this.TYPES.filter(type => type !== 'base' && (!types || types.includes(type))).map(
            type => {
                const labelKey = CONFIG.Item?.typeLabels?.[type];
                const label = labelKey && game.i18n.has(labelKey) ? game.i18n.localize(labelKey) : type;

                const isInventoryItem = CONFIG.Item.dataModels[type]?.metadata?.isInventoryItem;
                const group =
                    isInventoryItem === true
                        ? 'Inventory Items' //TODO localize
                        : isInventoryItem === false
                          ? 'Character Items' //TODO localize
                          : 'Other'; //TODO localize

                return { value: type, label, group };
            }
        );

        if (!documentTypes.length) {
            throw new Error('No document types were permitted to be created.'); //TODO localize
        }

        const sortedTypes = documentTypes.sort((a, b) => a.label.localeCompare(b.label, game.i18n.lang));

        return await super.createDialog(data, createOptions, {
            folders,
            types,
            template,
            context: { types: sortedTypes, ...context },
            ...dialogOptions
        });
    }

    /* -------------------------------------------- */

    /**
     * Generate an array of localized tag.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [];
        if (this.system._getTags) tags.push(...this.system._getTags());
        return tags;
    }

    /**
     * Generate a localized label array for this item.
     * @returns {(string | { value: string, icons: string[] })[]} An array of localized strings and damage label objects.
     */
    _getLabels() {
        const labels = [];
        if (this.system._getLabels) labels.push(...this.system._getLabels());
        return labels;
    }

    /* -------------------------------------------- */

    /**@inheritdoc */
    static getDefaultArtwork(itemData) {
        const { type } = itemData;
        const Model = CONFIG.Item.dataModels[type];
        const img = Model.DEFAULT_ICON ?? this.DEFAULT_ICON;
        return { img };
    }

    /* -------------------------------------------- */

    async use(event) {
        const actions = new Set(this.system.actionsList);
        if (actions?.size) {
            let action = actions.first();
            if (actions.size > 1 && !event?.shiftKey) {
                // Actions Choice Dialog
                action = await ActionSelectionDialog.create(this, event);
            }
            if (action) return action.use(event);
        }
    }

    /**
     * Create a new ChatMessage to display this documents data
     * @param {String} origin - uuid of a document. TODO: This needs to be reviewed.
     */
    async toChat(origin) {
        /**@type {foundry.documents.ChatMessage} */
        const cls = getDocumentClass('ChatMessage');
        const item = await foundry.utils.fromUuid(origin);

        const systemData = {
            origin: origin,
            img: this.img,
            item: {
                name: this.name,
                img: this.img,
                tags: this._getTags()
            },
            actions: item.system.actionsList,
            description: this.system.description
        };

        const msg = {
            type: 'abilityUse',
            user: game.user.id,
            actor: item.parent,
            speaker: cls.getSpeaker(),
            system: systemData,
            title: game.i18n.localize('DAGGERHEART.ACTIONS.Config.displayInChat'),
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/ability-use.hbs',
                systemData
            ),
            flags: {
                daggerheart: {
                    cssClass: 'dh-chat-message dh-style'
                }
            }
        };

        cls.create(msg);
    }
}

class DhpCombat extends Combat {
    async startCombat() {
        this._playCombatSound('startEncounter');
        const updateData = { round: 1, turn: null };
        Hooks.callAll('combatStart', this, updateData);
        await this.update(updateData);
        return this;
    }

    _sortCombatants(a, b) {
        const aNPC = Number(a.isNPC);
        const bNPC = Number(b.isNPC);
        if (aNPC !== bNPC) {
            return aNPC - bNPC;
        }

        return a.name.localeCompare(b.name);
    }
}

class DhActiveEffect extends foundry.documents.ActiveEffect {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**@override */
    get isSuppressed() {
        // If this is a copied effect from an attachment, never suppress it
        // (These effects have attachmentSource metadata)
        if (this.flags?.daggerheart?.attachmentSource) {
            return false;
        }

        // Then apply the standard suppression rules
        if (['weapon', 'armor'].includes(this.parent?.type)) {
            return !this.parent.system.equipped;
        }

        if (this.parent?.type === 'domainCard') {
            return this.parent.system.inVault;
        }

        return super.isSuppressed;
    }

    /**
     * Check if the parent item is currently attached to another item
     * @returns {boolean}
     */
    get isAttached() {
        if (!this.parent || !this.parent.parent) return false;

        // Check if this item's UUID is in any actor's armor or weapon attachment lists
        const actor = this.parent.parent;
        if (!actor || !actor.items) return false;

        return actor.items.some(item => {
            return (
                (item.type === 'armor' || item.type === 'weapon') &&
                item.system?.attached &&
                Array.isArray(item.system.attached) &&
                item.system.attached.includes(this.parent.uuid)
            );
        });
    }

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    /**@inheritdoc*/
    async _preCreate(data, options, user) {
        const update = {};
        if (!data.img) {
            update.img = 'icons/magic/life/heart-cross-blue.webp';
        }

        if (Object.keys(update).length > 0) {
            await this.updateSource(update);
        }

        await super._preCreate(data, options, user);
    }

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**@inheritdoc*/
    static applyField(model, change, field) {
        const isOriginTarget = change.value.toLowerCase().includes('origin.@');
        let parseModel = model;
        if (isOriginTarget && change.effect.origin) {
            change.value = change.value.replaceAll(/origin\.@/gi, '@');
            try {
                const effect = foundry.utils.fromUuidSync(change.effect.origin);
                const doc = effect.parent?.parent;
                if (doc) parseModel = doc;
            } catch (_) {}
        }

        const evalValue = this.effectSafeEval(itemAbleRollParse(change.value, parseModel, change.effect.parent));
        change.value = evalValue ?? change.value;
        super.applyField(model, change, field);
    }

    /**
     * Altered Foundry safeEval to allow non-numeric return
     * @param {string} expression
     * @returns
     */
    static effectSafeEval(expression) {
        let result;
        try {
            // eslint-disable-next-line no-new-func
            const evl = new Function('sandbox', `with (sandbox) { return ${expression}}`);
            result = evl(Roll.MATH_PROXY);
        } catch (err) {
            return expression;
        }

        return result;
    }

    /**
     * Generates a list of localized tags based on this item's type-specific properties.
     * @returns {string[]} An array of localized tag strings.
     */
    _getTags() {
        const tags = [
            `${game.i18n.localize(this.parent.system.metadata.label)}: ${this.parent.name}`,
            game.i18n.localize(
                this.isTemporary ? 'DAGGERHEART.EFFECTS.Duration.temporary' : 'DAGGERHEART.EFFECTS.Duration.passive'
            )
        ];

        for (const statusId of this.statuses) {
            const status = CONFIG.statusEffects.find(s => s.id === statusId);
            if (status) tags.push(game.i18n.localize(status.name));
        }

        return tags;
    }

    /**
     * Create a new ChatMessage to display this documents data.
     * @param {String} origin -  uuid of a document. TODO: This needs to be reviewed.
     */
    async toChat(origin) {
        /**@type {foundry.documents.ChatMessage} */
        const cls = getDocumentClass('ChatMessage');
        const speaker = cls.getSpeaker();
        const actor = cls.getSpeakerActor(speaker);
        const systemData = {
            action: { img: this.img, name: this.name },
            actor: { name: actor?.name, img: actor?.img },
            speaker,
            origin,
            description: this.description,
            actions: []
        };
        const msg = {
            title: game.i18n.localize('DAGGERHEART.GENERAL.Effect.single'),
            user: game.user.id,
            system: systemData,
            content: await foundry.applications.handlebars.renderTemplate(
                'systems/daggerheart/templates/ui/chat/action.hbs',
                systemData
            )
        };

        cls.create(msg);
    }

    prepareDerivedData() {
        /* Preventing subclass features from transferring to actor if they do not have the right subclass advancement */
        if (this.parent?.type === 'feature') {
            const origSubclassParent = this.parent.system.originItemType === 'subclass';
            if (origSubclassParent) {
                const subclass = this.parent.parent.items.find(
                    x =>
                        x.type === 'subclass' &&
                        x.system.isMulticlass === (this.parent.system.identifier === 'multiclass')
                );

                if (subclass) {
                    const featureState = subclass.system.featureState;

                    if (
                        (this.parent.system.identifier === CONFIG.DH.ITEM.featureSubTypes.specialization &&
                            featureState < 2) ||
                        (this.parent.system.identifier === CONFIG.DH.ITEM.featureSubTypes.mastery && featureState < 3)
                    ) {
                        this.transfer = false;
                    }
                }
            }
        }
    }
}

class DhpChatMessage extends foundry.documents.ChatMessage {
    targetHook = null;

    async renderHTML() {
        const actor = game.actors.get(this.speaker.actor);
        const actorData =
            actor && this.isContentVisible
                ? actor
                : {
                      img: this.author.avatar ? this.author.avatar : 'icons/svg/mystery-man.svg',
                      name: ''
                  };
        /* We can change to fully implementing the renderHTML function if needed, instead of augmenting it. */
        const html = await super.renderHTML({ actor: actorData, author: this.author });

        if (this.flags.core?.RollTable) {
            html.querySelector('.roll-buttons.apply-buttons').remove();
        }

        this.enrichChatMessage(html);
        this.addChatListeners(html);

        return html;
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    prepareData() {
        if (this.isAuthor && this.targetSelection === undefined) this.targetSelection = this.system.targets?.length > 0;
        super.prepareData();
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    _onCreate(data, options, userId) {
        super._onCreate(data, options, userId);
        if (this.system.registerTargetHook) this.system.registerTargetHook();
    }

    /* -------------------------------------------- */

    /** @inheritDoc */
    async _preDelete(options, user) {
        if (this.targetHook !== null) Hooks.off('targetToken', this.targetHook);
        return super._preDelete(options, user);
    }

    enrichChatMessage(html) {
        const elements = html.querySelectorAll('[data-perm-id]');
        elements.forEach(e => {
            const uuid = e.dataset.permId,
                document = fromUuidSync(uuid);
            if (!document) return;

            e.setAttribute('data-view-perm', document.testUserPermission(game.user, 'OBSERVER'));
            e.setAttribute('data-use-perm', document.testUserPermission(game.user, 'OWNER'));
        });

        if (this.isContentVisible) {
            if (this.type === 'dualityRoll') {
                html.classList.add('duality');
                switch (this.system.roll?.result?.duality) {
                    case 1:
                        html.classList.add('hope');
                        break;
                    case -1:
                        html.classList.add('fear');
                        break;
                    default:
                        html.classList.add('critical');
                        break;
                }
            }
        }

        if (!game.user.isGM) {
            const applyButtons = html.querySelector('.apply-buttons');
            applyButtons?.remove();
            if (!this.isAuthor && !this.speakerActor?.isOwner) {
                const buttons = html.querySelectorAll('.ability-card-footer > .ability-use-button');
                buttons.forEach(b => b.remove());
            }
        }
    }

    addChatListeners(html) {
        html.querySelectorAll('.damage-button').forEach(element =>
            element.addEventListener('click', this.onDamage.bind(this))
        );

        html.querySelectorAll('.duality-action-effect').forEach(element =>
            element.addEventListener('click', this.onApplyEffect.bind(this))
        );

        html.querySelectorAll('.roll-target').forEach(element => {
            element.addEventListener('mouseenter', this.hoverTarget);
            element.addEventListener('mouseleave', this.unhoverTarget);
            element.addEventListener('click', this.clickTarget);
        });

        html.querySelectorAll('.button-target-selection').forEach(element => {
            element.addEventListener('click', this.onTargetSelection.bind(this));
        });
    }

    getTargetList() {
        const targets = this.system.hitTargets ?? [];
        return targets.map(target => game.canvas.tokens.documentCollection.find(t => t.actor?.uuid === target.actorId));
    }

    async onDamage(event) {
        event.stopPropagation();
        const targets = this.getTargetList();

        if (this.system.onSave) {
            const pendingingSaves = this.system.hitTargets.filter(t => t.saved.success === null);
            if (pendingingSaves.length) {
                const confirm = await foundry.applications.api.DialogV2.confirm({
                    window: { title: 'Pending Reaction Rolls found' },
                    content: `<p>Some Tokens still need to roll their Reaction Roll.</p><p>Are you sure you want to continue ?</p><p><i>Undone reaction rolls will be considered as failed</i></p>`
                });
                if (!confirm) return;
            }
        }

        if (targets.length === 0)
            return ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelected'));

        for (let target of targets) {
            let damages = foundry.utils.deepClone(this.system.damage);
            if (
                !this.system.hasHealing &&
                this.system.onSave &&
                this.system.hitTargets.find(t => t.id === target.id)?.saved?.success === true
            ) {
                const mod = CONFIG.DH.ACTIONS.damageOnSave[this.system.onSave]?.mod ?? 1;
                Object.entries(damages).forEach(([k, v]) => {
                    v.total = 0;
                    v.parts.forEach(part => {
                        part.total = Math.ceil(part.total * mod);
                        v.total += part.total;
                    });
                });
            }

            this.consumeOnSuccess();
            if (this.system.hasHealing) target.actor.takeHealing(damages);
            else target.actor.takeDamage(damages);
        }
    }

    getAction(actor, itemId, actionId) {
        const item = actor.items.get(itemId),
            action =
                actor.system.attack?._id === actionId
                    ? actor.system.attack
                    : item.system.attack?._id === actionId
                      ? item.system.attack
                      : item?.system?.actions?.get(actionId);
        return action;
    }

    async onApplyEffect(event) {
        event.stopPropagation();
        const actor = await foundry.utils.fromUuid(this.system.source.actor);
        if (!actor || !game.user.isGM) return true;
        if (this.system.source.item && this.system.source.action) {
            const action = this.getAction(actor, this.system.source.item, this.system.source.action);
            if (!action || !action?.applyEffects) return;
            const targets = this.getTargetList();
            if (targets.length === 0)
                ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.noTargetsSelected'));
            this.consumeOnSuccess();
            await action.applyEffects(event, this, targets);
        }
    }

    consumeOnSuccess() {
        if (!this.system.successConsumed && !this.targetSelection) {
            const action = this.system.action;
            if (action) action.consume(this.system, true);
        }
    }

    hoverTarget(event) {
        event.stopPropagation();
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (token && !token?.controlled) token._onHoverIn(event, { hoverOutOthers: true });
    }

    unhoverTarget(event) {
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (token && !token?.controlled) token._onHoverOut(event);
    }

    clickTarget(event) {
        event.stopPropagation();
        const token = canvas.tokens.get(event.currentTarget.dataset.token);
        if (!token) {
            ui.notifications.info(game.i18n.localize('DAGGERHEART.UI.Notifications.attackTargetDoesNotExist'));
            return;
        }
        game.canvas.pan(token);
    }

    onTargetSelection(event) {
        event.stopPropagation();
        if (!event.target.classList.contains('target-selected'))
            this.system.targetMode = Boolean(event.target.dataset.targetHit);
    }
}

class DHToken extends TokenDocument {
    /**
     * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar.
     * @param {object} attributes       The tracked attributes which can be chosen from
     * @returns {object}                A nested object of attribute choices to display
     */
    static getTrackedAttributeChoices(attributes, model) {
        attributes = attributes || this.getTrackedAttributes();
        const barGroup = game.i18n.localize('TOKEN.BarAttributes');
        const valueGroup = game.i18n.localize('TOKEN.BarValues');

        const bars = attributes.bar.map(v => {
            const a = v.join('.');
            const modelLabel = model ? game.i18n.localize(model.schema.getField(`${a}.value`).label) : null;
            return { group: barGroup, value: a, label: modelLabel ? modelLabel : a };
        });
        bars.sort((a, b) => a.label.compare(b.label));

        const invalidAttributes = [
            'gold',
            'levelData',
            'actions',
            'biography',
            'class',
            'multiclass',
            'companion',
            'notes',
            'partner',
            'description',
            'impulses',
            'tier',
            'type'
        ];
        const values = attributes.value.reduce((acc, v) => {
            const a = v.join('.');
            if (invalidAttributes.some(x => a.startsWith(x))) return acc;

            const field = model ? model.schema.getField(a) : null;
            const modelLabel = field ? game.i18n.localize(field.label) : null;
            const hint = field ? game.i18n.localize(field.hint) : null;
            acc.push({ group: valueGroup, value: a, label: modelLabel ? modelLabel : a, hint: hint });

            return acc;
        }, []);
        values.sort((a, b) => a.label.compare(b.label));

        return bars.concat(values);
    }

    static _getTrackedAttributesFromSchema(schema, _path = []) {
        const attributes = { bar: [], value: [] };
        for (const [name, field] of Object.entries(schema.fields)) {
            const p = _path.concat([name]);
            if (field instanceof foundry.data.fields.NumberField) attributes.value.push(p);
            if (field instanceof foundry.data.fields.BooleanField && field.options.isAttributeChoice)
                attributes.value.push(p);
            if (field instanceof foundry.data.fields.StringField) attributes.value.push(p);
            if (field instanceof foundry.data.fields.ArrayField) attributes.value.push(p);
            const isSchema = field instanceof foundry.data.fields.SchemaField;
            const isModel = field instanceof foundry.data.fields.EmbeddedDataField;

            if (isSchema || isModel) {
                const schema = isModel ? field.model.schema : field;
                const isBar = schema.has && schema.has('value') && schema.has('max');
                if (isBar) attributes.bar.push(p);
                else {
                    const inner = this.getTrackedAttributes(schema, p);
                    attributes.bar.push(...inner.bar);
                    attributes.value.push(...inner.value);
                }
            }
        }
        return attributes;
    }
    
    _shouldRecordMovementHistory() {
        return false;
    }
}

class DhTooltipManager extends foundry.helpers.interaction.TooltipManager {
    async activate(element, options = {}) {
        const { TextEditor } = foundry.applications.ux;

        let html = options.html;
        if (element.dataset.tooltip?.startsWith('#item#')) {
            const itemUuid = element.dataset.tooltip.slice(6);
            const item = await foundry.utils.fromUuid(itemUuid);
            if (item) {
                const isAction = item instanceof game.system.api.models.actions.actionsTypes.base;
                const isEffect = item instanceof ActiveEffect;
                await this.enrichText(item, isAction || isEffect);

                const type = isAction ? 'action' : isEffect ? 'effect' : item.type;
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/${type}.hbs`,
                    {
                        item: item,
                        description: item.system?.enrichedDescription ?? item.enrichedDescription,
                        config: CONFIG.DH
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(element);
            }
        } else {
            const attack = element.dataset.tooltip?.startsWith('#attack#');
            if (attack) {
                const actorUuid = element.dataset.tooltip.slice(8);
                const actor = await foundry.utils.fromUuid(actorUuid);
                const attack = actor.system.attack;

                const description = await TextEditor.enrichHTML(attack.description);
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/attack.hbs`,
                    {
                        attack: attack,
                        description: description,
                        parent: actor,
                        config: CONFIG.DH
                    }
                );

                this.tooltip.innerHTML = html;
            }

            const shortRest = element.dataset.tooltip?.startsWith('#shortRest#');
            const longRest = element.dataset.tooltip?.startsWith('#longRest#');
            if (shortRest || longRest) {
                const key = element.dataset.tooltip.slice(shortRest ? 11 : 10);

                const moves = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew).restMoves[
                    element.dataset.restType
                ].moves;
                const move = moves[key];
                const description = await TextEditor.enrichHTML(move.description);
                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/downtime.hbs`,
                    {
                        move: move,
                        description: description
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(
                    element,
                    this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                );
            }

            const isAdvantage = element.dataset.tooltip?.startsWith('#advantage#');
            const isDisadvantage = element.dataset.tooltip?.startsWith('#disadvantage#');
            if (isAdvantage || isDisadvantage) {
                const actorUuid = element.dataset.tooltip.slice(isAdvantage ? 11 : 14);
                const actor = await foundry.utils.fromUuid(actorUuid);

                if (actor) {
                    html = await foundry.applications.handlebars.renderTemplate(
                        `systems/daggerheart/templates/ui/tooltip/advantage.hbs`,
                        {
                            sources: isAdvantage ? actor.system.advantageSources : actor.system.disadvantageSources
                        }
                    );

                    this.tooltip.innerHTML = html;
                }
            }

            const deathMove = element.dataset.tooltip?.startsWith('#deathMove#');
            if (deathMove) {
                const name = element.dataset.deathName;
                const img = element.dataset.deathImg;
                const description = element.dataset.deathDescription;

                html = await foundry.applications.handlebars.renderTemplate(
                    `systems/daggerheart/templates/ui/tooltip/death-move.hbs`,
                    {
                        move: { name: name, img: img, description: description }
                    }
                );

                this.tooltip.innerHTML = html;
                options.direction = this._determineItemTooltipDirection(
                    element,
                    this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                );
            }
        }

        super.activate(element, { ...options, html: html });
    }

    _determineItemTooltipDirection(element, prefered = this.constructor.TOOLTIP_DIRECTIONS.LEFT) {
        const pos = element.getBoundingClientRect();
        const dirs = this.constructor.TOOLTIP_DIRECTIONS;
        switch (prefered) {
            case this.constructor.TOOLTIP_DIRECTIONS.LEFT:
                return dirs[
                    pos.x - this.tooltip.offsetWidth < 0
                        ? this.constructor.TOOLTIP_DIRECTIONS.DOWN
                        : this.constructor.TOOLTIP_DIRECTIONS.LEFT
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.UP:
                return dirs[
                    pos.y - this.tooltip.offsetHeight < 0
                        ? this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                        : this.constructor.TOOLTIP_DIRECTIONS.UP
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.RIGHT:
                return dirs[
                    pos.x + this.tooltip.offsetWidth > document.body.clientWidth
                        ? this.constructor.TOOLTIP_DIRECTIONS.DOWN
                        : this.constructor.TOOLTIP_DIRECTIONS.RIGHT
                ];
            case this.constructor.TOOLTIP_DIRECTIONS.DOWN:
                return dirs[
                    pos.y + this.tooltip.offsetHeight > document.body.clientHeight
                        ? this.constructor.TOOLTIP_DIRECTIONS.LEFT
                        : this.constructor.TOOLTIP_DIRECTIONS.DOWN
                ];
        }
    }

    async enrichText(item, flatStructure) {
        const { TextEditor } = foundry.applications.ux;
        const enrichPaths = [
            { path: flatStructure ? '' : 'system', name: 'description' },
            { path: 'system', name: 'features' },
            { path: 'system', name: 'actions' },
            { path: 'system', name: 'customActions' }
        ];

        for (let data of enrichPaths) {
            const basePath = `${data.path ? `${data.path}.` : ''}${data.name}`;
            const pathValue = foundry.utils.getProperty(item, basePath);
            if (!pathValue) continue;

            if (Array.isArray(pathValue) || pathValue.size) {
                for (const [index, itemValue] of pathValue.entries()) {
                    const itemIsAction = itemValue instanceof game.system.api.models.actions.actionsTypes.base;
                    const value = itemIsAction || !itemValue?.item ? itemValue : itemValue.item;
                    const enrichedValue = await TextEditor.enrichHTML(value.system?.description ?? value.description);
                    if (itemIsAction) value.enrichedDescription = enrichedValue;
                    else foundry.utils.setProperty(item, `${basePath}.${index}.enrichedDescription`, enrichedValue);
                }
            } else {
                const enrichedValue = await TextEditor.enrichHTML(pathValue);
                foundry.utils.setProperty(
                    item,
                    `${data.path ? `${data.path}.` : ''}enriched${data.name.capitalize()}`,
                    enrichedValue
                );
            }
        }
    }
}

/**
 * A singleton class that handles preview templates.
 */

class DhTemplateManager {
    #activePreview;

    /**
     * Create a template preview, deactivating any existing ones.
     * @param {object} data
     */
    async createPreview(data) {
        const template = await canvas.templates._createPreview(data, { renderSheet: false });

        this.#activePreview = {
            document: template.document,
            object: template,
            origin: { x: template.document.x, y: template.document.y }
        };

        this.#activePreview.events = {
            contextmenu: this.#cancelTemplate.bind(this),
            mousedown: this.#confirmTemplate.bind(this),
            mousemove: this.#onDragMouseMove.bind(this),
            wheel: this.#onMouseWheel.bind(this)
        };
        canvas.stage.on('mousemove', this.#activePreview.events.mousemove);
        canvas.stage.on('mousedown', this.#activePreview.events.mousedown);

        canvas.app.view.addEventListener('wheel', this.#activePreview.events.wheel, true);
        canvas.app.view.addEventListener('contextmenu', this.#activePreview.events.contextmenu);
    }

    /**
     * Handles the movement of the temlate preview on mousedrag.
     * @param {mousemove Event} event
     */
    #onDragMouseMove(event) {
        event.stopPropagation();
        const { moveTime, object } = this.#activePreview;
        const update = {};

        const now = Date.now();
        if (now - (moveTime || 0) <= 16) return;
        this.#activePreview.moveTime = now;

        let cursor = event.getLocalPosition(canvas.templates);

        Object.assign(update, canvas.grid.getCenterPoint(cursor));

        object.document.updateSource(update);
        object.renderFlags.set({ refresh: true });
    }

    /**
     * Handles the rotation of the preview template on scrolling.
     * @param {wheel Event} event
     */
    #onMouseWheel(event) {
        if (!event.shiftKey) return;
        event.stopPropagation();
        event.preventDefault();
        const { moveTime, object } = this.#activePreview;

        const now = Date.now();
        if (now - (moveTime || 0) <= 16) return;
        this.#activePreview.moveTime = now;

        object.document.updateSource({
            direction: object.document.direction + event.deltaY * 0.2
        });
        object.renderFlags.set({ refresh: true });
    }

    /**
     * Cancels the preview template on right-click.
     * @param {contextmenu Event} event
     */
    #cancelTemplate(event) {
        const { mousemove, mousedown, contextmenu } = this.#activePreview.events;
        canvas.templates._onDragLeftCancel(event);

        canvas.stage.off('mousemove', mousemove);
        canvas.stage.off('mousedown', mousedown);
        canvas.app.view.removeEventListener('contextmenu', contextmenu);
    }

    /**
     * Creates a real MeasuredTemplate at the preview location and cancels the preview.
     * @param {click Event} event
     */
    #confirmTemplate(event) {
        event.stopPropagation();

        canvas.scene.createEmbeddedDocuments('MeasuredTemplate', [this.#activePreview.document.toObject()]);

        this.#cancelTemplate(event);
    }
}

var documents = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DHItem: DHItem,
    DhActiveEffect: DhActiveEffect,
    DhChatMessage: DhpChatMessage,
    DhTemplateManager: DhTemplateManager,
    DhToken: DHToken,
    DhTooltipManager: DhTooltipManager,
    DhpActor: DhpActor,
    DhpCombat: DhpCombat
});

class BaseRoll extends Roll {
    /** @inheritdoc */
    static CHAT_TEMPLATE = 'systems/daggerheart/templates/ui/chat/foundryRoll.hbs';

    /** @inheritdoc */
    static TOOLTIP_TEMPLATE = 'systems/daggerheart/templates/ui/chat/foundryRollTooltip.hbs';
}

class DHRoll extends Roll {
    baseTerms = [];
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        if (!this.data || !Object.keys(this.data).length) this.data = options.data;
    }

    get title() {
        return game.i18n.localize('DAGGERHEART.GENERAL.Roll.basic');
    }

    static messageType = 'adversaryRoll';

    static CHAT_TEMPLATE = 'systems/daggerheart/templates/ui/chat/roll.hbs';

    static DefaultDialog = D20RollDialog;

    static async build(config = {}, message = {}) {
        const roll = await this.buildConfigure(config, message);
        if (!roll) return;
        await this.buildEvaluate(roll, config, (message = {}));
        await this.buildPost(roll, config, (message = {}));
        return config;
    }

    static async buildConfigure(config = {}, message = {}) {
        config.hooks = [...this.getHooks(), ''];
        config.dialog ??= {};
        for (const hook of config.hooks) {
            if (Hooks.call(`${CONFIG.DH.id}.preRoll${hook.capitalize()}`, config, message) === false) return null;
        }

        this.applyKeybindings(config);

        this.temporaryModifierBuilder(config);

        let roll = new this(config.roll.formula, config.data, config);
        if (config.dialog.configure !== false) {
            // Open Roll Dialog
            const DialogClass = config.dialog?.class ?? this.DefaultDialog;
            const configDialog = await DialogClass.configure(roll, config, message);
            if (!configDialog) return;
        }

        for (const hook of config.hooks) {
            if (
                Hooks.call(`${CONFIG.DH.id}.post${hook.capitalize()}RollConfiguration`, roll, config, message) === false
            )
                return [];
        }
        return roll;
    }

    static async buildEvaluate(roll, config = {}, message = {}) {
        if (config.evaluate !== false) {
            await roll.evaluate();
            config.roll = this.postEvaluate(roll, config);
        }
    }

    static async buildPost(roll, config, message) {
        for (const hook of config.hooks) {
            if (Hooks.call(`${CONFIG.DH.id}.postRoll${hook.capitalize()}`, config, message) === false) return null;
        }

        // Create Chat Message
        if (!config.source?.message) config.message = await this.toMessage(roll, config);
    }

    static postEvaluate(roll, config = {}) {
        return {
            total: roll.total,
            formula: roll.formula,
            dice: roll.dice.map(d => ({
                dice: d.denomination,
                total: d.total,
                formula: d.formula,
                results: d.results
            }))
        };
    }

    static async toMessage(roll, config) {
        const cls = getDocumentClass('ChatMessage'),
            msg = {
                type: this.messageType,
                user: game.user.id,
                title: roll.title,
                speaker: cls.getSpeaker(),
                sound: config.mute ? null : CONFIG.sounds.dice,
                system: config,
                rolls: [roll]
            };
        config.selectedRollMode ??= game.settings.get('core', 'rollMode');
        if (roll._evaluated) return await cls.create(msg, { rollMode: config.selectedRollMode });
        return msg;
    }

    /** @inheritDoc */
    async render({ flavor, template = this.constructor.CHAT_TEMPLATE, isPrivate = false, ...options } = {}) {
        if (!this._evaluated) return;
        const chatData = await this._prepareChatRenderContext({ flavor, isPrivate, ...options });
        return foundry.applications.handlebars.renderTemplate(template, chatData);
    }

    /** @inheritDoc */
    async _prepareChatRenderContext({ flavor, isPrivate = false, ...options } = {}) {
        if (isPrivate) {
            return {
                user: game.user.id,
                flavor: null,
                title: '???',
                roll: {
                    total: '??'
                },
                hasRoll: true,
                isPrivate
            };
        } else {
            options.message.system.user = game.user.id;
            return options.message.system;
        }
    }

    static applyKeybindings(config) {
        if (config.event)
            config.dialog.configure ??= !(config.event.shiftKey || config.event.altKey || config.event.ctrlKey);
    }

    static getHooks(hooks) {
        return hooks ?? [];
    }

    formatModifier(modifier) {
        if (Array.isArray(modifier)) {
            return [
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(modifier.join(' + '), this.options.data)
            ];
        } else {
            const numTerm = modifier < 0 ? '-' : '+';
            return [
                new foundry.dice.terms.OperatorTerm({ operator: numTerm }),
                new foundry.dice.terms.NumericTerm({ number: Math.abs(modifier) })
            ];
        }
    }

    applyBaseBonus() {
        return [];
    }

    addModifiers(roll) {
        roll = roll ?? this.options.roll;
        roll.modifiers?.forEach(m => {
            this.terms.push(...this.formatModifier(m.value));
        });
    }

    getBonus(path, label) {
        const bonus = foundry.utils.getProperty(this.data.bonuses, path),
            modifiers = [];
        if (bonus?.bonus)
            modifiers.push({
                label: label,
                value: bonus?.bonus
            });
        if (bonus?.dice?.length)
            modifiers.push({
                label: label,
                value: bonus?.dice
            });
        return modifiers;
    }

    getFaces(faces) {
        return Number(faces.startsWith('d') ? faces.replace('d', '') : faces);
    }

    constructFormula(config) {
        this.terms = Roll.parse(this.options.roll.formula, config.data);

        this.options.roll.modifiers = this.applyBaseBonus();
        this.addModifiers();

        if (this.options.extraFormula) {
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(this.options.extraFormula, this.options.data)
            );
        }
        return (this._formula = this.constructor.getFormula(this.terms));
    }

    static calculateTotalModifiers(roll) {
        let modifierTotal = 0;
        for (let i = 0; i < roll.terms.length; i++) {
            if (
                roll.terms[i] instanceof foundry.dice.terms.NumericTerm &&
                !!roll.terms[i - 1] &&
                roll.terms[i - 1] instanceof foundry.dice.terms.OperatorTerm
            )
                modifierTotal += Number(`${roll.terms[i - 1].operator}${roll.terms[i].total}`);
        }
        return modifierTotal;
    }

    static temporaryModifierBuilder(config) {
        return {};
    }
}

const registerRollDiceHooks = () => {
    Hooks.on(`${CONFIG.DH.id}.postRollDuality`, async (config, message) => {
        const hopeFearAutomation = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).hopeFear;
        if (
            !config.source?.actor ||
            (game.user.isGM ? !hopeFearAutomation.gm : !hopeFearAutomation.players) ||
            config.roll.type === 'reaction'
        )
            return;

        const actor = await fromUuid(config.source.actor);
        let updates = [];
        if (!actor) return;
        if (config.roll.isCritical || config.roll.result.duality === 1)
            updates.push({ key: 'hope', value: 1, total: -1, enabled: true });
        if (config.roll.isCritical) updates.push({ key: 'stress', value: 1, total: -1, enabled: true });
        if (config.roll.result.duality === -1) updates.push({ key: 'fear', value: 1, total: -1, enabled: true });

        if (config.rerolledRoll) {
            if (config.rerolledRoll.isCritical || config.rerolledRoll.result.duality === 1)
                updates.push({ key: 'hope', value: -1, total: 1, enabled: true });
            if (config.rerolledRoll.isCritical) updates.push({ key: 'stress', value: -1, total: 1, enabled: true });
            if (config.rerolledRoll.result.duality === -1)
                updates.push({ key: 'fear', value: -1, total: 1, enabled: true });
        }

        if (updates.length) {
            const target = actor.system.partner ?? actor;
            if (!['dead', 'defeated', 'unconscious'].some(x => actor.statuses.has(x))) {
                if (config.rerolledRoll) target.modifyResource(updates);
                else config.costs = [...(config.costs ?? []), ...updates];
            }
        }

        if (!config.roll.hasOwnProperty('success') && !config.targets?.length) return;

        const rollResult = config.roll.success || config.targets.some(t => t.hit),
            looseSpotlight = !rollResult || config.roll.result.duality === -1;

        if (looseSpotlight && game.combat?.active) {
            const currentCombatant = game.combat.combatants.get(game.combat.current?.combatantId);
            if (currentCombatant?.actorId == actor.id) ui.combat.setCombatantSpotlight(currentCombatant.id);
        }

        return;
    });
};

class D20Roll extends DHRoll {
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        this.constructFormula();
    }

    static ADV_MODE = {
        NORMAL: 0,
        ADVANTAGE: 1,
        DISADVANTAGE: -1
    };

    static CRITICAL_TRESHOLD = 20;

    static DefaultDialog = D20RollDialog;

    get title() {
        return game.i18n.localize('DAGGERHEART.GENERAL.d20Roll');
    }

    get d20() {
        if (!(this.terms[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.terms[0];
    }

    set d20(faces) {
        if (!(this.terms[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.terms[0].faces = this.getFaces(faces);
    }

    get dAdvantage() {
        return this.dice[2];
    }

    get isCritical() {
        if (!this.d20._evaluated) return;
        return this.d20.total >= this.constructor.CRITICAL_TRESHOLD;
    }

    get hasAdvantage() {
        const adv = this.options.roll.advantage.type ?? this.options.roll.advantage;
        return adv === this.constructor.ADV_MODE.ADVANTAGE;
    }

    get hasDisadvantage() {
        const adv = this.options.roll.advantage.type ?? this.options.roll.advantage;
        return adv === this.constructor.ADV_MODE.DISADVANTAGE;
    }

    static applyKeybindings(config) {
        let keys = {
            normal: true,
            advantage: false,
            disadvantage: false
        };

        if (config.event) {
            keys = {
                normal: config.event.shiftKey || config.event.altKey || config.event.ctrlKey,
                advantage: config.event.altKey,
                disadvantage: config.event.ctrlKey
            };
        }

        // Should the roll configuration dialog be displayed?
        config.dialog.configure ??= !Object.values(keys).some(k => k);

        // Determine advantage mode
        const advantage = config.roll.advantage === this.ADV_MODE.ADVANTAGE || keys.advantage || config.advantage;
        const disadvantage =
            config.roll.advantage === this.ADV_MODE.DISADVANTAGE || keys.disadvantage || config.disadvantage;
        if (advantage && !disadvantage) config.roll.advantage = this.ADV_MODE.ADVANTAGE;
        else if (!advantage && disadvantage) config.roll.advantage = this.ADV_MODE.DISADVANTAGE;
        else config.roll.advantage = this.ADV_MODE.NORMAL;
    }

    constructFormula(config) {
        this.createBaseDice();
        this.configureModifiers();
        this.resetFormula();
        return this._formula;
    }

    createBaseDice() {
        if (this.terms[0] instanceof foundry.dice.terms.Die) {
            this.terms = [this.terms[0]];
            return;
        }
        this.terms[0] = new foundry.dice.terms.Die({ faces: 20 });
    }

    configureModifiers() {
        this.applyAdvantage();

        this.baseTerms = foundry.utils.deepClone(this.dice);

        this.options.roll.modifiers = this.applyBaseBonus();

        this.options.experiences?.forEach(m => {
            if (this.options.data.experiences?.[m])
                this.options.roll.modifiers.push({
                    label: this.options.data.experiences[m].name,
                    value: this.options.data.experiences[m].value
                });
        });

        this.addModifiers();
        if (this.options.extraFormula) {
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(this.options.extraFormula, this.options.data)
            );
        }
    }

    applyAdvantage() {
        this.d20.modifiers.findSplice(m => ['kh', 'kl'].includes(m));
        if (!this.hasAdvantage && !this.hasDisadvantage) this.d20.number = 1;
        else {
            this.d20.number = 2;
            this.d20.modifiers.push(this.hasAdvantage ? 'kh' : 'kl');
        }
    }

    applyBaseBonus() {
        const modifiers = foundry.utils.deepClone(this.options.roll.baseModifiers) ?? [];

        modifiers.push(...this.getBonus(`roll.${this.options.type}`, `${this.options.type?.capitalize()} Bonus`));
        modifiers.push(
            ...this.getBonus(`roll.${this.options.roll.type}`, `${this.options.roll.type?.capitalize()} Bonus`)
        );

        return modifiers;
    }

    static postEvaluate(roll, config = {}) {
        const data = super.postEvaluate(roll, config);
        data.type = config.roll?.type;
        data.difficulty = config.roll.difficulty;
        if (config.targets?.length) {
            config.targets.forEach(target => {
                const difficulty = config.roll.difficulty ?? target.difficulty ?? target.evasion;
                target.hit = roll.isCritical || roll.total >= difficulty;
            });
            data.success = config.targets.some(target => target.hit);
        } else if (config.roll.difficulty) data.success = roll.isCritical || roll.total >= config.roll.difficulty;

        data.advantage = {
            type: config.roll.advantage,
            dice: roll.dAdvantage?.denomination,
            value: roll.dAdvantage?.total
        };
        data.dice = data.dice.map(dice => ({
            ...dice,
            results: dice.results.filter(x => !x.rerolled),
            rerolled: {
                any: dice.results.some(x => x.rerolled),
                rerolls: dice.results.filter(x => x.rerolled)
            }
        }));
        data.isCritical = config.isCritical = roll.isCritical;
        data.extra = roll.dice
            .filter(d => !roll.baseTerms.includes(d))
            .map(d => {
                return {
                    dice: d.denomination,
                    value: d.total,
                    results: d.results
                };
            });
        data.modifierTotal = this.calculateTotalModifiers(roll);
        return data;
    }

    resetFormula() {
        return (this._formula = this.constructor.getFormula(this.terms));
    }

    static async reroll(rollString, _target, message) {
        let parsedRoll = game.system.api.dice.D20Roll.fromData(rollString);
        parsedRoll = await parsedRoll.reroll();
        const newRoll = game.system.api.dice.D20Roll.postEvaluate(parsedRoll, {
            targets: message.system.targets,
            roll: {
                advantage: message.system.roll.advantage?.type,
                difficulty: message.system.roll.difficulty ? Number(message.system.roll.difficulty) : null
            }
        });

        if (game.modules.get('dice-so-nice')?.active) {
            await game.dice3d.showForRoll(parsedRoll, game.user, true);
        }

        const rerolled = {
            any: true,
            rerolls: [
                ...(message.system.roll.dice[0].rerolled?.rerolls?.length > 0
                    ? [message.system.roll.dice[0].rerolled?.rerolls]
                    : []),
                rollString.terms[0].results
            ]
        };
        return {
            newRoll: {
                ...newRoll,
                dice: [
                    {
                        ...newRoll.dice[0],
                        rerolled: rerolled
                    }
                ]
            },
            parsedRoll
        };
    }
}

class DamageRoll extends DHRoll {
    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
    }

    static DefaultDialog = DamageDialog;

    static async buildEvaluate(roll, config = {}, message = {}) {
        if (config.evaluate !== false) for (const roll of config.roll) await roll.roll.evaluate();

        roll._evaluated = true;
        const parts = config.roll.map(r => this.postEvaluate(r));

        config.damage = this.unifyDamageRoll(parts);
    }

    static postEvaluate(roll, config = {}) {
        return {
            ...roll,
            ...super.postEvaluate(roll.roll, config),
            damageTypes: [...(roll.damageTypes ?? [])],
            roll: roll.roll,
            type: config.type,
            modifierTotal: this.calculateTotalModifiers(roll.roll)
        };
    }

    static async buildPost(roll, config, message) {
        const chatMessage = config.source?.message
            ? ui.chat.collection.get(config.source.message)
            : getDocumentClass('ChatMessage').applyRollMode({}, config.rollMode);
        if (game.modules.get('dice-so-nice')?.active) {
            const pool = foundry.dice.terms.PoolTerm.fromRolls(
                    Object.values(config.damage).flatMap(r => r.parts.map(p => p.roll))
                ),
                diceRoll = Roll.fromTerms([pool]);
            await game.dice3d.showForRoll(
                diceRoll,
                game.user,
                true,
                chatMessage.whisper?.length > 0 ? chatMessage.whisper : null,
                chatMessage.blind
            );
        }
        await super.buildPost(roll, config, message);
        if (config.source?.message) {
            chatMessage.update({ 'system.damage': config.damage });
        }
    }

    static unifyDamageRoll(rolls) {
        const unified = {};
        rolls.forEach(r => {
            const resource = unified[r.applyTo] ?? { formula: '', total: 0, parts: [] };
            resource.formula += `${resource.formula !== '' ? ' + ' : ''}${r.formula}`;
            resource.total += r.total;
            resource.parts.push(r);
            unified[r.applyTo] = resource;
        });
        return unified;
    }

    static formatGlobal(rolls) {
        let formula, total;
        const applyTo = new Set(rolls.flatMap(r => r.applyTo));
        if (applyTo.size > 1) {
            const data = {};
            rolls.forEach(r => {
                if (data[r.applyTo]) {
                    data[r.applyTo].formula += ` + ${r.formula}`;
                    data[r.applyTo].total += r.total;
                } else {
                    data[r.applyTo] = {
                        formula: r.formula,
                        total: r.total
                    };
                }
            });
            formula = Object.entries(data).reduce((a, [k, v]) => a + ` ${k}: ${v.formula}`, '');
            total = Object.entries(data).reduce((a, [k, v]) => a + ` ${k}: ${v.total}`, '');
        } else {
            formula = rolls.map(r => r.formula).join(' + ');
            total = rolls.reduce((a, c) => a + c.total, 0);
        }
        return { formula, total };
    }

    applyBaseBonus(part) {
        const modifiers = [],
            type = this.options.messageType ?? (this.options.hasHealing ? 'healing' : 'damage'),
            options = part ?? this.options;

        modifiers.push(...this.getBonus(`${type}`, `${type.capitalize()} Bonus`));
        if (!this.options.hasHealing) {
            options.damageTypes?.forEach(t => {
                modifiers.push(...this.getBonus(`${type}.${t}`, `${t.capitalize()} ${type.capitalize()} Bonus`));
            });
            const weapons = ['primaryWeapon', 'secondaryWeapon'];
            weapons.forEach(w => {
                if (this.options.source.item && this.options.source.item === this.data[w]?.id)
                    modifiers.push(...this.getBonus(`${type}.${w}`, 'Weapon Bonus'));
            });
        }

        return modifiers;
    }

    constructFormula(config) {
        this.options.roll.forEach((part, index) => {
            part.roll = new Roll(Roll.replaceFormulaData(part.formula, config.data));
            this.constructFormulaPart(config, part, index);
        });
        return this.options.roll;
    }

    constructFormulaPart(config, part, index) {
        part.roll.terms = Roll.parse(part.roll.formula, config.data);

        if (part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            part.modifiers = this.applyBaseBonus(part);
            this.addModifiers(part);
            part.modifiers?.forEach(m => {
                part.roll.terms.push(...this.formatModifier(m.value));
            });
        }

        /* To Remove When Reaction System */
        if (index === 0 && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            for (const mod in config.modifiers) {
                const modifier = config.modifiers[mod];
                if (modifier.beforeCrit === true && (modifier.enabled || modifier.value)) modifier.callback(part);
            }
        }

        if (part.extraFormula) {
            part.roll.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                ...this.constructor.parse(part.extraFormula, this.options.data)
            );
        }

        if (config.isCritical && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            const total = part.roll.dice.reduce((acc, term) => acc + term._faces * term._number, 0);
            if (total > 0) {
                part.roll.terms.push(...this.formatModifier(total));
            }
        }

        /* To Remove When Reaction System */
        if (index === 0 && part.applyTo === CONFIG.DH.GENERAL.healingTypes.hitPoints.id) {
            for (const mod in config.modifiers) {
                const modifier = config.modifiers[mod];
                if (!modifier.beforeCrit && (modifier.enabled || modifier.value)) modifier.callback(part);
            }
        }

        return (part.roll._formula = this.constructor.getFormula(part.roll.terms));
    }

    /* To Remove When Reaction System */
    static temporaryModifierBuilder(config) {
        const mods = {};
        if (config.data?.parent) {
            if (config.data.parent.appliedEffects) {
                // Bardic Rally
                const rallyChoices = config.data?.parent?.appliedEffects.reduce((a, c) => {
                    const change = c.changes.find(ch => ch.key === 'system.bonuses.rally');
                    if (change) a.push({ value: c.id, label: change.value });
                    return a;
                }, []);
                if (rallyChoices.length) {
                    mods.rally = {
                        label: 'DAGGERHEART.CLASS.Feature.rallyDice',
                        values: rallyChoices,
                        value: null,
                        beforeCrit: true,
                        callback: part => {
                            const rallyFaces = config.modifiers.rally.values.find(
                                r => r.value === config.modifiers.rally.value
                            )?.label;
                            part.roll.terms.push(
                                new foundry.dice.terms.OperatorTerm({ operator: '+' }),
                                ...this.parse(`1${rallyFaces}`)
                            );
                        }
                    };
                }
            }

            const item = config.data.parent.items?.get(config.source.item);
            if (item) {
                // Massive (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'massive'))
                    mods.massive = {
                        label: CONFIG.DH.ITEM.weaponFeatures.massive.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`kh${part.roll.terms[0].number}`);
                            part.roll.terms[0].number += 1;
                        }
                    };

                // Powerful (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'powerful'))
                    mods.powerful = {
                        label: CONFIG.DH.ITEM.weaponFeatures.powerful.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`kh${part.roll.terms[0].number}`);
                            part.roll.terms[0].number += 1;
                        }
                    };

                // Brutal (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'brutal'))
                    mods.brutal = {
                        label: CONFIG.DH.ITEM.weaponFeatures.brutal.label,
                        enabled: true,
                        beforeCrit: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`x${part.roll.terms[0].faces}`);
                        }
                    };

                // Serrated (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'serrated'))
                    mods.serrated = {
                        label: CONFIG.DH.ITEM.weaponFeatures.serrated.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`sc8`);
                        }
                    };

                // Self-Correcting (Weapon Feature)
                if (item.system.itemFeatures.find(f => f.value === 'selfCorrecting'))
                    mods.selfCorrecting = {
                        label: CONFIG.DH.ITEM.weaponFeatures.selfCorrecting.label,
                        enabled: true,
                        callback: part => {
                            part.roll.terms[0].modifiers.push(`sc6`);
                        }
                    };
            }
        }

        config.modifiers = mods;
        return mods;
    }

    static async reroll(target, message) {
        const { damageType, part, dice, result } = target.dataset;
        const rollPart = message.system.damage[damageType].parts[part];

        let diceIndex = 0;
        let parsedRoll = game.system.api.dice.DamageRoll.fromData({
            ...rollPart.roll,
            terms: rollPart.roll.terms.map(term => {
                const isDie = term.class === 'Die';
                const fixedTerm = {
                    ...term,
                    ...(isDie ? { results: rollPart.dice[diceIndex].results } : {})
                };

                if (isDie) diceIndex++;
                return fixedTerm;
            }),
            class: 'DamageRoll',
            evaluated: false
        });

        const parsedDiceTerms = Object.keys(parsedRoll.terms).reduce((acc, key) => {
            const term = parsedRoll.terms[key];
            if (term instanceof CONFIG.Dice.termTypes.DiceTerm) acc[Object.keys(acc).length] = term;
            return acc;
        }, {});
        const term = parsedDiceTerms[dice];
        const termResult = parsedDiceTerms[dice].results[result];

        const newIndex = parsedDiceTerms[dice].results.length;
        await term.reroll(`/r1=${termResult.result}`);

        if (game.modules.get('dice-so-nice')?.active) {
            const newResult = parsedDiceTerms[dice].results[newIndex];
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: [
                    new foundry.dice.terms.Die({
                        ...term,
                        total: newResult.result,
                        faces: term._faces,
                        results: [newResult]
                    })
                ],
                options: { appearance: {} }
            };

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        await parsedRoll.evaluate();

        const results = parsedRoll.dice[dice].results.map(result => ({
            ...result,
            discarded: !result.active
        }));
        const newResult = results.splice(results.length - 1, 1);
        results.splice(Number(result) + 1, 0, newResult[0]);

        const rerolledDice = parsedRoll.dice.map((x, index) => {
            const isRerollDice = index === Number(dice);
            if (!isRerollDice) return { ...x, dice: x.denomination };
            return {
                dice: parsedRoll.dice[dice].denomination,
                total: parsedRoll.dice[dice].total,
                results: results.map(result => ({
                    ...result,
                    hasRerolls: result.hasRerolls || isRerollDice
                }))
            };
        });

        const updateMessage = game.messages.get(message._id);
        const damageParts = updateMessage.system.damage[damageType].parts.map((damagePart, index) => {
            if (index !== Number(part)) return damagePart;
            return {
                ...rollPart,
                total: parsedRoll.total,
                dice: rerolledDice
            };
        });
        await updateMessage.update({
            [`system.damage.${damageType}`]: {
                ...updateMessage,
                total: parsedRoll.total,
                parts: damageParts
            }
        });
    }
}

class DualityRoll extends D20Roll {
    _advantageFaces = 6;
    _advantageNumber = 1;
    _rallyIndex;

    constructor(formula, data = {}, options = {}) {
        super(formula, data, options);
        this.rallyChoices = this.setRallyChoices();
    }

    static messageType = 'dualityRoll';

    static DefaultDialog = D20RollDialog;

    get title() {
        return game.i18n.localize(
            `DAGGERHEART.GENERAL.${this.options?.roll?.type === CONFIG.DH.ITEM.actionTypes.reaction.id ? 'reactionRoll' : 'dualityRoll'}`
        );
    }

    get dHope() {
        // if ( !(this.terms[0] instanceof foundry.dice.terms.Die) ) return;
        if (!(this.dice[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.dice[0];
        // return this.#hopeDice;
    }

    set dHope(faces) {
        if (!(this.dice[0] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.terms[0].faces = this.getFaces(faces);
        // this.#hopeDice = `d${face}`;
    }

    get dFear() {
        // if ( !(this.terms[1] instanceof foundry.dice.terms.Die) ) return;
        if (!(this.dice[1] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        return this.dice[1];
        // return this.#fearDice;
    }

    set dFear(faces) {
        if (!(this.dice[1] instanceof foundry.dice.terms.Die)) this.createBaseDice();
        this.dice[1].faces = this.getFaces(faces);
        // this.#fearDice = `d${face}`;
    }

    get dAdvantage() {
        return this.dice[2];
    }

    get advantageFaces() {
        return this._advantageFaces;
    }

    set advantageFaces(faces) {
        this._advantageFaces = this.getFaces(faces);
    }

    get advantageNumber() {
        return this._advantageNumber;
    }

    set advantageNumber(value) {
        this._advantageNumber = Number(value);
    }

    setRallyChoices() {
        return this.data?.parent?.appliedEffects.reduce((a, c) => {
            const change = c.changes.find(ch => ch.key === 'system.bonuses.rally');
            if (change) a.push({ value: c.id, label: change.value });
            return a;
        }, []);
    }

    get dRally() {
        if (!this.rallyFaces) return null;
        if (this.hasDisadvantage || this.hasAdvantage) return this.dice[3];
        else return this.dice[2];
    }

    get rallyFaces() {
        const rallyChoice = this.rallyChoices?.find(r => r.value === this._rallyIndex)?.label;
        return rallyChoice ? this.getFaces(rallyChoice) : null;
    }

    get isCritical() {
        if (!this.dHope._evaluated || !this.dFear._evaluated) return;
        return this.dHope.total === this.dFear.total;
    }

    get withHope() {
        if (!this._evaluated) return;
        return this.dHope.total > this.dFear.total;
    }

    get withFear() {
        if (!this._evaluated) return;
        return this.dHope.total < this.dFear.total;
    }

    get totalLabel() {
        const label = this.withHope
            ? 'DAGGERHEART.GENERAL.hope'
            : this.withFear
              ? 'DAGGERHEART.GENERAL.fear'
              : 'DAGGERHEART.GENERAL.criticalSuccess';

        return game.i18n.localize(label);
    }

    static getHooks(hooks) {
        return [...(hooks ?? []), 'Duality'];
    }

    /** @inheritDoc */
    static fromData(data) {
        data.terms[0].class = foundry.dice.terms.Die.name;
        data.terms[2].class = foundry.dice.terms.Die.name;
        return super.fromData(data);
    }

    createBaseDice() {
        if (this.dice[0] instanceof foundry.dice.terms.Die && this.dice[1] instanceof foundry.dice.terms.Die) {
            this.terms = [this.terms[0], this.terms[1], this.terms[2]];
            return;
        }
        this.terms[0] = new foundry.dice.terms.Die({ faces: 12 });
        this.terms[1] = new foundry.dice.terms.OperatorTerm({ operator: '+' });
        this.terms[2] = new foundry.dice.terms.Die({ faces: 12 });
    }

    applyAdvantage() {
        if (this.hasAdvantage || this.hasDisadvantage) {
            const dieFaces = this.advantageFaces,
                advDie = new foundry.dice.terms.Die({ faces: dieFaces, number: this.advantageNumber });
            if (this.advantageNumber > 1) advDie.modifiers = ['kh'];
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: this.hasDisadvantage ? '-' : '+' }),
                advDie
            );
        }
        if (this.rallyFaces)
            this.terms.push(
                new foundry.dice.terms.OperatorTerm({ operator: this.hasDisadvantage ? '-' : '+' }),
                new foundry.dice.terms.Die({ faces: this.rallyFaces })
            );
    }

    applyBaseBonus() {
        const modifiers = super.applyBaseBonus();

        if (this.options.roll.trait && this.data.traits[this.options.roll.trait])
            modifiers.unshift({
                label: `DAGGERHEART.CONFIG.Traits.${this.options.roll.trait}.name`,
                value: this.data.traits[this.options.roll.trait].value
            });

        const weapons = ['primaryWeapon', 'secondaryWeapon'];
        weapons.forEach(w => {
            if (this.options.source.item && this.options.source.item === this.data[w]?.id)
                modifiers.push(...this.getBonus(`roll.${w}`, 'Weapon Bonus'));
        });

        return modifiers;
    }

    static async buildEvaluate(roll, config = {}, message = {}) {
        await super.buildEvaluate(roll, config, message);

        await setDiceSoNiceForDualityRoll(
            roll,
            config.roll.advantage.type,
            config.roll.hope.dice,
            config.roll.fear.dice,
            config.roll.advantage.dice
        );
    }

    static postEvaluate(roll, config = {}) {
        const data = super.postEvaluate(roll, config);

        data.hope = {
            dice: roll.dHope.denomination,
            value: roll.dHope.total,
            rerolled: {
                any: roll.dHope.results.some(x => x.rerolled),
                rerolls: roll.dHope.results.filter(x => x.rerolled)
            }
        };
        data.fear = {
            dice: roll.dFear.denomination,
            value: roll.dFear.total,
            rerolled: {
                any: roll.dFear.results.some(x => x.rerolled),
                rerolls: roll.dFear.results.filter(x => x.rerolled)
            }
        };
        data.rally = {
            dice: roll.dRally?.denomination,
            value: roll.dRally?.total
        };
        data.result = {
            duality: roll.withHope ? 1 : roll.withFear ? -1 : 0,
            total: roll.dHope.total + roll.dFear.total,
            label: roll.totalLabel
        };

        if (roll._rallyIndex && roll.data?.parent)
            roll.data.parent.deleteEmbeddedDocuments('ActiveEffect', [roll._rallyIndex]);

        return data;
    }

    static async reroll(rollString, target, message) {
        let parsedRoll = game.system.api.dice.DualityRoll.fromData({ ...rollString, evaluated: false });
        const term = parsedRoll.terms[target.dataset.dieIndex];
        await term.reroll(`/r1=${term.total}`);
        if (game.modules.get('dice-so-nice')?.active) {
            const diceSoNiceRoll = {
                _evaluated: true,
                dice: [
                    new foundry.dice.terms.Die({
                        ...term,
                        faces: term._faces,
                        results: term.results.filter(x => !x.rerolled)
                    })
                ],
                options: { appearance: {} }
            };

            const diceSoNicePresets = await getDiceSoNicePresets(`d${term._faces}`, `d${term._faces}`);
            const type = target.dataset.type;
            if (diceSoNicePresets[type]) {
                diceSoNiceRoll.dice[0].options = diceSoNicePresets[type];
            }

            await game.dice3d.showForRoll(diceSoNiceRoll, game.user, true);
        }

        await parsedRoll.evaluate();

        const newRoll = game.system.api.dice.DualityRoll.postEvaluate(parsedRoll, {
            targets: message.system.targets,
            roll: {
                advantage: message.system.roll.advantage?.type,
                difficulty: message.system.roll.difficulty ? Number(message.system.roll.difficulty) : null
            }
        });
        newRoll.extra = newRoll.extra.slice(2);

        Hooks.call(`${CONFIG.DH.id}.postRollDuality`, {
            source: { actor: message.system.source.actor ?? '' },
            targets: message.system.targets,
            roll: newRoll,
            rerolledRoll:
                newRoll.result.duality !== message.system.roll.result.duality ? message.system.roll : undefined
        });
        return { newRoll, parsedRoll };
    }
}

var dice = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseRoll: BaseRoll,
    D20Roll: D20Roll,
    DHRoll: DHRoll,
    DamageRoll: DamageRoll,
    DualityRoll: DualityRoll
});

class RegisterHandlebarsHelpers {
    static registerHelpers() {
        Handlebars.registerHelper({
            add: this.add,
            includes: this.includes,
            times: this.times,
            damageFormula: this.damageFormula,
            formulaValue: this.formulaValue,
            damageSymbols: this.damageSymbols,
            rollParsed: this.rollParsed,
            hasProperty: foundry.utils.hasProperty,
            getProperty: foundry.utils.getProperty,
            setVar: this.setVar,
            empty: this.empty
        });
    }
    static add(a, b) {
        const aNum = Number.parseInt(a);
        const bNum = Number.parseInt(b);
        return (Number.isNaN(aNum) ? 0 : aNum) + (Number.isNaN(bNum) ? 0 : bNum);
    }

    static includes(list, item) {
        return list.includes(item);
    }

    static times(nr, block) {
        var accum = '';
        for (var i = 0; i < nr; ++i) accum += block.fn(i);
        return accum;
    }

    static damageFormula(attack, actor) {
        const traitTotal = actor.system.traits?.[attack.roll.trait]?.value;
        const instances = [
            attack.damage.parts.map(x => Roll.replaceFormulaData(x.value.getFormula(), actor)).join(' + '),
            traitTotal
        ].filter(x => x);

        return instances.join(traitTotal > 0 ? ' + ' : ' - ');
    }

    static formulaValue(formula, item) {
        if (isNaN(formula)) {
            const data = item.getRollData.bind(item)(),
                roll = new Roll(Roll.replaceFormulaData(formula, data)).evaluateSync();
            formula = roll.total;
        }
        return formula;
    }

    static damageSymbols(damageParts) {
        const symbols = [...new Set(damageParts.reduce((a, c) => a.concat([...c.type]), []))].map(
            p => CONFIG.DH.GENERAL.damageTypes[p].icon
        );
        return new Handlebars.SafeString(Array.from(symbols).map(symbol => `<i class="fa-solid ${symbol}"></i>`));
    }

    static rollParsed(value, actor, item, numerical) {
        const isNumerical = typeof numerical === 'boolean' ? numerical : false;
        const result = itemAbleRollParse(value, actor?.getRollData() ?? {}, item);
        return isNumerical ? (!result ? 0 : Number(result)) : result;
    }

    static setVar(name, value, context) {
        this[name] = value;
    }

    static empty(object) {
        if (!(typeof object === 'object')) return true;
        return Object.keys(object).length === 0;
    }
}

function DhDamageEnricher(match, _options) {
    const parts = match[1].split('|').map(x => x.trim());

    let value = null,
        type = null,
        inline = false;

    parts.forEach(part => {
        const split = part.split(':').map(x => x.toLowerCase().trim());
        if (split.length === 2) {
            switch (split[0]) {
                case 'value':
                    value = split[1];
                    break;
                case 'type':
                    type = split[1];
                    break;
                case 'inline':
                    inline = true;
                    break;
            }
        }
    });

    if (!value || !value) return match[0];

    return getDamageMessage(value, type, inline, match[0]);
}

function getDamageMessage(damage, type, inline, defaultElement) {
    const typeIcons = type
        .replace('[', '')
        .replace(']', '')
        .split(',')
        .map(x => x.trim())
        .map(x => {
            return CONFIG.DH.GENERAL.damageTypes[x]?.icon ?? null;
        })
        .filter(x => x);

    if (!typeIcons.length) return defaultElement;

    const iconNodes = typeIcons.map(x => `<i class="fa-solid ${x}"></i>`).join('');

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <button type="button" class="enriched-damage-button${inline ? ' inline' : ''}" 
            data-value="${damage}"
            data-type="${type}"
            data-tooltip="${game.i18n.localize('DAGGERHEART.GENERAL.damage')}"
        >
            ${damage}
            ${iconNodes}
        </button>
    `;

    return dualityElement;
}

const renderDamageButton = async event => {
    const button = event.currentTarget,
        value = button.dataset.value,
        type = button.dataset.type
            .replace('[', '')
            .replace(']', '')
            .split(',')
            .map(x => x.trim());

    const config = {
        event: event,
        title: game.i18n.localize('Damage Roll'),
        data: { bonuses: [] },
        source: {},
        hasDamage: true,
        hasTarget: true,
        targets: Array.from(game.user.targets).map(t =>
            game.system.api.fields.ActionFields.TargetField.formatTarget(t)
        ),
        roll: [
            {
                formula: value,
                applyTo: CONFIG.DH.GENERAL.healingTypes.hitPoints.id,
                type: type
            }
        ]
    };

    CONFIG.Dice.daggerheart.DamageRoll.build(config);
};

function DhDualityRollEnricher(match, _options) {
    const roll = rollCommandToJSON(match[1], match[0]);
    if (!roll) return match[0];

    return getDualityMessage(roll.result, roll.flavor);
}

function getDualityMessage(roll, flavor) {
    const trait = roll.trait && abilities[roll.trait] ? game.i18n.localize(abilities[roll.trait].label) : null;
    const label =
        flavor ??
        (roll.trait
            ? game.i18n.format('DAGGERHEART.GENERAL.rollWith', { roll: trait })
            : roll.reaction
              ? game.i18n.localize('DAGGERHEART.GENERAL.reactionRoll')
              : game.i18n.localize('DAGGERHEART.GENERAL.duality'));

    const dataLabel = trait
        ? game.i18n.localize(abilities[roll.trait].label)
        : game.i18n.localize('DAGGERHEART.GENERAL.duality');

    const advantage = roll.advantage
        ? CONFIG.DH.ACTIONS.advantageState.advantage.value
        : roll.disadvantage
          ? CONFIG.DH.ACTIONS.advantageState.disadvantage.value
          : undefined;
    const advantageLabel =
        advantage === CONFIG.DH.ACTIONS.advantageState.advantage.value
            ? 'Advantage'
            : advantage === CONFIG.DH.ACTIONS.advantageState.disadvantage.value
              ? 'Disadvantage'
              : undefined;

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <button type="button" class="duality-roll-button${roll.inline ? ' inline' : ''}" 
            data-title="${label}"
            data-label="${dataLabel}"
            data-reaction="${roll.reaction ? 'true' : 'false'}"
            data-hope="${roll.hope ?? 'd12'}" 
            data-fear="${roll.fear ?? 'd12'}"
            ${advantage ? `data-advantage="${advantage}"` : ''}
            ${roll.difficulty !== undefined ? `data-difficulty="${roll.difficulty}"` : ''}
            ${roll.trait && abilities[roll.trait] ? `data-trait="${roll.trait}"` : ''}
            ${roll.advantage ? 'data-advantage="true"' : ''}
            ${roll.disadvantage ? 'data-disadvantage="true"' : ''}
        >
            ${roll.reaction ? '<i class="fa-solid fa-reply"></i>' : '<i class="fa-solid fa-circle-half-stroke"></i>'}
            ${label}
            ${!flavor && (roll.difficulty || advantageLabel) ? `(${[roll.difficulty, advantageLabel ? game.i18n.localize(`DAGGERHEART.GENERAL.${advantageLabel}.short`) : null].filter(x => x).join(' ')})` : ''}
        </button>
    `;

    return dualityElement;
}

const renderDualityButton = async event => {
    const button = event.currentTarget,
        reaction = button.dataset.reaction === 'true',
        traitValue = button.dataset.trait?.toLowerCase(),
        target = getCommandTarget({ allowNull: true }),
        difficulty = button.dataset.difficulty,
        advantage = button.dataset.advantage ? Number(button.dataset.advantage) : undefined;

    await enrichedDualityRoll(
        {
            reaction,
            traitValue,
            target,
            difficulty,
            title: button.dataset.title,
            label: button.dataset.label,
            advantage
        },
        event
    );
};

const enrichedDualityRoll = async (
    { reaction, traitValue, target, difficulty, title, label, advantage },
    event
) => {
    const config = {
        event: event ?? {},
        title: title,
        roll: {
            trait: traitValue && target ? traitValue : null,
            label: label,
            difficulty: difficulty,
            advantage,
            type: reaction ? 'reaction' : null
        },
        type: 'trait',
        hasRoll: true
    };

    if (target) {
        await target.diceRoll(config);
    } else {
        // For no target, call DualityRoll directly with basic data
        config.data = { experiences: {}, traits: {} };
        config.source = { actor: null };
        await CONFIG.Dice.daggerheart.DualityRoll.build(config);
    }
};

async function DhEffectEnricher(match, _options) {
    const effect = await foundry.utils.fromUuid(match[1]);
    if (!effect) return match[0];

    const dualityElement = document.createElement('span');
    dualityElement.innerHTML = `
        <a class="flexrow enriched-effect" 
            data-link
            draggable="true"
            data-uuid="${match[1]}"
            data-tooltip="${game.i18n.localize('DAGGERHEART.UI.Tooltip.dragApplyEffect')}"
        >
            <img src="icons/svg/aura.svg" style="width: 24px;" />
            <span>${effect.name}</span>
        </a>
    `;

    return dualityElement;
}

function DhTemplateEnricher(match, _options) {
    const parts = match[1].split('|').map(x => x.trim());

    let type = null,
        range = null,
        inline = false;

    parts.forEach(part => {
        const split = part.split(':').map(x => x.toLowerCase().trim());
        if (split.length === 2) {
            switch (split[0]) {
                case 'type':
                    const matchedType = Object.values(CONFIG.DH.GENERAL.templateTypes).find(
                        x => x.toLowerCase() === split[1]
                    );
                    type = matchedType;
                    break;
                case 'range':
                    const matchedRange = Object.values(CONFIG.DH.GENERAL.templateRanges).find(
                        x => x.id.toLowerCase() === split[1] || x.short === split[1]
                    );
                    range = matchedRange?.id;
                    break;
                case 'inline':
                    inline = true;
                    break;
            }
        }
    });

    if (!type || !range) return match[0];

    const label = game.i18n.localize(`DAGGERHEART.CONFIG.TemplateTypes.${type}`);

    const templateElement = document.createElement('span');
    templateElement.innerHTML = `
        <button type="button" class="measured-template-button${inline ? ' inline' : ''}" data-type="${type}" data-range="${range}">
            ${label} - ${game.i18n.localize(`DAGGERHEART.CONFIG.Range.${range}.name`)}
        </button>
    `;

    return templateElement;
}

const renderMeasuredTemplate = async event => {
    const button = event.currentTarget,
        type = button.dataset.type,
        range = button.dataset.range;

    if (!type || !range || !game.canvas.scene) return;

    const usedType = type === 'inFront' ? 'cone' : type === 'emanation' ? 'circle' : type;
    const angle =
        type === CONST.MEASURED_TEMPLATE_TYPES.CONE
            ? CONFIG.MeasuredTemplate.defaults.angle
            : type === CONFIG.DH.GENERAL.templateTypes.INFRONT
              ? '180'
              : undefined;

    const baseDistance = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement[
        range
    ];
    const distance = type === CONFIG.DH.GENERAL.templateTypes.EMANATION ? baseDistance + 2.5 : baseDistance;

    const { width, height } = game.canvas.scene.dimensions;
    const data = {
        x: width / 2,
        y: height / 2,
        t: usedType,
        distance: distance,
        width: type === CONST.MEASURED_TEMPLATE_TYPES.RAY ? 5 : undefined,
        angle: angle
    };

    CONFIG.ux.TemplateManager.createPreview(data);
};

const enricherConfig = [
    {
        pattern: /@Damage\[(.*)\]({.*})?/g,
        enricher: DhDamageEnricher
    },
    {
        pattern: /\[\[\/dr\s?(.*?)\]\]({.*})?/g,
        enricher: DhDualityRollEnricher
    },
    {
        pattern: /@Effect\[(.*)\]({.*})?/g,
        enricher: DhEffectEnricher
    },
    {
        pattern: /@Template\[(.*)\]({.*})?/g,
        enricher: DhTemplateEnricher
    }
];

const enricherRenderSetup = element => {
    element
        .querySelectorAll('.enriched-damage-button')
        .forEach(element => element.addEventListener('click', renderDamageButton));

    element
        .querySelectorAll('.duality-roll-button')
        .forEach(element => element.addEventListener('click', renderDualityButton));

    element
        .querySelectorAll('.measured-template-button')
        .forEach(element => element.addEventListener('click', renderMeasuredTemplate));

    // element
    //     .querySelectorAll('.enriched-effect')
    //     .forEach(element => element.addEventListener('dragstart', dragEnrichedEffect));
};

class DhCountdowns extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;

        return {
            narrative: new fields.EmbeddedDataField(DhCountdownData),
            encounter: new fields.EmbeddedDataField(DhCountdownData)
        };
    }

    static CountdownCategories = { narrative: 'narrative', combat: 'combat' };
}

class DhCountdownData extends foundry.abstract.DataModel {
    static LOCALIZATION_PREFIXES = ['DAGGERHEART.APPLICATIONS.Countdown']; // Nots ure why this won't work. Setting labels manually for now

    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            countdowns: new fields.TypedObjectField(new fields.EmbeddedDataField(DhCountdown)),
            ownership: new fields.SchemaField({
                default: new fields.NumberField({
                    required: true,
                    choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                    initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE
                }),
                players: new fields.TypedObjectField(
                    new fields.SchemaField({
                        type: new fields.NumberField({
                            required: true,
                            choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                            initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
                        })
                    })
                )
            }),
            window: new fields.SchemaField({})
        };
    }

    get playerOwnership() {
        return Array.from(game.users).reduce((acc, user) => {
            acc[user.id] = {
                value: user.isGM
                    ? CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER
                    : this.ownership.players[user.id] && this.ownership.players[user.id].type !== -1
                      ? this.ownership.players[user.id].type
                      : this.ownership.default,
                isGM: user.isGM
            };

            return acc;
        }, {});
    }
}

class DhCountdown extends foundry.abstract.DataModel {
    static defineSchema() {
        const fields = foundry.data.fields;
        return {
            name: new fields.StringField({
                required: true,
                label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.name.label'
            }),
            img: new fields.FilePathField({
                categories: ['IMAGE'],
                base64: false,
                initial: 'icons/magic/time/hourglass-yellow-green.webp'
            }),
            ownership: new fields.SchemaField({
                default: new fields.NumberField({
                    required: true,
                    choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                    initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE
                }),
                players: new fields.TypedObjectField(
                    new fields.SchemaField({
                        type: new fields.NumberField({
                            required: true,
                            choices: Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS),
                            initial: CONST.DOCUMENT_OWNERSHIP_LEVELS.INHERIT
                        })
                    })
                )
            }),
            progress: new fields.SchemaField({
                current: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.current.label'
                }),
                max: new fields.NumberField({
                    required: true,
                    integer: true,
                    initial: 1,
                    label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.max.label'
                }),
                type: new fields.SchemaField({
                    value: new fields.StringField({
                        required: true,
                        choices: CONFIG.DH.GENERAL.countdownTypes,
                        initial: CONFIG.DH.GENERAL.countdownTypes.custom.id,
                        label: 'DAGGERHEART.GENERAL.type'
                    }),
                    label: new fields.StringField({
                        label: 'DAGGERHEART.APPLICATIONS.Countdown.FIELDS.countdowns.element.progress.type.label.label'
                    })
                })
            })
        };
    }

    get playerOwnership() {
        return Array.from(game.users).reduce((acc, user) => {
            acc[user.id] = {
                value: user.isGM
                    ? CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER
                    : this.ownership.players[user.id] && this.ownership.players[user.id].type !== -1
                      ? this.ownership.players[user.id].type
                      : this.ownership.default,
                isGM: user.isGM
            };

            return acc;
        }, {});
    }
}

const registerCountdownHooks = () => {
    Hooks.on(socketEvent.Refresh, ({ refreshType, application }) => {
        if (refreshType === RefreshType.Countdown) {
            if (application) {
                foundry.applications.instances.get(application)?.render();
            } else {
                foundry.applications.instances.get('narrative-countdowns')?.render();
                foundry.applications.instances.get('encounter-countdowns')?.render();
            }

            return false;
        }
    });
};

const preloadHandlebarsTemplates = async function () {
    foundry.applications.handlebars.loadTemplates({
        'daggerheart.inventory-items':
            'systems/daggerheart/templates/sheets/global/partials/inventory-fieldset-items-V2.hbs',
        'daggerheart.inventory-item': 'systems/daggerheart/templates/sheets/global/partials/inventory-item-V2.hbs'
    });
    return foundry.applications.handlebars.loadTemplates([
        'systems/daggerheart/templates/sheets/global/tabs/tab-navigation.hbs',
        'systems/daggerheart/templates/sheets/global/partials/action-item.hbs',
        'systems/daggerheart/templates/sheets/global/partials/domain-card-item.hbs',
        'systems/daggerheart/templates/sheets/global/partials/item-resource.hbs',
        'systems/daggerheart/templates/sheets/global/partials/resource-section.hbs',
        'systems/daggerheart/templates/components/card-preview.hbs',
        'systems/daggerheart/templates/levelup/parts/selectable-card-preview.hbs',
        'systems/daggerheart/templates/sheets/global/partials/feature-section-item.hbs',
        'systems/daggerheart/templates/ui/combatTracker/combatTrackerSection.hbs',
        'systems/daggerheart/templates/actionTypes/damage.hbs',
        'systems/daggerheart/templates/actionTypes/resource.hbs',
        'systems/daggerheart/templates/actionTypes/macro.hbs',
        'systems/daggerheart/templates/actionTypes/uses.hbs',
        'systems/daggerheart/templates/actionTypes/roll.hbs',
        'systems/daggerheart/templates/actionTypes/save.hbs',
        'systems/daggerheart/templates/actionTypes/cost.hbs',
        'systems/daggerheart/templates/actionTypes/range-target.hbs',
        'systems/daggerheart/templates/actionTypes/effect.hbs',
        'systems/daggerheart/templates/actionTypes/beastform.hbs',
        'systems/daggerheart/templates/settings/components/settings-item-line.hbs',
        'systems/daggerheart/templates/ui/tooltip/parts/tooltipChips.hbs',
        'systems/daggerheart/templates/ui/tooltip/parts/tooltipTags.hbs',
        'systems/daggerheart/templates/dialogs/downtime/activities.hbs',
        'systems/daggerheart/templates/dialogs/dice-roll/costSelection.hbs',

        
        'systems/daggerheart/templates/ui/chat/parts/roll-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/damage-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/target-part.hbs',
        'systems/daggerheart/templates/ui/chat/parts/button-part.hbs',
    ]);
};

const registerDHSettings = () => {
    registerMenuSettings();
    registerMenus();
    registerNonConfigSettings();
};

const registerMenuSettings = () => {
    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules, {
        scope: 'world',
        config: false,
        type: DhVariantRules
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation, {
        scope: 'world',
        config: false,
        type: DhAutomation
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Homebrew, {
        scope: 'world',
        config: false,
        type: DhHomebrew,
        onChange: value => {
            if (value.maxFear) {
                if (ui.resources) ui.resources.render({ force: true });
            }
        }
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, {
        scope: 'client',
        config: false,
        type: DhAppearance,
        onChange: value => {
            if (value.displayFear) {
                if (ui.resources) {
                    if (value.displayFear === 'hide') ui.resources.close({ allowed: true });
                    else ui.resources.render({ force: true });
                }
            }
        }
    });
};

const registerMenus = () => {
    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.Automation.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.name'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.automation.hint'),
        icon: CONFIG.DH.SETTINGS.menu.Automation.Icon,
        type: DhAutomationSettings,
        restricted: true
    });
    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.Homebrew.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.name'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.homebrew.hint'),
        icon: CONFIG.DH.SETTINGS.menu.Homebrew.Icon,
        type: DhHomebrewSettings,
        restricted: true
    });

    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.appearance, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.title'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.appearance.hint'),
        icon: 'fa-solid fa-palette',
        type: DHAppearanceSettings,
        restricted: false
    });

    game.settings.registerMenu(CONFIG.DH.id, CONFIG.DH.SETTINGS.menu.VariantRules.Name, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.title'),
        label: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.label'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Menu.variantRules.hint'),
        icon: CONFIG.DH.SETTINGS.menu.VariantRules.Icon,
        type: DHVariantRuleSettings,
        restricted: true
    });
};

const registerNonConfigSettings = () => {
    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion, {
        scope: 'world',
        config: false,
        type: String
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LevelTiers, {
        scope: 'world',
        config: false,
        type: DhLevelTiers,
        default: defaultLevelTiers
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Resources.Fear, {
        name: game.i18n.localize('DAGGERHEART.SETTINGS.Resources.fear.name'),
        hint: game.i18n.localize('DAGGERHEART.SETTINGS.Resources.fear.hint'),
        scope: 'world',
        config: false,
        type: Number,
        default: 0,
        onChange: () => {
            if (ui.resources) ui.resources.render({ force: true });
            ui.combat.render({ force: true });
        }
    });

    game.settings.register(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Countdowns, {
        scope: 'world',
        config: false,
        type: DhCountdowns
    });
};

async function runMigrations() {
    let lastMigrationVersion = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion);
    if (!lastMigrationVersion) lastMigrationVersion = '1.0.6';

    if (foundry.utils.isNewerVersion('1.1.0', lastMigrationVersion)) {
        const lockedPacks = [];
        const compendiumActors = [];
        for (let pack of game.packs) {
            if (pack.locked) {
                lockedPacks.push(pack.collection);
                await pack.configure({ locked: false });
            }
            const documents = await pack.getDocuments();
            compendiumActors.push(...documents.filter(x => x.type === 'character'));
        }

        [...compendiumActors, ...game.actors].forEach(actor => {
            const items = actor.items.reduce((acc, item) => {
                if (item.type === 'feature') {
                    const { originItemType, isMulticlass, identifier } = item.system;
                    const base = originItemType
                        ? actor.items.find(
                              x => x.type === originItemType && Boolean(isMulticlass) === Boolean(x.system.isMulticlass)
                          )
                        : null;
                    if (base) {
                        const feature = base.system.features.find(x => x.item && x.item.uuid === item.uuid);
                        if (feature && identifier !== 'multiclass') {
                            acc.push({ _id: item.id, system: { identifier: feature.type } });
                        }
                    }
                }

                return acc;
            }, []);

            actor.updateEmbeddedDocuments('Item', items);
        });

        for (let packId of lockedPacks) {
            const pack = game.packs.get(packId);
            await pack.configure({ locked: true });
        }

        lastMigrationVersion = '1.1.0';
    }

    if (foundry.utils.isNewerVersion('1.1.1', lastMigrationVersion)) {
        const lockedPacks = [];
        const compendiumClasses = [];
        const compendiumActors = [];
        for (let pack of game.packs) {
            if (pack.locked) {
                lockedPacks.push(pack.collection);
                await pack.configure({ locked: false });
            }
            const documents = await pack.getDocuments();
            compendiumClasses.push(...documents.filter(x => x.type === 'class'));
            compendiumActors.push(...documents.filter(x => x.type === 'character'));
        }

        [...compendiumActors, ...game.actors.filter(x => x.type === 'character')].forEach(char => {
            const multiclass = char.items.find(x => x.type === 'class' && x.system.isMulticlass);
            const multiclassSubclass =
                multiclass?.system?.subclasses?.length > 0 ? multiclass.system.subclasses[0] : null;
            char.items.forEach(item => {
                if (item.type === 'feature' && item.system.identifier === 'multiclass') {
                    const base = item.system.originItemType === 'class' ? multiclass : multiclassSubclass;
                    if (base) {
                        const baseFeature = base.system.features.find(x => x.item.name === item.name);
                        if (baseFeature) {
                            item.update({
                                system: {
                                    multiclassOrigin: true,
                                    identifier: baseFeature.type
                                }
                            });
                        }
                    }
                }
            });
        });

        const worldClasses = game.items.filter(x => x.type === 'class');
        for (let classVal of [...compendiumClasses, ...worldClasses]) {
            for (let subclass of classVal.system.subclasses) {
                await subclass.update({ 'system.linkedClass': classVal.uuid });
            }
        }

        for (let packId of lockedPacks) {
            const pack = game.packs.get(packId);
            await pack.configure({ locked: true });
        }

        lastMigrationVersion = '1.1.1';
    }

    await game.settings.set(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.LastMigrationVersion, lastMigrationVersion);
}

class DhMeasuredTemplate extends foundry.canvas.placeables.MeasuredTemplate {
    _refreshRulerText() {
        super._refreshRulerText();

        const rangeMeasurementSettings = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.variantRules
        ).rangeMeasurement;
        if (rangeMeasurementSettings.enabled) {
            const splitRulerText = this.ruler.text.split(' ');
            if (splitRulerText.length > 0) {
                const rulerValue = Number(splitRulerText[0]);
                const vagueLabel = this.constructor.getDistanceLabel(rulerValue, rangeMeasurementSettings);
                this.ruler.text = vagueLabel;
            }
        }
    }

    static getDistanceLabel(distance, settings) {
        if (distance <= settings.melee) {
            return game.i18n.localize('DAGGERHEART.CONFIG.Range.melee.name');
        }
        if (distance <= settings.veryClose) {
            return game.i18n.localize('DAGGERHEART.CONFIG.Range.veryClose.name');
        }
        if (distance <= settings.close) {
            return game.i18n.localize('DAGGERHEART.CONFIG.Range.close.name');
        }
        if (distance <= settings.far) {
            return game.i18n.localize('DAGGERHEART.CONFIG.Range.far.name');
        }
        if (distance > settings.far) {
            return game.i18n.localize('DAGGERHEART.CONFIG.Range.veryFar.name');
        }

        return '';
    }
}

class DhpRuler extends foundry.canvas.interaction.Ruler {
    _getWaypointLabelContext(waypoint, state) {
        const context = super._getWaypointLabelContext(waypoint, state);
        if (!context) return;

        const range = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement;

        if (range.enabled) {
            const distance = DhMeasuredTemplate.getDistanceLabel(waypoint.measurement.distance.toNearest(0.01), range);
            context.cost = { total: distance, units: null };
            context.distance = { total: distance, units: null };
        }

        return context;
    }
}

class DhTemplateLayer extends foundry.canvas.layers.TemplateLayer {
    static prepareSceneControls() {
        const sc = foundry.applications.ui.SceneControls;
        return {
            name: 'templates',
            order: 2,
            title: 'CONTROLS.GroupMeasure',
            icon: 'fa-solid fa-ruler-combined',
            visible: game.user.can('TEMPLATE_CREATE'),
            onChange: (event, active) => {
                if (active) canvas.templates.activate();
            },
            onToolChange: () => canvas.templates.setAllRenderFlags({ refreshState: true }),
            tools: {
                circle: {
                    name: 'circle',
                    order: 1,
                    title: 'CONTROLS.MeasureCircle',
                    icon: 'fa-regular fa-circle',
                    toolclip: {
                        src: 'toolclips/tools/measure-circle.webm',
                        heading: 'CONTROLS.MeasureCircle',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete'])
                    }
                },
                cone: {
                    name: 'cone',
                    order: 2,
                    title: 'CONTROLS.MeasureCone',
                    icon: 'fa-solid fa-angle-left',
                    toolclip: {
                        src: 'toolclips/tools/measure-cone.webm',
                        heading: 'CONTROLS.MeasureCone',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                inFront: {
                    name: 'inFront',
                    order: 3,
                    title: 'CONTROLS.inFront',
                    icon: 'fa-solid fa-eye',
                    toolclip: {
                        src: 'toolclips/tools/measure-cone.webm',
                        heading: 'CONTROLS.inFront',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                rect: {
                    name: 'rect',
                    order: 4,
                    title: 'CONTROLS.MeasureRect',
                    icon: 'fa-regular fa-square',
                    toolclip: {
                        src: 'toolclips/tools/measure-rect.webm',
                        heading: 'CONTROLS.MeasureRect',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                ray: {
                    name: 'ray',
                    order: 5,
                    title: 'CONTROLS.MeasureRay',
                    icon: 'fa-solid fa-up-down',
                    toolclip: {
                        src: 'toolclips/tools/measure-ray.webm',
                        heading: 'CONTROLS.MeasureRay',
                        items: sc.buildToolclipItems(['create', 'move', 'edit', 'hide', 'delete', 'rotate'])
                    }
                },
                clear: {
                    name: 'clear',
                    order: 6,
                    title: 'CONTROLS.MeasureClear',
                    icon: 'fa-solid fa-trash',
                    visible: game.user.isGM,
                    onChange: () => canvas.templates.deleteAll(),
                    button: true
                }
            },
            activeTool: 'circle'
        };
    }

    _onDragLeftStart(event) {
        const interaction = event.interactionData;

        // Snap the origin to the grid
        if (!event.shiftKey) interaction.origin = this.getSnappedPoint(interaction.origin);

        // Create a pending MeasuredTemplateDocument
        const tool = game.activeTool === 'inFront' ? 'cone' : game.activeTool;
        const previewData = {
            user: game.user.id,
            t: tool,
            x: interaction.origin.x,
            y: interaction.origin.y,
            sort: Math.max(this.getMaxSort() + 1, 0),
            distance: 1,
            direction: 0,
            fillColor: game.user.color || '#FF0000',
            hidden: event.altKey
        };
        const defaults = CONFIG.MeasuredTemplate.defaults;
        if (game.activeTool === 'cone') previewData.angle = defaults.angle;
        else if (game.activeTool === 'inFront') previewData.angle = 180;
        else if (game.activeTool === 'ray') previewData.width = defaults.width * canvas.dimensions.distance;
        const cls = foundry.utils.getDocumentClass('MeasuredTemplate');
        const doc = new cls(previewData, { parent: canvas.scene });

        // Create a preview MeasuredTemplate object
        const template = new this.constructor.placeableClass(doc);
        doc._object = template;
        interaction.preview = this.preview.addChild(template);
        template.draw();
    }
}

class DhTokenPlaceable extends foundry.canvas.placeables.Token {
    /** @inheritDoc */
    async _drawEffects() {
        this.effects.renderable = false;

        // Clear Effects Container
        this.effects.removeChildren().forEach(c => c.destroy());
        this.effects.bg = this.effects.addChild(new PIXI.Graphics());
        this.effects.bg.zIndex = -1;
        this.effects.overlay = null;

        // Categorize effects
        const statusMap = new Map(foundry.CONFIG.statusEffects.map(status => [status.id, status]));
        const activeEffects = (this.actor ? this.actor.effects.filter(x => !x.disabled) : []).reduce((acc, effect) => {
            acc.push(effect);

            const currentStatusActiveEffects = acc.filter(
                x => x.statuses.size === 1 && x.name === game.i18n.localize(statusMap.get(x.statuses.first())?.name)
            );
            for (var status of effect.statuses) {
                if (!currentStatusActiveEffects.find(x => x.statuses.has(status))) {
                    const statusData = statusMap.get(status);
                    if (statusData) {
                        acc.push({
                            name: game.i18n.localize(statusData.name),
                            statuses: [status],
                            img: statusData.icon,
                            tint: effect.tint
                        });
                    }
                }
            }

            return acc;
        }, []);
        const overlayEffect = activeEffects.findLast(e => e.img && e.getFlag?.('core', 'overlay'));

        // Draw effects
        const promises = [];
        for (const [i, effect] of activeEffects.entries()) {
            if (!effect.img) continue;
            const promise =
                effect === overlayEffect
                    ? this._drawOverlay(effect.img, effect.tint)
                    : this._drawEffect(effect.img, effect.tint);
            promises.push(
                promise.then(e => {
                    if (e) e.zIndex = i;
                })
            );
        }
        await Promise.allSettled(promises);

        this.effects.sortChildren();
        this.effects.renderable = true;
        this.renderFlags.set({ refreshEffects: true });
    }

    /** @inheritDoc */
    _drawBar(number, bar, data) {
        const val = Number(data.value);
        Math.clamp(val, 0, data.max) / data.max;

        // Determine sizing
        const { width, height } = this.document.getSize();
        const s = canvas.dimensions.uiScale;
        const bw = width;
        const bh = 8 * (this.document.height >= 2 ? 1.5 : 1) * s;

        // Determine the color to use
        const fillColor =
            number === 0 ? foundry.utils.Color.fromRGB([1, 0, 0]) : foundry.utils.Color.fromString('#0032b1');

        // Draw the bar
        const widthUnit = bw / data.max;
        bar.clear().lineStyle(s, 0x000000, 1.0);
        const sections = [...Array(data.max).keys()];
        for (let mark of sections) {
            const x = mark * widthUnit;
            const marked = mark + 1 <= data.value;
            const color = marked ? fillColor : foundry.utils.Color.fromRGB([0, 0, 0]);
            if (mark === 0 || mark === sections.length - 1) {
                bar.beginFill(color, marked ? 1.0 : 0.5).drawRect(x, 0, widthUnit, bh, 2 * s); // Would like drawRoundedRect, but it's very troublsome with the corners. Leaving for now.
            } else {
                bar.beginFill(color, marked ? 1.0 : 0.5).drawRect(x, 0, widthUnit, bh, 2 * s);
            }
        }

        // Set position
        const posY = number === 0 ? height - bh : 0;
        bar.position.set(0, posY);
        return true;
    }
}

class DhpTokenRuler extends foundry.canvas.placeables.tokens.TokenRuler {
    _getWaypointLabelContext(waypoint, state) {
        const context = super._getWaypointLabelContext(waypoint, state);
        if (!context) return;

        const range = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.variantRules).rangeMeasurement;

        if (range.enabled) {
            const distance = DhMeasuredTemplate.getDistanceLabel(waypoint.measurement.distance.toNearest(0.01), range);
            context.cost = { total: distance, units: null };
            context.distance = { total: distance, units: null };
        }

        return context;
    }
}

Hooks.once('init', () => {
    CONFIG.DH = SYSTEM;
    game.system.api = {
        applications,
        models,
        documents,
        dice,
        fields
    };

    CONFIG.TextEditor.enrichers.push(...enricherConfig);

    CONFIG.statusEffects = [
        ...CONFIG.statusEffects.filter(x => !['dead', 'unconscious'].includes(x.id)),
        ...Object.values(SYSTEM.GENERAL.conditions).map(x => ({
            ...x,
            name: game.i18n.localize(x.name),
            systemEffect: true
        }))
    ];

    CONFIG.Dice.daggerheart = {
        DHRoll: DHRoll,
        DualityRoll: DualityRoll,
        D20Roll: D20Roll,
        DamageRoll: DamageRoll
    };

    CONFIG.Dice.rolls = [BaseRoll, DHRoll, DualityRoll, D20Roll, DamageRoll];
    CONFIG.MeasuredTemplate.objectClass = DhMeasuredTemplate;

    const { DocumentSheetConfig } = foundry.applications.apps;
    CONFIG.Token.documentClass = DHToken;
    CONFIG.Token.prototypeSheetClass = DhPrototypeTokenConfig;
    DocumentSheetConfig.unregisterSheet(TokenDocument, 'core', foundry.applications.sheets.TokenConfig);
    DocumentSheetConfig.registerSheet(TokenDocument, SYSTEM.id, DhTokenConfig, {
        makeDefault: true
    });

    CONFIG.Item.documentClass = DHItem;

    //Registering the Item DataModel
    CONFIG.Item.dataModels = config;

    const { Items, Actors } = foundry.documents.collections;
    Items.unregisterSheet('core', foundry.applications.sheets.ItemSheetV2);
    Items.registerSheet(SYSTEM.id, AncestrySheet, { types: ['ancestry'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, CommunitySheet, { types: ['community'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, ClassSheet, { types: ['class'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, SubclassSheet, { types: ['subclass'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, FeatureSheet, { types: ['feature'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, DomainCardSheet, { types: ['domainCard'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, LootSheet, {
        types: ['loot'],
        makeDefault: true
    });
    Items.registerSheet(SYSTEM.id, ConsumableSheet, { types: ['consumable'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, WeaponSheet, { types: ['weapon'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, ArmorSheet, { types: ['armor'], makeDefault: true });
    Items.registerSheet(SYSTEM.id, BeastformSheet, { types: ['beastform'], makeDefault: true });

    CONFIG.Actor.documentClass = DhpActor;
    CONFIG.Actor.dataModels = config$2;

    Actors.unregisterSheet('core', foundry.applications.sheets.ActorSheetV2);
    Actors.registerSheet(SYSTEM.id, CharacterSheet, { types: ['character'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, DhCompanionSheet, { types: ['companion'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, AdversarySheet, { types: ['adversary'], makeDefault: true });
    Actors.registerSheet(SYSTEM.id, DhpEnvironment, {
        types: ['environment'],
        makeDefault: true
    });

    CONFIG.ActiveEffect.documentClass = DhActiveEffect;
    CONFIG.ActiveEffect.dataModels = config$3;

    DocumentSheetConfig.unregisterSheet(
        CONFIG.ActiveEffect.documentClass,
        'core',
        foundry.applications.sheets.ActiveEffectConfig
    );
    DocumentSheetConfig.registerSheet(
        CONFIG.ActiveEffect.documentClass,
        SYSTEM.id,
        DhActiveEffectConfig,
        {
            makeDefault: true
        }
    );

    CONFIG.Token.hudClass = DHTokenHUD;

    CONFIG.Combat.dataModels = {
        base: DhCombat
    };

    CONFIG.Combatant.dataModels = {
        base: DhCombatant
    };

    CONFIG.ChatMessage.dataModels = config$1;
    CONFIG.ChatMessage.documentClass = DhpChatMessage;
    CONFIG.ChatMessage.template = 'systems/daggerheart/templates/ui/chat/chat-message.hbs';

    CONFIG.Canvas.rulerClass = DhpRuler;
    CONFIG.Canvas.layers.templates.layerClass = DhTemplateLayer;
    CONFIG.Token.objectClass = DhTokenPlaceable;
    CONFIG.Combat.documentClass = DhpCombat;
    CONFIG.ui.combat = DhCombatTracker;
    CONFIG.ui.chat = DhpChatLog;
    CONFIG.ui.hotbar = DhHotbar;
    CONFIG.Token.rulerClass = DhpTokenRuler;

    CONFIG.ui.resources = FearTracker;
    CONFIG.ux.ContextMenu = DHContextMenu;
    CONFIG.ux.TooltipManager = DhTooltipManager;

    CONFIG.ux.TemplateManager = new DhTemplateManager();

    game.socket.on(`system.${SYSTEM.id}`, handleSocketEvent);

    // Make Compendium Dialog resizable
    foundry.applications.sidebar.apps.Compendium.DEFAULT_OPTIONS.window.resizable = true;

    registerDHSettings();
    RegisterHandlebarsHelpers.registerHelpers();

    return preloadHandlebarsTemplates();
});

Hooks.on('ready', async () => {
    ui.resources = new CONFIG.ui.resources();
    if (game.settings.get(SYSTEM.id, SYSTEM.SETTINGS.gameSettings.appearance).displayFear !== 'hide')
        ui.resources.render({ force: true });

    registerCountdownHooks();
    registerSocketHooks();
    registerRollDiceHooks();
    registerUserQueries();

    if (!game.user.getFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.welcomeMessage)) {
        const welcomeMessage = await foundry.utils.fromUuid(CONFIG.DH.GENERAL.compendiumJournals.welcome);
        if (welcomeMessage) {
            welcomeMessage.sheet.render({ force: true });
            game.user.setFlag(CONFIG.DH.id, CONFIG.DH.FLAGS.userFlags.welcomeMessage, true);
        }
    }

    runMigrations();
});

Hooks.once('dicesoniceready', () => {});

Hooks.on('renderChatMessageHTML', (_, element, message) => {
    enricherRenderSetup(element);
    const cssClass = message.message.flags?.daggerheart?.cssClass;
    if (cssClass) cssClass.split(' ').forEach(cls => element.classList.add(cls));
});

Hooks.on('renderJournalEntryPageProseMirrorSheet', (_, element) => {
    enricherRenderSetup(element);
});

Hooks.on('renderHandlebarsApplication', (_, element) => {
    enricherRenderSetup(element);
});

Hooks.on('chatMessage', (_, message) => {
    if (message.startsWith('/dr')) {
        const result =
            message.trim().toLowerCase() === '/dr' ? { result: {} } : rollCommandToJSON(message.replace(/\/dr\s?/, ''));
        if (!result) {
            ui.notifications.error(game.i18n.localize('DAGGERHEART.UI.Notifications.dualityParsing'));
            return false;
        }

        const { result: rollCommand, flavor } = result;

        const reaction = rollCommand.reaction;
        const traitValue = rollCommand.trait?.toLowerCase();
        const advantage = rollCommand.advantage
            ? CONFIG.DH.ACTIONS.advantageState.advantage.value
            : rollCommand.disadvantage
              ? CONFIG.DH.ACTIONS.advantageState.disadvantage.value
              : undefined;
        const difficulty = rollCommand.difficulty;

        const target = getCommandTarget({ allowNull: true });
        const title = traitValue
            ? game.i18n.format('DAGGERHEART.UI.Chat.dualityRoll.abilityCheckTitle', {
                  ability: game.i18n.localize(SYSTEM.ACTOR.abilities[traitValue].label)
              })
            : game.i18n.localize('DAGGERHEART.GENERAL.duality');

        enrichedDualityRoll({
            reaction,
            traitValue,
            target,
            difficulty,
            title,
            label: 'test',
            advantage
        });
        return false;
    }
});

Hooks.on('renderJournalDirectory', async (tab, html, _, options) => {
    if (tab.id === 'journal') {
        if (options.parts && !options.parts.includes('footer')) return;

        const buttons = tab.element.querySelector('.directory-footer.action-buttons');
        const title = game.i18n.format('DAGGERHEART.APPLICATIONS.Countdown.title', {
            type: game.i18n.localize('DAGGERHEART.APPLICATIONS.Countdown.types.narrative')
        });
        buttons.insertAdjacentHTML(
            'afterbegin',
            `
            <button id="narrative-countdown-button">
                <i class="fa-solid fa-stopwatch"></i>
                <span style="font-weight: 400; font-family: var(--font-sans);">${title}</span>
            </button>`
        );

        buttons.querySelector('#narrative-countdown-button').onclick = async () => {
            new NarrativeCountdowns().open();
        };
    }
});

Hooks.on('moveToken', async (movedToken, data) => {
    const effectsAutomation = game.settings.get(CONFIG.DH.id, CONFIG.DH.SETTINGS.gameSettings.Automation).effects;
    if (!effectsAutomation.rangeDependent) return;

    const rangeDependantEffects = movedToken.actor.effects.filter(effect => effect.system.rangeDependence?.enabled);

    const updateEffects = async (disposition, token, effects, effectUpdates) => {
        const rangeMeasurement = game.settings.get(
            CONFIG.DH.id,
            CONFIG.DH.SETTINGS.gameSettings.variantRules
        ).rangeMeasurement;

        for (let effect of effects.filter(x => x.system.rangeDependence?.enabled)) {
            const { target, range, type } = effect.system.rangeDependence;
            if ((target === 'friendly' && disposition !== 1) || (target === 'hostile' && disposition !== -1))
                return false;

            const distanceBetween = canvas.grid.measurePath([
                { ...movedToken.toObject(), x: data.destination.x, y: data.destination.y },
                token
            ]).distance;
            const distance = rangeMeasurement[range];

            const reverse = type === CONFIG.DH.GENERAL.rangeInclusion.outsideRange.id;
            const newDisabled = reverse ? distanceBetween <= distance : distanceBetween > distance;
            const oldDisabled = effectUpdates[effect.uuid] ? effectUpdates[effect.uuid].disabled : newDisabled;
            effectUpdates[effect.uuid] = {
                disabled: oldDisabled || newDisabled,
                value: effect
            };
        }
    };

    const effectUpdates = {};
    for (let token of game.scenes.find(x => x.active).tokens) {
        if (token.id !== movedToken.id) {
            await updateEffects(token.disposition, token, rangeDependantEffects, effectUpdates);
        }

        if (token.actor) await updateEffects(movedToken.disposition, token, token.actor.effects, effectUpdates);
    }

    for (let key in effectUpdates) {
        const effect = effectUpdates[key];
        await effect.value.update({ disabled: effect.disabled });
    }
});
//# sourceMappingURL=daggerheart.js.map
